<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <!-- 立即初始化关键变量 -->
    <script>
        // 确保lastUserInteractionTime变量在页面加载最早期就被初始化
        window.lastUserInteractionTime = Date.now();
        console.log('[内联脚本] 已初始化lastUserInteractionTime =', new Date(window.lastUserInteractionTime).toLocaleTimeString());
        
        // 初始化activeTimerReminders变量
        window.activeTimerReminders = new Map();
        console.log('[内联脚本] 已初始化activeTimerReminders');
        
        // 初始化自动语音播放开关
        window.autoSpeakEnabled = true;
        console.log('[内联脚本] 已初始化autoSpeakEnabled = true');
        
        // 初始化语音设置
        window.currentVoice = 'longxiaochun';
        window.currentAudio = null;
        console.log('[内联脚本] 已初始化语音设置');
    </script>
    
    <!-- 立即初始化timerSettings变量，确保在任何脚本执行前就存在 -->
    <script>
    (function() {
        console.log('[内联修复] 立即初始化timerSettings变量');
        
        // 在全局作用域定义timerSettings
        window.timerSettings = {
            repeatCount: 2,         // 默认重复次数
            intervalSeconds: 5,     // 默认间隔秒数
            autoStopOnResponse: true, // 默认有响应时停止提醒
            audioLoopCount: 1,      // 音频循环次数
            audioLoopInterval: 500  // 音频循环间隔
        };
        
        // 初始化计时器相关变量，避免类似的初始化顺序问题
        window.activeTimerReminders = new Map(); // 保存活动的提醒计时器
        window.lastUserInteractionTime = Date.now(); // 上次用户交互时间
        
        // 尝试从localStorage加载已保存的设置
        try {
            const savedSettings = localStorage.getItem('timerSettings');
            if (savedSettings) {
                const parsedSettings = JSON.parse(savedSettings);
                // 合并已保存的设置
                window.timerSettings = {...window.timerSettings, ...parsedSettings};
                console.log('[内联修复] 从localStorage加载了保存的设置');
            }
        } catch (error) {
            console.error('[内联修复] 加载设置出错:', error);
        }
        
        // 确保initSettingsPanel函数可以安全执行
        const originalInitSettingsPanel = window.initSettingsPanel;
        window.initSettingsPanel = function() {
            console.log('[内联修复] 调用安全版本的initSettingsPanel');
            
            // 再次确认timerSettings存在
            if (typeof window.timerSettings === 'undefined') {
                console.warn('[内联修复] timerSettings不存在，重新初始化');
                window.timerSettings = {
                    repeatCount: 2,
                    intervalSeconds: 5,
                    autoStopOnResponse: true,
                    audioLoopCount: 1,
                    audioLoopInterval: 500
                };
            }
            
            // 调用原始函数
            if (typeof originalInitSettingsPanel === 'function') {
                try {
                    originalInitSettingsPanel();
                } catch (e) {
                    console.error('[内联修复] 执行原始initSettingsPanel出错:', e);
                }
            }
        };
        
        console.log('[内联修复] 变量初始化和函数修复完成');
    })();
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能聊天</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background-color: #4CAF50;
            color: white;
            padding: 15px;
            text-align: center;
            border-radius: 5px 5px 0 0;
        }
        
        .chat-container {
            background-color: white;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .chat-messages {
            height: 400px;
            overflow-y: auto;
            padding: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 70%;
            word-wrap: break-word;
        }
        
        .user-message {
            background-color: #DCF8C6;
            margin-left: auto;
            border-bottom-right-radius: 5px;
        }
        
        .bot-message {
            background-color: #F1F0F0;
            margin-right: auto;
            border-bottom-left-radius: 5px;
        }
        
        .chat-input {
            display: flex;
            padding: 15px;
        }
        
        .chat-input input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
            font-size: 16px;
        }
        
        .chat-input button {
            margin-left: 10px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .chat-input button:hover {
            background-color: #45a049;
        }
        
        .typing-indicator {
            display: none;
            padding: 10px 15px;
            background-color: #f1f1f1;
            border-radius: 18px;
            margin-bottom: 15px;
            width: fit-content;
        }
        
        .typing-indicator span {
            height: 10px;
            width: 10px;
            float: left;
            margin: 0 1px;
            background-color: #9E9EA1;
            display: block;
            border-radius: 50%;
            opacity: 0.4;
        }
        
        .typing-indicator span:nth-of-type(1) {
            animation: 1s blink infinite 0.3333s;
        }
        
        .typing-indicator span:nth-of-type(2) {
            animation: 1s blink infinite 0.6666s;
        }
        
        .typing-indicator span:nth-of-type(3) {
            animation: 1s blink infinite 0.9999s;
        }
        
        @keyframes blink {
            50% {
                opacity: 1;
            }
        }
        
        .file-upload {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .file-upload input {
            display: none;
        }
        
        .file-upload label {
            padding: 8px 15px;
            background-color: #f1f1f1;
            border-radius: 20px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        .file-upload label:hover {
            background-color: #e1e1e1;
        }
        
        .file-preview {
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .file-item {
            position: relative;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .file-item img {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 5px;
        }
        
        .remove-file {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: #ff4d4d;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            cursor: pointer;
        }
        
        .file-status {
            margin-top: 5px;
            font-size: 14px;
            color: #666;
        }
        
        .nav-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background-color: #333;
        }
        
        .nav-bar a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
        }
        
        .nav-bar a:hover {
            background-color: #555;
            border-radius: 5px;
        }
        
        /* 控制台按钮样式 */
        .console-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
            transition: background-color 0.3s;
        }
        
        .console-button:hover {
            background-color: #45a049;
        }
        
        /* 重置按钮样式 */
        .reset-button {
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .reset-button:hover {
            background-color: #ff5252;
        }
        
        .actions {
            display: flex;
            justify-content: flex-end;
            margin-left: auto;
        }
        
        /* 录音按钮样式 */
        .record-button {
            margin-left: 10px;
            padding: 10px 20px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .record-button.recording {
            background-color: #cc0000;
            animation: pulse 1.5s infinite;
        }
        
        .record-button:hover {
            background-color: #d32f2f;
        }
        
        @keyframes pulse {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                opacity: 1;
            }
        }
        
        .recording-status {
            display: none;
            font-size: 14px;
            color: #f44336;
            margin-top: 5px;
            text-align: center;
        }
        
        /* 添加计时器历史记录按钮样式 */
        .timer-history-button {
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
            transition: background-color 0.3s;
        }
        
        .timer-history-button:hover {
            background-color: #0b7dda;
        }
        
        /* 计时器历史记录模态框样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 800px;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: #000;
        }
        
        .timer-history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .timer-history-table th, .timer-history-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .timer-history-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .timer-history-table th {
            padding-top: 12px;
            padding-bottom: 12px;
            background-color: #4CAF50;
            color: white;
        }
        
        .timer-history-table tr:hover {
            background-color: #ddd;
        }
        
        .no-history {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        
        /* 添加计时器设置面板样式 */
        .settings-panel {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin-top: 15px;
        }
        
        .settings-panel h3 {
            margin-top: 0;
            color: #4CAF50;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .settings-row label {
            flex: 1;
            margin-right: 10px;
        }
        
        .settings-row input, .settings-row select {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .settings-info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            font-style: italic;
        }
        
        .settings-toggle {
            background-color: #f1f1f1;
            color: #333;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 14px;
        }
        
        .settings-toggle:hover {
            background-color: #e1e1e1;
        }

        /* 模态窗口样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            max-width: 600px;
            position: relative;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #555;
        }

        .settings-container {
            margin-top: 15px;
        }

        .settings-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }

        .settings-section h3 {
            margin-top: 0;
            color: #4CAF50;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }

        .settings-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .save-btn, .test-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .save-btn {
            background-color: #4CAF50;
            color: white;
        }

        .test-btn {
            background-color: #2196F3;
            color: white;
        }

        .save-btn:hover {
            background-color: #45a049;
        }

        .test-btn:hover {
            background-color: #0b7dda;
        }
        
        /* 临时消息样式 */
        .temporary-message {
            opacity: 0.8;
            position: relative;
        }
        
        /* 加载动画样式 */
        .loading-dots {
            display: inline-block;
            margin-left: 10px;
            vertical-align: bottom;
        }
        
        .loading-dots span {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #777;
            margin-right: 3px;
            animation: dotPulse 1.5s infinite ease-in-out;
        }
        
        .loading-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .loading-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes dotPulse {
            0%, 100% { transform: scale(0.6); opacity: 0.6; }
            50% { transform: scale(1); opacity: 1; }
        }
        
        /* 消息文本样式 */
        .message-text {
            display: inline-block;
            vertical-align: middle;
        }
    </style>
    <!-- 计时器设置已通过内联脚本初始化，不再需要外部修复脚本 -->
    <!-- <script src="/js/timer-settings-init-quick-fix.js"></script> -->

    <!-- 禁用所有调试功能 -->
    <script>
    (function() {
        console.log('[调试禁用] 正在禁用所有调试面板和功能');
        
        // 添加CSS来隐藏调试面板
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            /* 隐藏所有调试元素 */
            #timerDebugPanel, #debugToggle, .debug-panel, .debug-toggle,
            [id^="debug-"], [class^="debug-"], [id*="debug"], [class*="debug"] {
                display: none !important;
                visibility: hidden !important;
                opacity: 0 !important;
                height: 0 !important;
                width: 0 !important;
                position: absolute !important;
                left: -9999px !important;
                top: -9999px !important;
                z-index: -9999 !important;
            }
        `;
        document.head.appendChild(styleElement);
        
        // 禁用调试面板相关函数
        window.addDebugToggleButton = function() {
            console.log('[调试禁用] 调试按钮功能已禁用');
            return false;
        };
        
        window.debugTimerForm = function() {
            console.log('[调试禁用] 调试面板功能已禁用');
            return false;
        };
        
        // 设置DOM加载后的处理
        document.addEventListener('DOMContentLoaded', function() {
            // 立即移除所有调试元素
            setTimeout(function removeDebugElements() {
                const selectors = [
                    '#timerDebugPanel', '#debugToggle', '.debug-panel', '.debug-toggle',
                    '[id^="debug-"]', '[class^="debug-"]'
                ];
                
                selectors.forEach(function(selector) {
                    document.querySelectorAll(selector).forEach(function(element) {
                        if (element && element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    });
                });
                
                // 禁用emergencyFunctions中的调试功能
                if (window.emergencyFunctions) {
                    window.emergencyFunctions.debugTimerForm = function() {
                        console.log('[调试禁用] 紧急函数中的调试面板功能已禁用');
                        return false;
                    };
                }
            }, 500);
            
            // 定期检查并移除调试元素
            setInterval(function() {
                document.querySelectorAll('#timerDebugPanel, #debugToggle, .debug-panel, .debug-toggle').forEach(function(element) {
                    if (element && element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                });
            }, 2000);
        });
    })();
    </script>
</head>
<body>
    <!-- 导航栏 -->
    <div class="nav-bar">
        <div class="nav-links">
            <a href="/">首页</a>
            <a href="/chat.html">聊天</a>
        </div>
        <div>
            <button class="console-button" onclick="window.location.href='/modbus.html'">控制台</button>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>智能聊天</h1>
            <button id="toggleSettings" class="settings-toggle">计时器设置</button>
        </div>
        
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages">
                <!-- 聊天消息将在这里显示 -->
            </div>
            
            <div class="typing-indicator" id="typingIndicator">
                <span></span>
                <span></span>
                <span></span>
            </div>
            
            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="输入您的问题..." autocomplete="off">
                <button id="sendButton">发送</button>
                <button id="recordButton" class="record-button">录音</button>
            </div>
            
            <div class="recording-status" id="recordingStatus">正在录音...</div>
            
            <div class="file-upload">
                <input type="file" id="fileInput" accept="image/*" multiple>
                <label for="fileInput">上传图片</label>
                <div id="fileStatus" class="file-status"></div>
            </div>
            
            <div class="file-preview" id="filePreview">
                <!-- 文件预览将在这里显示 -->
            </div>
        </div>
    </div>
    
    <!-- 计时器历史记录模态框 -->
    <div id="timerHistoryModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>计时器历史记录</h2>
            <div id="timerHistoryContent">
                <table class="timer-history-table">
                    <thead>
                        <tr>
                            <th>标题</th>
                            <th>消息</th>
                            <th>完成时间</th>
                        </tr>
                    </thead>
                    <tbody id="timerHistoryTableBody">
                        <!-- 计时器历史记录将在这里显示 -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- 添加设置面板 -->
    <!-- 
    <div id="timerSettings" class="settings-panel" style="display: none;">
        <h3>计时器提醒设置</h3>
        <div class="settings-row">
            <label for="reminderRepeatCount">提醒重复次数:</label>
            <input type="number" id="reminderRepeatCount" min="1" max="10" value="2">
        </div>
        <div class="settings-row">
            <label for="reminderInterval">重复间隔时间(秒):</label>
            <input type="number" id="reminderInterval" min="1" max="60" value="5">
        </div>
        <div class="settings-row">
            <label for="autoStopReminders">无人应答时停止提醒:</label>
            <select id="autoStopReminders">
                <option value="true" selected>是</option>
                <option value="false">否</option>
            </select>
        </div>
        <div class="settings-info">
            当计时器结束后，系统会播放提示音和消息，按照上述设置进行重复提醒，直到用户输入消息或达到最大重复次数。
        </div>
    </div>
    -->
    
    <!-- 计时器设置模态窗口 -->
    <div id="timerSettingsModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeTimerSettings">&times;</span>
            <h2>计时器音频设置</h2>
            <div class="settings-container">
                <div class="settings-section">
                    <h3>提醒重复设置</h3>
                    <div class="settings-row">
                        <label for="reminderRepeatCount">提醒重复次数:</label>
                        <input type="number" id="reminderRepeatCount" min="1" max="10" value="2">
                    </div>
                    <div class="settings-row">
                        <label for="reminderInterval">重复间隔时间(秒):</label>
                        <input type="number" id="reminderInterval" min="1" max="60" value="5">
                    </div>
                    <div class="settings-row">
                        <label for="autoStopReminders">无人应答时停止提醒:</label>
                        <select id="autoStopReminders">
                            <option value="true" selected>是</option>
                            <option value="false">否</option>
                        </select>
                    </div>
                    <div class="settings-info">
                        当计时器结束后，系统会播放提示音和消息，按照上述设置进行重复提醒，直到用户输入消息或达到最大重复次数。
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3>音频循环设置</h3>
                    <div class="settings-row">
                        <label for="audioLoopCount">音频循环次数:</label>
                        <input type="number" id="audioLoopCount" min="1" max="5" value="1">
                    </div>
                    <div class="settings-row">
                        <label for="audioLoopInterval">音频循环间隔(毫秒):</label>
                        <input type="number" id="audioLoopInterval" min="0" max="5000" step="100" value="500">
                    </div>
                    <div class="settings-info">
                        音频循环设置控制单次提醒中的循环播放次数和间隔，增强提醒效果。
                    </div>
                </div>
                
                <div class="settings-buttons">
                    <button id="saveTimerSettings" class="save-btn">保存设置</button>
                    <button id="testAudioLoop" class="test-btn">测试循环播放</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // DOM元素
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const typingIndicator = document.getElementById('typingIndicator');
        const fileInput = document.getElementById('fileInput');
        const fileStatus = document.getElementById('fileStatus');
        const filePreview = document.getElementById('filePreview');
        const recordButton = document.getElementById('recordButton');
        
        // 全局变量
        let conversationId = localStorage.getItem('lastSessionId') || '';
        let userId = localStorage.getItem('userId') || generateUserId();
        let ws = null;
        let sessionStartTime = Date.now();
        let mediaSource = null;
        let sourceBuffer = null;
        let audioElement = null;
        let audioChunks = [];
        let audioQueue = [];
        let pendingAudioUrls = [];
        let isAudioPlaying = false;
        let isProcessingAudio = false;
        let audioInitialized = false;
        let processedUrls = new Set();
        let deletedFiles = new Set();
        let totalAudioReceived = 0;
        let totalAudioPlayed = 0;
        let currentPlayingAudio = null;
        let currentTaskId = null; // 添加当前任务ID变量
        let isStreamingResponse = false; // 标记是否正在接收流式响应
        let uploadedFiles = []; // 添加上传文件数组
        let botMessage = ''; // 添加机器人消息变量，用于累加显示消息内容
        let currentConversationRoundId = ''; // 当前对话轮次ID，用于过滤音频
        
        // 录音相关变量
        let isRecording = false;
        let mediaRecorder = null;
        let audioStream = null;
        let audioTracks = null;
        let recordingStartTime = 0;
        
        // 添加用户交互事件，解锁音频播放
        document.addEventListener('click', unlockAudio);
        document.addEventListener('keydown', unlockAudio);
        
        // 初始化页面
        document.addEventListener('DOMContentLoaded', () => {
            console.log('页面已加载，初始化聊天界面');
            
            // 初始化并获取用户标识
            userId = localStorage.getItem('userId');
            if (!userId) {
                userId = 'user-' + Date.now();
                localStorage.setItem('userId', userId);
                console.log(`生成新的用户标识: ${userId}`);
            } else {
                console.log(`使用已保存的用户标识: ${userId}`);
            }
            
            // 初始化语音识别处理状态
            window.isProcessingAjaxRecognition = false;
            
            // 尝试从localStorage恢复会话ID
            const savedSessionId = localStorage.getItem('lastSessionId');
            const savedSessionDate = localStorage.getItem('lastSessionDate');
            const currentDate = getCurrentDateString();
            
            if (savedSessionId && savedSessionDate === currentDate) {
                // 如果有保存的会话ID，且是今天的，则使用它
                conversationId = savedSessionId;
                console.log(`从localStorage恢复会话ID: ${conversationId}`);
            } else {
                // 否则初始化/检查会话ID
                checkAndUpdateConversationId();
                console.log('当前会话ID:', conversationId);
            }
            
            // 添加事件监听器
            sendButton.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // 阻止默认的回车换行
                    sendMessage();
                }
            });
            fileInput.addEventListener('change', handleFileUpload);
            
            // 初始化音频相关变量
            mediaSource = null;
            sourceBuffer = null;
            audioElement = null;
            audioChunks = [];
            audioQueue = [];
            pendingAudioUrls = [];
            isAudioPlaying = false;
            isProcessingAudio = false;
            audioInitialized = false;
            processedUrls = new Set();
            deletedFiles = new Set();
            totalAudioReceived = 0;
            totalAudioPlayed = 0;
            currentPlayingAudio = null;
            console.log('音频变量已初始化');
            
            // 添加欢迎消息
            addMessage('您好！我是智能助手，有什么可以帮您的吗？', 'bot');
            
            // 清理旧会话的音频文件
            cleanupOldAudioFiles(sessionStartTime);
            
            // 绑定重置按钮事件
            const resetButton = document.getElementById('reset-button');
            if (resetButton) {
                resetButton.addEventListener('click', resetConversation);
            } else {
                console.warn('重置按钮元素未找到，跳过事件绑定');
            }
            
            // 初始化录音功能
            initRecordingFeature();
            
            // 建立WebSocket连接
            connectWebSocket();
            
            // 初始化计时器历史记录功能
            initTimerHistory();
            
            // 初始化设置面板
            initSettingsPanel();
        });
        
        // 连接WebSocket
        function connectWebSocket() {
            const wsUrl = `ws://${window.location.host}`;
            
            console.log(`尝试连接WebSocket: ${wsUrl}`);
            ws = new WebSocket(wsUrl);
            
            // 语音合成和播放相关函数
            function requestSpeech(text) {
                if (!text) return;
                console.log('请求语音合成:', text);
                
                // 停止当前正在播放的音频
                stopAllAudio();
                
                // 调用TTS API
                fetch('/api/tts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        voice: window.currentVoice || 'longxiaochun'
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.audioUrl) {
                        playAudio(data.audioUrl);
                    } else {
                        console.error('语音合成失败:', data.error || '未知错误');
                    }
                })
                .catch(error => {
                    console.error('语音合成请求失败:', error);
                });
            }

            function playAudio(audioUrl) {
                if (!audioUrl) return;
                
                // 停止当前正在播放的音频
                stopAllAudio();
                
                // 创建新的音频实例并播放
                window.currentAudio = new Audio(audioUrl);
                window.currentAudio.play().catch(error => {
                    console.error('音频播放失败:', error);
                });
            }

            function stopAllAudio() {
                if (window.currentAudio) {
                    window.currentAudio.pause();
                    window.currentAudio = null;
                }
                console.log('停止所有正在播放的音频');
            }

            // 切换自动语音播放
            window.toggleAutoSpeak = function() {
                window.autoSpeakEnabled = !window.autoSpeakEnabled;
                console.log('自动语音播放已' + (window.autoSpeakEnabled ? '启用' : '禁用'));
                return window.autoSpeakEnabled;
            }

            // 切换语音
            window.changeVoice = function(voice) {
                window.currentVoice = voice;
                console.log('已切换到语音:', voice);
            }
            
            ws.onopen = () => {
                console.log('WebSocket连接已建立');
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('收到WebSocket消息类型:', data.type);
                    
                    // 处理语音识别结果
                    if (data.type === 'asr_result') {
                        // 如果AJAX请求正在处理，跳过WebSocket更新
                        if (window.isProcessingAjaxRecognition !== true) {
                            updateRecognitionText(data);
                        } else {
                            console.log('AJAX识别请求正在处理中，跳过WebSocket asr_result更新');
                        }
                    }
                    // 处理语音识别完成事件
                    else if (data.type === 'asr_complete') {
                        // 如果AJAX请求正在处理，跳过WebSocket更新
                        if (window.isProcessingAjaxRecognition !== true) {
                            handleRecognitionComplete(data);
                        } else {
                            console.log('AJAX识别请求正在处理中，跳过WebSocket asr_complete更新');
                        }
                    }
                    // 处理计时器完成事件
                    else if (data.type === 'timer_completed') {
                        // 计时器完成
                        handleTimerCompleted(data.timer);
                    }
                    // 添加对聊天响应的处理
                    else if (data.type === 'chat_response') {
                        // 隐藏输入指示器
                        typingIndicator.style.display = 'none';
                        
                        if (data.success) {
                            // 添加机器人消息
                            console.log('收到回复:', data.answer);
                            addMessage(data.answer, 'bot');
                            
                            // 消息分类标识（可选：如果需要在UI上展示分类）
                            if (data.messageType) {
                                console.log(`消息分类: ${data.messageType}`);
                            }
                            
                            // 如果启用了自动语音
                            if (window.autoSpeakEnabled) {
                                // 请求语音合成
                                requestSpeech(data.answer);
                            }
                        } else {
                            // 处理错误
                            addMessage(data.error || '抱歉，处理您的请求时出错了。', 'bot');
                        }
                        
                        // 滚动到底部
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                    // 处理聊天响应更新
                    else if (data.type === 'chat_response_update') {
                        console.log('收到聊天响应更新:', data.answer);
                        
                        if (data.success) {
                            // 添加更新的回复
                            addMessage(data.answer, 'bot');
                            
                            // 如果启用了自动语音，播放更新回复的语音
                            if (window.autoSpeakEnabled) {
                                // 请求语音合成
                                requestSpeech(data.answer);
                            }
                        }
                    }
                    // 处理TTS响应
                    else if (data.type === 'tts_response') {
                        if (data.success && data.audioUrl) {
                            playAudio(data.audioUrl);
                        } else {
                            console.error('TTS处理失败:', data.error || '未知错误');
                        }
                    }
                } catch (error) {
                    console.error('解析WebSocket消息失败:', error);
                }
            };
            
            ws.onclose = () => {
                console.log('WebSocket连接已关闭，尝试重连...');
                setTimeout(connectWebSocket, 3000);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket错误:', error);
            };
        }
        
        // 初始化录音功能
        function initRecordingFeature() {
            console.log('初始化录音功能');
            
            // 检查浏览器是否支持getUserMedia
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('浏览器不支持录音功能');
                recordButton.style.display = 'none';
                return;
            }
            
            // 更新录音按钮状态 - 增强版本
            function updateRecordingButtonState(state) {
                console.log(`更新录音按钮状态: ${state}`);
                
                // 移除所有可能的类
                recordButton.classList.remove('recording', 'processing', 'error');
                
                // 根据状态设置相应的类和属性
                switch (state) {
                    case 'idle':
                        // 空闲状态
                        recordButton.textContent = '录音';
                        recordButton.disabled = false;
                        recordButton.title = '开始录音';
                        
                        // 隐藏状态提示
                        if (recordingStatus.textContent === '正在录音...' || 
                            recordingStatus.textContent.startsWith('正在录音... ')) {
                            recordingStatus.style.display = 'none';
                        }
                        break;
                        
                    case 'recording':
                        // 录音中状态
                        recordButton.classList.add('recording');
                        recordButton.textContent = '停止';
                        recordButton.disabled = false;
                        recordButton.title = '停止录音';
                        
                        // 显示录音状态
                        recordingStatus.style.display = 'block';
                        recordingStatus.textContent = '正在录音...';
                        break;
                        
                    case 'processing':
                        // 处理中状态
                        recordButton.classList.add('processing');
                        recordButton.textContent = '处理中...';
                        recordButton.disabled = true;
                        recordButton.title = '处理中...';
                        
                        // 显示处理状态
                        recordingStatus.style.display = 'block';
                        recordingStatus.textContent = '正在处理录音...';
                        break;
                        
                    case 'error':
                        // 错误状态
                        recordButton.classList.add('error');
                        recordButton.textContent = '重试';
                        recordButton.disabled = false;
                        recordButton.title = '录音出错，点击重试';
                        
                        // 如果没有特定错误消息，显示通用消息
                        if (recordingStatus.textContent === '') {
                            recordingStatus.textContent = '录音出错，请重试';
                        }
                        
                        recordingStatus.style.display = 'block';
                        break;
                    
                    default:
                        console.error(`未知的按钮状态: ${state}`);
                        recordButton.textContent = '录音';
                        recordButton.disabled = false;
                        break;
                }
                
                // 日志当前状态
                console.log(`按钮状态已更新为: ${state}, 禁用状态: ${recordButton.disabled}, 文本: ${recordButton.textContent}`);
            }
            
            // 显示录音状态信息
            function showStatus(type, message) {
                console.log(`状态更新: [${type}] ${message}`);
                
                if (!recordingStatus) {
                    console.error('录音状态元素未找到');
                    return;
                }
                
                recordingStatus.textContent = message;
                recordingStatus.style.display = 'block';
                
                // 根据状态类型设置不同的样式
                recordingStatus.className = 'recording-status';
                switch (type) {
                    case 'error':
                        recordingStatus.classList.add('status-error');
                        break;
                    case 'success':
                        recordingStatus.classList.add('status-success');
                        // 成功状态1.5秒后自动隐藏
                        setTimeout(() => {
                            if (recordingStatus.classList.contains('status-success')) {
                                recordingStatus.style.display = 'none';
                            }
                        }, 1500);
                        break;
                    case 'info':
                        recordingStatus.classList.add('status-info');
                        break;
                    case 'warning':
                        recordingStatus.classList.add('status-warning');
                        break;
                    case 'processing':
                        recordingStatus.classList.add('status-processing');
                        break;
                    default:
                        break;
                }
            }
            
            // 添加录音按钮事件 - 增强版本
            recordButton.addEventListener('click', (event) => {
                console.log('录音按钮被点击，当前录音状态:', isRecording ? '录音中' : '未录音');
                
                // 阻止事件冒泡和默认行为，避免多次触发
                event.preventDefault();
                event.stopPropagation();
                
                // 录音按钮在处理中时禁用点击
                if (recordButton.disabled) {
                    console.log('录音按钮当前已禁用，忽略点击');
                    return;
                }
                
                if (isRecording) {
                    console.log('尝试停止录音...');
                    // 立即更新UI状态，防止用户重复点击
                    recordButton.disabled = true;
                    updateRecordingButtonState('processing');
                    
                    // 使用setTimeout确保状态更新后再停止录音
                    setTimeout(() => {
                        stopRecording();
                    }, 10);
                } else {
                    console.log('尝试开始录音...');
                    startRecording();
                }
            });
            
            // 开始录音 - 只保留完整录音识别版本
            async function startRecording() {
                console.log('开始录音（完整识别模式）');
                
                // 更新录音按钮状态
                updateRecordingButtonState('recording');
                
                try {
                    // 重置音频块数组
                    audioChunks = [];
                    
                    // 设置录音状态为true
                    isRecording = true;
                    
                    // 获取媒体流
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 16000,
                            channelCount: 1 // 确保单声道
                        }
                    });
                    
                    console.log('获取到麦克风权限');
                    
                    // 保存媒体流和轨道
                    audioStream = stream;
                    audioTracks = stream.getAudioTracks();
                    
                    // 创建MediaRecorder实例，明确指定mime类型和比特率
                    const options = {
                        mimeType: 'audio/webm;codecs=opus',
                        audioBitsPerSecond: 128000
                    };
                    
                    // 如果不支持，尝试其他格式
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        console.warn(`${options.mimeType} 不支持，尝试备选格式`);
                        options.mimeType = 'audio/webm';
                    }
                    
                    console.log(`使用录音格式: ${options.mimeType}`);
                    mediaRecorder = new MediaRecorder(stream, options);
                    
                    // 记录开始时间
                    recordingStartTime = Date.now();
                    
                    // 设置数据可用事件处理器
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            console.log(`收集到音频块: ${(event.data.size / 1024).toFixed(2)} KB`);
                            audioChunks.push(event.data);
                        }
                    };
                    
                    // 设置停止事件处理器
                    mediaRecorder.onstop = () => {
                        console.log('MediaRecorder 停止');
                        
                        // 停止所有音频轨道
                        if (audioTracks) {
                            audioTracks.forEach(track => {
                                if (track.readyState === 'live') {
                                    track.stop();
                                    console.log('音频轨道已停止');
                                }
                            });
                        }
                        
                        // 处理完整录音
                        processRecording();
                    };
                    
                    // 开始录音
                    mediaRecorder.start(1000);  // 每1秒获取一次数据块
                    console.log('录音已开始，每1秒收集一次数据');
                    
                    showStatus('info', '录音中...');
                } catch (error) {
                    console.error('启动录音时出错:', error);
                    
                    // 确保录音状态设置为false
                    isRecording = false;
                    
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        showStatus('error', '麦克风访问被拒绝，请检查浏览器权限设置');
                    } else {
                        showStatus('error', `启动录音出错: ${error.message}`);
                    }
                    
                    updateRecordingButtonState('error');
                    
                    // 延迟后恢复按钮状态
                    setTimeout(() => {
                        updateRecordingButtonState('idle');
                    }, 2000);
                }
            }
            
            // 停止录音
            function stopRecording() {
                console.log('停止录音');
                
                // 更新按钮状态
                updateRecordingButtonState('processing');
                
                // 设置录音状态为false
                isRecording = false;
                
                try {
                    // 检查mediaRecorder是否存在和状态
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        console.log('停止MediaRecorder');
                        mediaRecorder.stop();
                    } else {
                        console.warn('MediaRecorder不存在或不在录音状态');
                        
                        // 如果录音器不存在，直接处理结果
                        if (audioChunks && audioChunks.length > 0) {
                            processRecording();
                        } else {
                            updateRecordingButtonState('idle');
                            showStatus('error', '录音异常，请重试');
                        }
                    }
                    
                    // 停止所有音频轨道
                    if (audioTracks) {
                        audioTracks.forEach(track => {
                            if (track.readyState === 'live') {
                                track.stop();
                                console.log('音频轨道已停止');
                            }
                        });
                    }
                    
                    // 释放音频流
                    if (audioStream) {
                        audioStream.getTracks().forEach(track => track.stop());
                        audioStream = null;
                    }
                } catch (error) {
                    console.error('停止录音时出错:', error);
                    showStatus('error', `停止录音出错: ${error.message}`);
                    updateRecordingButtonState('error');
                    
                    // 延迟后恢复按钮状态
                    setTimeout(() => {
                        updateRecordingButtonState('idle');
                    }, 2000);
                }
            }
            
            // 处理录音数据
            function processRecording() {
                console.log('开始处理完整录音数据');
                
                // 检查是否有录音数据
                if (!audioChunks || audioChunks.length === 0) {
                    console.warn('没有录音数据可处理');
                    showStatus('error', '没有检测到语音');
                    updateRecordingButtonState('idle');
                    return;
                }
                
                try {
                    // 创建音频Blob
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    console.log(`完整音频数据大小: ${(audioBlob.size / 1024).toFixed(2)} KB`);
                    
                    // 检查音频大小
                    if (audioBlob.size < 8192) { // 8KB
                        console.warn('音频数据太小，可能没有录到声音');
                        showStatus('error', '录音太短或没有声音');
                        updateRecordingButtonState('idle');
                        return;
                    }
                    
                    // 使用当前时间戳创建唯一用户ID和文件名
                    const uniqueUserId = 'user-' + Date.now();
                    const filename = `recording_${Date.now()}.webm`;
                    
                    // 创建FormData对象
                    const formData = new FormData();
                    formData.append('file', audioBlob, filename);
                    formData.append('user', uniqueUserId);
                    formData.append('isPartial', 'false'); // 标记为完整音频
                    
                    showStatus('info', '正在识别完整语音...');
                    
                    // 标记AJAX识别请求正在处理中
                    window.isProcessingAjaxRecognition = true;
                    
                    // 发送到服务器进行识别
                    fetch('/api/speech-to-text', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.error(`语音识别请求失败: ${response.status} ${response.statusText}`);
                            throw new Error(`语音识别请求失败: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('完整语音识别结果(AJAX):', data);
                        
                        if (data.success && data.text) {
                            // 将识别结果添加到输入框
                            const inputBox = document.getElementById('messageInput');
                            if (inputBox) {
                                const currentText = inputBox.value.trim();
                                let newText = '';
                                
                                // 如果当前输入框已有文本，追加新识别的文本而不是替换
                                if (currentText) {
                                    // 检查是否需要添加空格或标点符号
                                    const needsSeparator = !currentText.endsWith(' ') && 
                                                          !currentText.endsWith('，') && 
                                                          !currentText.endsWith('。') &&
                                                          !currentText.endsWith('？') &&
                                                          !currentText.endsWith('！');
                                    
                                    // 添加适当的分隔符（中文环境下通常使用逗号）
                                    newText = currentText + (needsSeparator ? '，' : '') + data.text;
                                } else {
                                    newText = data.text;
                                }
                                
                                // 更新输入框文本
                                inputBox.value = newText;
                                
                                // 将焦点设置到输入框末尾
                                inputBox.focus();
                                inputBox.setSelectionRange(inputBox.value.length, inputBox.value.length);
                            } else {
                                console.error('未找到id为messageInput的输入框元素');
                            }
                            
                            showStatus('success', '语音识别成功，已添加到输入框');
                        } else {
                            console.warn('语音识别没有返回文本');
                            showStatus('warning', '未能识别语音内容');
                        }
                        
                        // 恢复按钮状态
                        updateRecordingButtonState('idle');
                    })
                    .catch(error => {
                        console.error('语音识别处理出错:', error);
                        showStatus('error', `语音识别失败: ${error.message}`);
                        updateRecordingButtonState('error');
                        
                        // 延迟后恢复按钮状态
                        setTimeout(() => {
                            updateRecordingButtonState('idle');
                        }, 2000);
                    })
                    .finally(() => {
                        // 清空音频数据
                        audioChunks = [];
                        // 标记AJAX识别请求处理完成
                        window.isProcessingAjaxRecognition = false;
                    });
                } catch (error) {
                    console.error('处理录音数据出错:', error);
                    showStatus('error', `处理录音出错: ${error.message}`);
                    updateRecordingButtonState('error');
                    
                    // 延迟后恢复按钮状态
                    setTimeout(() => {
                        updateRecordingButtonState('idle');
                    }, 2000);
                    
                    // 清空音频数据
                    audioChunks = [];
                    // 确保状态重置
                    window.isProcessingAjaxRecognition = false;
                }
            }
        }
        
        // 解锁音频播放（浏览器需要用户交互才能自动播放音频）
        let audioUnlocked = false;
        function unlockAudio() {
            if (audioUnlocked) return;
            
            console.log('尝试解锁音频播放...');
            
            // 创建一个静音的音频元素并尝试播放
            const silentAudio = new Audio();
            silentAudio.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV6urq6urq6urq6urq6urq6urq6v////////////////////////////////8AAAAATGF2YzU4LjU0AAAAAAAAAAAAAAAAJAYAAAAAAAAAASDs90hvAAAAAAAAAAAAAAAAAAAA';
            silentAudio.volume = 0.01;
            
            const promise = silentAudio.play();
            if (promise !== undefined) {
                promise.then(() => {
                    console.log('音频播放已解锁');
                    audioUnlocked = true;
                    
                    // 初始化MediaSource
                    if (!audioInitialized) {
                        initMediaSource();
                    }
                }).catch(e => {
                    console.warn('无法解锁音频播放:', e);
                });
            }
            
            // 移除事件监听器
            document.removeEventListener('click', unlockAudio);
            document.removeEventListener('keydown', unlockAudio);
        }
        
        // 处理音频数据
        function handleAudioData(base64Audio) {
            if (!mediaSource || mediaSource.readyState !== 'open') {
                initMediaSource();
            }
            
            try {
                // 将Base64音频数据转换为ArrayBuffer
                const binaryString = atob(base64Audio);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // 如果SourceBuffer正在更新，将音频块添加到队列
                if (sourceBuffer && sourceBuffer.updating) {
                    audioChunks.push(bytes.buffer);
                } else if (sourceBuffer) {
                    // 否则，直接添加到SourceBuffer
                    sourceBuffer.appendBuffer(bytes.buffer);
                } else {
                    console.error('SourceBuffer尚未创建');
                }
                
                // 如果音频未在播放，开始播放
                if (!isAudioPlaying && audioElement) {
                    audioElement.play().then(() => {
                        isAudioPlaying = true;
                        console.log('开始播放音频');
                    }).catch(e => {
                        console.error('音频播放失败:', e);
                    });
                }
            } catch (e) {
                console.error('处理音频数据失败:', e);
            }
        }
        
        // 结束音频流
        function endAudioStream() {
            if (mediaSource && mediaSource.readyState === 'open') {
                // 处理完队列中的所有音频块后关闭MediaSource
                if (audioChunks.length === 0 && sourceBuffer && !sourceBuffer.updating) {
                    try {
                        mediaSource.endOfStream();
                    } catch (e) {
                        console.error('关闭MediaSource失败:', e);
                    }
                } else {
                    // 如果队列不为空或SourceBuffer正在更新，等待处理完成后再关闭
                    setTimeout(endAudioStream, 100);
                }
            }
        }
        
        // 发送消息
        function sendMessage() {
            const message = messageInput.value.trim();
            
            if (!message && uploadedFiles.length === 0) {
                return;
            }
            
            // 在发送新消息前，立即停止所有正在播放的音频和响应
            console.log('发送新消息，停止所有响应和音频播放');
            
            // 立即中断当前正在处理的流式响应
            if (isStreamingResponse) {
                try {
                    // 尝试中止当前的响应读取器（如果存在）
                    if (window.currentResponseReader && window.currentResponseReader.cancel) {
                        window.currentResponseReader.cancel('用户发送了新消息');
                        console.log('已中断当前响应流读取器');
                    }
                    
                    // 移除当前的机器人消息DOM元素（如果正在显示）
                    if (window.currentBotMessageElement) {
                        console.log('移除未完成的机器人消息元素');
                        if (window.currentBotMessageElement.parentNode) {
                            window.currentBotMessageElement.parentNode.removeChild(window.currentBotMessageElement);
                        }
                        window.currentBotMessageElement = null;
                    }
                } catch (error) {
                    console.error('中断当前响应时出错:', error);
                }
            }
            
            // 停止所有音频播放
            stopAllAudio();
            
            // 如果有正在进行的流式响应，先停止它
            if (isStreamingResponse && currentTaskId) {
                console.log(`检测到新的用户输入，停止当前响应，任务ID: ${currentTaskId}`);
                
                // 立即重置状态，无需等待停止请求完成
                console.log('立即重置状态，准备发送新消息');
                isStreamingResponse = false;
                currentTaskId = null;
            }
            
            // 添加用户消息到聊天窗口
            addMessage(message, 'user');
            
            // 清空输入框
            messageInput.value = '';
            
            // 显示输入指示器
            typingIndicator.style.display = 'block';
            
            // 通过WebSocket发送消息到服务器
            if (ws && ws.readyState === WebSocket.OPEN) {
                // 生成请求ID
                const requestId = 'req_' + Date.now();
                
                // 准备要发送的数据
                const requestData = {
                    type: 'chat_request',
                    message: message,
                    requestId: requestId,
                    userId: userId,
                    files: uploadedFiles.map(file => ({
                type: 'image',
                url: file.url
                    }))
                };
                
                // 发送数据
                ws.send(JSON.stringify(requestData));
                console.log('已发送聊天请求:', requestData);
                        } else {
                console.error('WebSocket未连接，无法发送消息');
                // 显示错误消息
                addMessage('抱歉，服务器连接已断开，请刷新页面重试。', 'bot');
                    // 隐藏输入指示器
                    typingIndicator.style.display = 'none';
            }
            
            // 清空文件预览和上传的文件
            filePreview.innerHTML = '';
            uploadedFiles = [];
        }
        
        // 请求语音合成
        function requestSpeech(text) {
            if (!text || !autoSpeakEnabled) return;
            
            console.log('请求语音合成:', text.substring(0, 50) + (text.length > 50 ? '...' : ''));
            
            // 生成请求ID
            const requestId = 'tts_' + Date.now();
            
            // 发送TTS请求
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'tts_request',
                    text: text,
                    voice: currentVoice || 'longxiaochun', // 使用当前选中的声音或默认值
                    requestId: requestId
                }));
                                                    } else {
                console.error('WebSocket未连接，无法发送TTS请求');
            }
        }
        
        // 播放音频
        function playAudio(audioUrl) {
            if (!audioUrl) return;
            
            console.log('播放音频:', audioUrl);
            
            // 停止当前正在播放的音频
            stopAllAudio();
            
            // 创建音频元素
            const audio = new Audio(audioUrl);
            audio.dataset.audioUrl = audioUrl;
            
            // 设置音频事件
            audio.onplay = () => {
                console.log('音频开始播放');
            };
            
            audio.onended = () => {
                console.log('音频播放结束');
                // 移除音频元素
                if (audio.parentNode) {
                    audio.parentNode.removeChild(audio);
                }
            };
            
            audio.onerror = (error) => {
                console.error('音频播放错误:', error);
                // 移除音频元素
                if (audio.parentNode) {
                    audio.parentNode.removeChild(audio);
                }
            };
            
            // 将音频元素添加到DOM中
            document.body.appendChild(audio);
            
            // 播放音频
            audio.play().catch(error => {
                console.error('播放音频失败:', error);
            });
        }
        
        // 增强stopAllAudio函数，确保彻底停止和清理所有音频
        function stopAllAudio() {
            console.log('停止所有正在播放的音频');
            
            // 查找并停止所有音频元素
            const audioElements = document.querySelectorAll('audio');
            if (audioElements.length > 0) {
                console.log(`找到 ${audioElements.length} 个音频元素，停止播放并移除`);
                audioElements.forEach(audio => {
                    try {
                        // 记录被停止的音频URL
                        if (audio.dataset.audioUrl) {
                            console.log(`停止播放音频: ${audio.dataset.audioUrl}`);
                            processedUrls.add(audio.dataset.audioUrl);
                        }
                        
                        // 停止播放
                        audio.pause();
                        audio.currentTime = 0;
                        
                        // 移除元素
                        if (audio.parentNode) {
                            audio.parentNode.removeChild(audio);
                        }
                    } catch (err) {
                        console.error('停止音频元素时出错:', err);
                    }
                });
            }
            
            // 清空待处理队列
            if (pendingAudioUrls.length > 0) {
                console.log(`清空音频队列 (${pendingAudioUrls.length} 个项目)`);
                pendingAudioUrls = [];
            }
            
            // 取消所有挂起的合成请求（如果有）
            if (window.currentSynthesisRequests && window.currentSynthesisRequests.length > 0) {
                console.log(`取消 ${window.currentSynthesisRequests.length} 个挂起的合成请求`);
                window.currentSynthesisRequests.forEach(controller => {
                    if (controller && controller.abort) {
                        try {
                            controller.abort();
                        } catch (err) {
                            console.error('取消合成请求时出错:', err);
                        }
                    }
                });
                window.currentSynthesisRequests = [];
            }
            
            // 重置状态
            isProcessingAudio = false;
            currentPlayingAudio = null;
            console.log('音频播放已完全停止，所有相关状态已重置');
        }
        
        // 添加消息到聊天窗口
        function addMessage(content, sender) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${sender}-message`;
            
            // 添加内容
            const textEl = document.createElement('div');
            textEl.className = 'message-text';
            textEl.textContent = content;
            messageEl.appendChild(textEl);
            
            chatMessages.appendChild(messageEl);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // 处理文件上传
        function handleFileUpload(event) {
            const files = event.target.files;
            
            if (!files || files.length === 0) {
                return;
            }
            
            fileStatus.textContent = '正在上传...';
            
            // 清空文件预览
            filePreview.innerHTML = '';
            uploadedFiles = [];
            
            // 上传每个文件
            Array.from(files).forEach(file => {
                // 创建FormData
                const formData = new FormData();
                formData.append('file', file);
                
                // 上传文件到服务器
                fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.url) {
                        // 添加到上传的文件列表
                        uploadedFiles.push({
                            name: file.name,
                            url: data.url
                        });
                        
                        // 创建预览
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        
                        const img = document.createElement('img');
                        img.src = data.url;
                        fileItem.appendChild(img);
                        
                        const removeBtn = document.createElement('div');
                        removeBtn.className = 'remove-file';
                        removeBtn.textContent = 'x';
                        removeBtn.addEventListener('click', () => {
                            // 从预览和上传列表中移除
                            fileItem.remove();
                            uploadedFiles = uploadedFiles.filter(f => f.url !== data.url);
                        });
                        fileItem.appendChild(removeBtn);
                        
                        filePreview.appendChild(fileItem);
                        
                        // 更新状态
                        fileStatus.textContent = `已上传 ${uploadedFiles.length} 个文件`;
                    } else {
                        console.error('文件上传失败:', data.error);
                        fileStatus.textContent = '文件上传失败';
                    }
                })
                .catch(error => {
                    console.error('文件上传请求失败:', error);
                    fileStatus.textContent = '文件上传失败';
                });
            });
        }

        // 初始化MediaSource
        function initMediaSource() {
            console.log('初始化MediaSource');
            
            // 如果已经初始化，则返回
            if (audioInitialized) {
                console.log('MediaSource已经初始化');
                return;
            }
            
            // 创建MediaSource实例
            mediaSource = new MediaSource();
            
            // 创建音频元素
            audioElement = new Audio();
            audioElement.controls = false;
            audioElement.style.display = 'none';
            audioElement.volume = 1.0;
            document.body.appendChild(audioElement);
            
            // 设置音频源
            audioElement.src = URL.createObjectURL(mediaSource);
            
            // 监听MediaSource打开事件
            mediaSource.addEventListener('sourceopen', () => {
                console.log('MediaSource已打开');
                
                try {
                    // 尝试不同的MIME类型
                    try {
                        sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg');
                    } catch (e) {
                        console.warn('无法创建audio/mpeg SourceBuffer，尝试其他格式');
                        try {
                            sourceBuffer = mediaSource.addSourceBuffer('audio/mp3');
                        } catch (e2) {
                            console.warn('无法创建audio/mp3 SourceBuffer，尝试其他格式');
                            sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg; codecs="mp3"');
                        }
                    }
                    
                    // 监听SourceBuffer更新结束事件
                    sourceBuffer.addEventListener('updateend', () => {
                        console.log('SourceBuffer更新结束');
                        // 如果队列中有待处理的音频块，继续添加
                        if (audioChunks.length > 0 && !sourceBuffer.updating) {
                            const chunk = audioChunks.shift();
                            console.log(`从队列中取出音频块，剩余: ${audioChunks.length}`);
                            sourceBuffer.appendBuffer(chunk);
                        }
                    });
                    
                    audioInitialized = true;
                    console.log('音频播放器初始化完成');
                } catch (e) {
                    console.error('创建SourceBuffer失败:', e);
                    // 尝试使用普通Audio元素播放
                    fallbackToSimpleAudio();
                }
            });
            
            // 添加错误处理
            mediaSource.addEventListener('error', (e) => {
                console.error('MediaSource错误:', e);
                fallbackToSimpleAudio();
            });
            
            // 监听音频播放结束事件
            audioElement.addEventListener('ended', () => {
                console.log('音频播放结束');
                isAudioPlaying = false;
            });
            
            // 添加错误处理
            audioElement.addEventListener('error', (e) => {
                console.error('音频元素错误:', e);
                fallbackToSimpleAudio();
            });
        }

        // 添加音频块到MediaSource
        function appendAudioChunk(arrayBuffer) {
            if (!sourceBuffer || !mediaSource || mediaSource.readyState !== 'open') {
                // 如果MediaSource尚未准备好，将块添加到队列
                audioChunks.push(arrayBuffer);
                console.log('MediaSource尚未准备好，将音频块添加到队列');
                return;
            }
            
            try {
                if (sourceBuffer.updating) {
                    // 如果SourceBuffer正在更新，将块添加到队列
                    audioChunks.push(arrayBuffer);
                    console.log('SourceBuffer正在更新，将音频块添加到队列');
                } else {
                    // 直接添加到SourceBuffer
                    console.log(`直接添加音频块到SourceBuffer，大小: ${arrayBuffer.byteLength}`);
                    sourceBuffer.appendBuffer(arrayBuffer);
                    console.log(`音频块已添加到SourceBuffer，队列长度: ${audioChunks.length}`);
                }
            } catch (e) {
                console.error('添加音频块失败:', e);
                // 如果添加失败，尝试降级
                fallbackToSimpleAudio();
            }
        }

        // 添加音频预加载功能
        function preloadAudio(url) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.oncanplaythrough = () => {
                    resolve(audio);
                };
                audio.onerror = (error) => {
                    reject(error);
                };
                audio.src = url;
                audio.load();
            });
        }

        // 辅助函数：检查URL是否已处理过
        function isUrlProcessed(url) {
            // 完整URL检查
            if (processedUrls.has(url)) return true;
            
            // 文件名检查（有时URL格式可能略有不同）
            const filename = url.split('/').pop();
            for (const processedUrl of processedUrls) {
                const processedFilename = processedUrl.split('/').pop();
                if (processedFilename === filename) return true;
            }
            return false;
        }
        
        // 辅助函数：检查URL是否已在队列中
        function isUrlInQueue(url) {
            // 完整URL检查
            const exactMatch = pendingAudioUrls.some(item => item.url === url);
            if (exactMatch) return true;
            
            // 文件名检查（有时URL格式可能略有不同）
            const filename = url.split('/').pop();
            return pendingAudioUrls.some(item => {
                const itemFilename = item.url.split('/').pop();
                return itemFilename === filename;
            });
        }
        
        // 当收到音频事件时，处理音频URL
        function handleAudioEvent(parsedData) {
            console.log('收到音频URL:', parsedData.url);
            console.log('音频文本:', parsedData.text);
            console.log('是否最终片段:', parsedData.isFinal);
            console.log('音频轮次ID:', parsedData.roundId || '未指定');
            
            // 检查URL是否有效
            if (!parsedData.url || !parsedData.url.startsWith('/audio/')) {
                console.log('跳过无效音频URL');
                return;
            }
            
            // 提取文件名
            const filename = parsedData.url.split('/').pop();
            
            // 检查文件是否已被删除
            if (deletedFiles.has(filename)) {
                console.log(`跳过已删除的音频文件: ${filename}`);
                return;
            }
            
            // 检查音频是否属于当前对话轮次 - 使用后端返回的轮次ID
            const audioRoundId = parsedData.roundId;
            if (audioRoundId && audioRoundId !== currentConversationRoundId) {
                console.log(`跳过不属于当前轮次的音频: ${parsedData.url} [轮次ID: ${audioRoundId} 不等于 ${currentConversationRoundId}]`);
                return;
            }
            
            // 检查URL是否已在队列中或已处理
            if (isUrlProcessed(parsedData.url)) {
                console.log(`音频URL已被处理，跳过: ${parsedData.url}`);
                return;
            }
            
            if (isUrlInQueue(parsedData.url)) {
                console.log(`音频URL已在队列中，跳过: ${parsedData.url}`);
                return;
            }
            
            // 提取文件名中的数字（用于排序）
            const match = parsedData.url.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
            const timestamp = match ? parseInt(match[1]) : 0;
            
            // 递增计数器
            totalAudioReceived++;
            console.log(`处理新音频 #${totalAudioReceived}: ${parsedData.url}`);
            
            // 添加到待处理队列，包含当前对话轮次ID
            pendingAudioUrls.push({
                url: parsedData.url,
                text: parsedData.text || "",
                isFinal: parsedData.isFinal || false,
                timestamp: timestamp,
                id: totalAudioReceived,
                receivedAt: Date.now(),
                roundId: audioRoundId || currentConversationRoundId // 使用后端返回的轮次ID，如没有则使用当前轮次ID
            });
            
            console.log(`添加到队列成功，当前队列长度: ${pendingAudioUrls.length}, 轮次ID: ${audioRoundId || currentConversationRoundId}`);
            
            // 按时间戳排序队列
            pendingAudioUrls.sort((a, b) => a.timestamp - b.timestamp);
            
            // 如果当前没有正在处理音频，开始处理
            if (!isProcessingAudio) {
                console.log('开始处理音频队列');
                processNextAudio();
            } else {
                console.log('当前有音频正在处理，新音频已加入队列');
            }
        }

        // 修改音频处理函数
        async function processNextAudio() {
            // 过滤不属于当前轮次的音频
            if (pendingAudioUrls.length > 0) {
                const outdatedAudios = pendingAudioUrls.filter(audio => audio.roundId !== currentConversationRoundId);
                if (outdatedAudios.length > 0) {
                    console.log(`发现 ${outdatedAudios.length} 个不属于当前轮次(${currentConversationRoundId})的音频，将被跳过`);
                    // 从队列中移除这些音频
                    pendingAudioUrls = pendingAudioUrls.filter(audio => audio.roundId === currentConversationRoundId);
                }
            }
            
            if (pendingAudioUrls.length === 0) {
                isProcessingAudio = false;
                currentPlayingAudio = null;
                console.log('音频队列为空，处理结束');
                return;
            }
            
            isProcessingAudio = true;
            const audioItem = pendingAudioUrls.shift();
            currentPlayingAudio = audioItem;
            
            console.log(`开始处理音频: ${audioItem.url} (队列剩余: ${pendingAudioUrls.length}个) [轮次ID: ${audioItem.roundId}]`);
            
            // 再次检查该音频是否已被处理或已被删除
            const filename = audioItem.url.split('/').pop();
            if (isUrlProcessed(audioItem.url)) {
                console.log(`音频已被处理，跳过: ${audioItem.url}`);
                currentPlayingAudio = null;
                processNextAudio();
                return;
            }
            
            if (deletedFiles.has(filename)) {
                console.log(`音频文件已被删除，跳过: ${filename}`);
                currentPlayingAudio = null;
                processNextAudio();
                return;
            }
            
            try {
                // 预加载音频
                console.log(`预加载音频: ${audioItem.url}`);
                const audio = await preloadAudio(audioItem.url);
                console.log(`音频预加载成功: ${audioItem.url}`);
                
                // 添加轮次ID属性用于后续检查
                audio.dataset.roundId = audioItem.roundId;
                audio.dataset.audioUrl = audioItem.url;
                
                // 播放音频
                audio.onended = () => {
                    console.log(`音频播放完成: ${audioItem.url}`);
                    // 标记为已处理
                    processedUrls.add(audioItem.url);
                    totalAudioPlayed++;
                    currentPlayingAudio = null;
                    
                    // 播放完成后删除音频文件
                    if (filename && filename.startsWith('tts_') && filename.endsWith('.mp3') && !deletedFiles.has(filename)) {
                        deleteAudioFile(filename);
                    }
                    
                    // 删除音频元素，避免内存泄漏
                    document.body.removeChild(audio);
                    processNextAudio();
                };
                
                // 添加到DOM以便控制
                audio.style.display = 'none'; // 隐藏元素但保持功能
                document.body.appendChild(audio);
                
                console.log(`开始播放音频: ${audioItem.url}`);
                audio.play().catch(error => {
                    console.error(`音频播放失败: ${error.message}`);
                    // 尝试重新加载并播放
                    setTimeout(() => {
                        console.log(`尝试重新加载音频: ${audioItem.url}`);
                        audio.load();
                        audio.play().catch(e => {
                            console.error(`重试播放失败: ${e.message}`);
                            // 移除DOM元素
                            document.body.removeChild(audio);
                            processNextAudio(); // 继续处理下一个
                        });
                    }, 1000);
                });
            } catch (error) {
                console.error(`处理音频出错: ${error.message}`);
                // 继续处理下一个
                currentPlayingAudio = null;
                processNextAudio();
            }
        }

        // 开始播放
        function startPlayback() {
            // 如果音频未在播放，开始播放
            if (!isAudioPlaying && audioElement && audioInitialized) {
                audioElement.play()
                    .then(() => {
                        isAudioPlaying = true;
                        console.log('开始播放音频流');
                    })
                    .catch(err => {
                        // 如果播放失败，尝试降级
                        fallbackToSimpleAudio();
                    });
            } else {
                if (isAudioPlaying) {
                    console.log('已在播放中');
                } else {
                    console.log('播放器未就绪');
                }
            }
        }

        // 降级到简单音频播放
        function fallbackToSimpleAudio() {
            console.log('降级到简单音频播放模式');
            
            // 重置状态
            audioInitialized = false;
            isAudioPlaying = false;
            
            // 清理现有元素
            if (audioElement) {
                audioElement.pause();
                if (audioElement.parentNode) {
                    audioElement.parentNode.removeChild(audioElement);
                }
            }
            
            // 确保队列按时间戳排序
            pendingAudioUrls.sort((a, b) => a.timestamp - b.timestamp);
            
            // 显示当前队列状态
            const queueInfo = pendingAudioUrls.map(item => {
                const shortUrl = item.url.split('/').pop();
                return `${shortUrl}`;
            }).join(', ');
            
            // 创建音频队列播放器
            const audioQueue = [...pendingAudioUrls];
            pendingAudioUrls = [];
            
            // 播放第一个音频
            if (audioQueue.length > 0) {
                playNextInQueue(audioQueue);
            }
        }

        // 按顺序播放队列中的音频
        function playNextInQueue(queue) {
            if (queue.length === 0) {
                console.log('简单模式队列播放完成');
                return;
            }
            
            const audioData = queue.shift();
            console.log(`简单模式播放: ${audioData.url.split('/').pop()}`);
            
            const audio = new Audio(audioData.url);
            audio.volume = 1.0;
            audio.controls = false;
            audio.style.display = 'none';
            document.body.appendChild(audio);
            
            // 播放结束后播放下一个
            audio.onended = () => {
                // 删除音频文件
                const filename = audioData.url.split('/').pop();
                if (filename && filename.startsWith('tts_') && filename.endsWith('.mp3') && !deletedFiles.has(filename)) {
                    deleteAudioFile(filename);
                }
                
                document.body.removeChild(audio);
                playNextInQueue(queue);
            };
            
            // 播放错误处理
            audio.onerror = (e) => {
                console.error('播放错误:', e);
                document.body.removeChild(audio);
                playNextInQueue(queue);
            };
            
            // 开始播放
            audio.play().catch(err => {
                console.error('播放失败:', err);
                document.body.removeChild(audio);
                playNextInQueue(queue);
            });
        }

        // 改进检查音频文件函数
        function checkMissingAudio() {
            console.log('开始检查音频文件...');
            
            // 获取最近30秒内的URL，避免检查太旧的音频
            const recentTime = Date.now() - 30000; // 30秒前
            
            // 获取已处理的最近URLs
            const recentProcessedUrls = Array.from(processedUrls)
                .filter(url => {
                    // 尝试从URL中提取时间戳
                    const match = url.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
                    if (match) {
                        const urlTimestamp = parseInt(match[1]);
                        // 时间戳是否在最近30秒内
                        return Date.now() - urlTimestamp < 30000;
                    }
                    return true; // 如果无法提取时间戳，默认保留
                });
            
            // 检查后台生成的音频文件
            fetch('/api/audio/list')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const backendFiles = data.files || [];
                    if (backendFiles.length === 0) {
                        console.log('后台没有音频文件');
                        return;
                    }
                    
                    console.log(`后台音频文件数量: ${backendFiles.length}`);
                    
                    // 获取最近生成的音频文件（按文件名中的时间戳排序）
                    const recentFiles = backendFiles
                        .filter(file => {
                            // 修改正则表达式以匹配带有轮次ID的文件名
                            const match = file.match(/tts_(\d+)(?:_round_([^.]+))?\.mp3$/);
                            if (match) {
                                const timestamp = parseInt(match[1]);
                                const roundId = match[2];
                                
                                // 只处理30秒内的文件，并且要么没有轮次ID，要么轮次ID匹配当前轮次
                                return Date.now() - timestamp < 30000 && 
                                       (!roundId || roundId === currentConversationRoundId);
                            }
                            return false;
                        })
                        .sort((a, b) => {
                            const matchA = a.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
                            const matchB = b.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
                            const timeA = matchA ? parseInt(matchA[1]) : 0;
                            const timeB = matchB ? parseInt(matchB[1]) : 0;
                            return timeA - timeB;
                        });
                    
                    if (recentFiles.length === 0) {
                        console.log('没有最近生成的音频文件');
                        return;
                    }
                    
                    console.log(`最近音频文件: ${recentFiles.join(', ')}`);
                    
                    // 检查是否有未处理的文件
                    const pendingUrls = pendingAudioUrls.map(item => item.url.split('/').pop());
                    
                    const missingFiles = recentFiles.filter(file => {
                        // 检查文件是否已被删除
                        if (deletedFiles.has(file)) return false;
                        
                        // 检查文件名对应的URL是否已在队列中
                        const fileUrl = `/audio/${file}`;
                        if (isUrlInQueue(fileUrl)) return false;
                        
                        // 检查文件名对应的URL是否已被处理
                        if (isUrlProcessed(fileUrl)) return false;
                        
                        // 检查文件是否属于当前轮次
                        const match = file.match(/tts_\d+_round_([^.]+)\.mp3$/);
                        if (match) {
                            const roundId = match[1];
                            if (roundId !== currentConversationRoundId) {
                                console.log(`跳过不属于当前轮次的音频文件: ${file} [轮次ID: ${roundId}]`);
                                return false;
                            }
                        }
                        
                        // 如果以上条件都不满足，则认为是遗漏的文件
                        return true;
                    });
                    
                    if (missingFiles.length > 0) {
                        console.log(`发现 ${missingFiles.length} 个未处理的音频文件: ${missingFiles.join(', ')}`);
                        
                        // 限制添加的数量，避免添加太多旧文件
                        const filesToAdd = missingFiles.slice(0, 5); // 最多添加5个
                        
                        console.log(`添加 ${filesToAdd.length} 个文件到队列`);
                        
                        // 添加到待处理队列，标记为当前轮次的音频
                        filesToAdd.forEach((file, index) => {
                            const url = `/audio/${file}`;
                            
                            // 检查是否已经在队列中
                            const alreadyInQueue = pendingAudioUrls.some(item => item.url === url);
                            if (alreadyInQueue) {
                                console.log(`文件已在队列中: ${file}`);
                                return;
                            }
                            
                            // 提取文件中的轮次ID
                            let fileRoundId = currentConversationRoundId;
                            const roundMatch = file.match(/tts_\d+_round_([^.]+)\.mp3$/);
                            if (roundMatch) {
                                fileRoundId = roundMatch[1];
                            }
                            
                            const timestampMatch = file.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
                            const timestamp = timestampMatch ? parseInt(timestampMatch[1]) : 0;
                            
                            pendingAudioUrls.push({
                                url: url,
                                text: "",
                                isFinal: index === filesToAdd.length - 1,
                                timestamp: timestamp,
                                id: totalAudioReceived + index + 1,
                                receivedAt: Date.now(),
                                roundId: fileRoundId // 使用文件名中的轮次ID
                            });
                        });
                        
                        totalAudioReceived += filesToAdd.length;
                        
                        // 按时间戳排序队列
                        pendingAudioUrls.sort((a, b) => a.timestamp - b.timestamp);
                        
                        // 如果当前没有正在处理音频，开始处理
                        if (!isProcessingAudio) {
                            processNextAudio();
                        }
                    } else {
                        console.log('没有发现未处理的音频文件');
                    }
                })
                .catch(error => {
                    console.error('检查音频文件失败:', error);
                });
        }

        // 删除音频文件
        async function deleteAudioFile(filename) {
            try {
                // 检查文件是否已经被删除
                if (deletedFiles.has(filename)) {
                    console.log(`文件已被删除，跳过: ${filename}`);
                    return;
                }
                
                console.log(`正在删除音频文件: ${filename}`);
                const response = await fetch(`/api/audio/delete/${filename}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                if (result.success) {
                    console.log(`音频文件删除成功: ${filename}`);
                    deletedFiles.add(filename);
                } else {
                    console.log(`音频文件删除失败: ${result.message}`);
                }
            } catch (error) {
                console.error('删除音频文件失败:', error);
            }
        }
        
        // 批量清理旧音频文件
        async function cleanupOldAudioFiles(sessionStartTime) {
            try {
                console.log(`正在清理旧音频文件...`);
                const response = await fetch('/api/audio/cleanup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sessionStartTime })
                });
                const result = await response.json();
                if (result.success) {
                    console.log(`清理完成: 已删除${result.deletedCount}个旧文件`);
                    
                    // 将删除的文件记录到deletedFiles集合中
                    if (result.deletedFiles && Array.isArray(result.deletedFiles)) {
                        result.deletedFiles.forEach(file => deletedFiles.add(file));
                    }
                } else {
                    console.log(`清理失败: ${result.message}`);
                }
            } catch (error) {
                console.error('清理旧音频文件失败:', error);
            }
        }

        // 重置对话
        function resetConversation() {
            console.log('========== 重置对话开始 ==========');
            console.log(`用户标识: ${userId} (保持不变)`);
            console.log(`旧会话ID: ${conversationId || '无'}`);
            
            // 生成新的对话轮次ID
            currentConversationRoundId = 'round_' + Date.now();
            console.log(`生成新的对话轮次ID: ${currentConversationRoundId}`);
            
            // 停止所有音频播放
            stopAllAudio();
            
            // 清空消息容器
            chatMessages.innerHTML = '';
            
            // 清除会话ID和相关localStorage记录，但保留用户标识
            conversationId = '';
            localStorage.removeItem('lastSessionId');
            localStorage.removeItem('lastSessionDate');
            console.log('已清除会话ID和localStorage记录');
            
            // 重新初始化会话ID
            checkAndUpdateConversationId();
            console.log(`新会话ID: ${conversationId}`);
            
            // 添加欢迎消息
            addMessage('您好！我是智能助手，有什么可以帮您的吗？', 'bot');
            
            // 重置全局变量
            audioQueue = [];
            pendingAudioUrls = [];
            processedUrls = new Set();
            // 保留删除文件记录
            currentPlayingAudio = null;
            totalAudioPlayed = 0;
            totalAudioReceived = 0;
            isProcessingAudio = false;
            
            // 更新当前会话时间戳
            sessionStartTime = Date.now();
            
            // 清理旧音频文件
            cleanupOldAudioFiles(sessionStartTime);
            
            console.log('对话已重置，所有音频相关变量已清零');
            console.log('========== 重置对话完成 ==========');
        }

        // 获取当天日期字符串
        function getCurrentDateString() {
            const today = new Date();
            return today.getFullYear() +
                   String(today.getMonth() + 1).padStart(2, '0') +
                   String(today.getDate()).padStart(2, '0');
        }

        // 生成基于日期的会话ID
        function generateConversationId() {
            return `chat_session_${getCurrentDateString()}`;
        }

        // 生成唯一用户ID
        function generateUserId() {
            return 'user-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
        }

        // 检查会话ID是否需要更新（不同日期）
        function checkAndUpdateConversationId() {
            console.log('检查会话ID是否需要更新...');
            console.log(`当前会话ID: ${conversationId || '无'}`);
            
            // 生成基于日期的新ID
            const newId = generateConversationId();
            
            // 检查会话ID类型
            const isCustomId = conversationId && conversationId.startsWith('chat_session_');
            const isUUID = conversationId && !isCustomId; // 非自定义ID视为UUID
            
            // 如果会话ID为空，或者是自定义格式但不是今天的日期，则更新
            if (!conversationId) {
                console.log(`会话ID为空，初始化为: ${newId}`);
                conversationId = newId;
                return true; // 表示ID已更新
            } else if (isCustomId && conversationId !== newId) {
                console.log(`会话ID是过期的自定义ID，更新为今天的ID: ${conversationId} -> ${newId}`);
                conversationId = newId;
                return true; // 表示ID已更新 
            } else if (isUUID) {
                console.log(`会话ID是UUID格式，保持不变: ${conversationId}`);
                // 如果是UUID格式，保留不变
                return false; // 表示ID未更新
            } else {
                console.log(`会话ID是最新的自定义ID，无需更新: ${conversationId}`);
                return false; // 表示ID未更新
            }
        }

        // 更新语音识别文本到输入框
        function updateRecognitionText(data) {
            console.log('收到WebSocket语音识别结果:', data);
            
            // 检查是否来自WebSocket的实时更新
            const isWebSocketUpdate = true;
            
            // 如果正在进行AJAX识别请求处理，跳过WebSocket更新
            if (window.isProcessingAjaxRecognition === true) {
                console.log('AJAX识别请求正在处理中，跳过WebSocket更新');
                return;
            }
            
            // 将识别文本填充到消息输入框
            messageInput.value = data.text;
            
            // 如果是最终结果，更新状态
            if (data.isFinal) {
                // 显示录音状态为"识别完成"
                recordingStatus.textContent = '句子识别完成';
                setTimeout(() => {
                    if (recordingStatus.textContent === '句子识别完成') {
                        recordingStatus.style.display = 'none';
                    }
                }, 1500);
            }
        }
        
        // 处理语音识别完成
        function handleRecognitionComplete(data) {
            console.log('语音识别完成:', data);
            
            // 将最终识别文本填充到消息输入框
            messageInput.value = data.text;
            
            // 更新状态
            recordingStatus.textContent = '识别完成';
            setTimeout(() => {
                recordingStatus.style.display = 'none';
                updateRecordingButtonState('idle');
                recordButton.disabled = false;
            }, 1500);
            
            // 聚焦输入框
            messageInput.focus();
        }
        
        // 处理计时器完成事件
        function handleTimerCompleted(timer) {
            console.log('计时器完成:', timer);
            
            // 提取消息内容和通知文本
            let notificationMessage = '';
            let messageToSpeak = '';
            
            // 获取计时器的实际消息内容（用于播放）
            if (timer && timer.message) {
                messageToSpeak = timer.message;
            }
            
            // 构建通知消息（只用于显示）
            if (timer && timer.name) {
                notificationMessage = `计时器 "${timer.name}" 已完成`;
            } else if (timer && timer.title) {
                notificationMessage = `计时器 "${timer.title}" 已完成`;
            } else {
                notificationMessage = '计时器已完成';
            }
            
            // 添加消息到聊天框
            addMessage(notificationMessage, 'bot');
            
            // 仅当有指定的消息内容时才播放语音
            if (messageToSpeak) {
                console.log(`计时器消息内容: "${messageToSpeak}"`);
                // 先播放广播提示音，然后再播放计时器消息
                playWithAlertSound(messageToSpeak);
                
                // 设置重复提醒
                if (timerSettings.repeatCount > 1) {
                    const timerId = timer.id || `timer_${Date.now()}`;
                    setupTimerReminders(timerId, messageToSpeak);
                }
            } else {
                // 如果没有指定消息内容，则播放通知消息
                console.log('计时器没有指定消息内容，使用通知消息');
                playWithAlertSound(notificationMessage);
                
                // 设置重复提醒
                if (timerSettings.repeatCount > 1) {
                    const timerId = timer.id || `timer_${Date.now()}`;
                    setupTimerReminders(timerId, notificationMessage);
                }
            }
        }

        // 先播放提示音，然后再播放计时器消息的函数
        function playWithAlertSound(message) {
            const alertSoundUrl = '/audio/Broadcastalert.mp3';
            
            console.log('检查广播提示音文件:', alertSoundUrl);
            console.log(`将要播放的计时器消息:`, message);
            
            // 检查是否有AudioAutoplay模块
            if (window.AudioAutoplay) {
                // 先播放提示音，然后播放消息
                window.AudioAutoplay.play(alertSoundUrl, () => {
                    console.log('广播提示音播放完成，开始播放计时器消息');
                    // 使用语音合成播放消息
                    speakMessage(message);
                });
            } else {
                // 回退方案：检查广播提示音文件是否存在
                fetch(alertSoundUrl, { method: 'HEAD' })
                    .then(response => {
                        if (response.ok) {
                            console.log('广播提示音可用，先播放提示音');
                            playAlertThenMessage(alertSoundUrl, message);
                        } else {
                            console.log('广播提示音不可用，直接播放计时器消息');
                            // 直接播放计时器消息
                            speakMessage(message);
                        }
                    })
                    .catch(error => {
                        console.error('检查广播提示音时出错:', error);
                        // 出错时直接播放计时器消息
                        speakMessage(message);
                    });
            }
        }

        // 使用普通Audio元素播放提示音，然后播放消息
        function playAlertThenMessage(alertSoundUrl, message, repeatCount = 2) {
            console.log('使用普通Audio元素播放提示音');
            
            // 创建音频元素并播放提示音
            const alertAudio = new Audio();
            // 添加playsinline属性以提高在移动设备上自动播放的成功率
            alertAudio.setAttribute('playsinline', '');
            alertAudio.setAttribute('webkit-playsinline', '');
            alertAudio.preload = 'auto';
            
            // 设置音频源
            alertAudio.src = alertSoundUrl;
            
            // 提示音播放完成后，播放计时器消息
            alertAudio.onended = function() {
                console.log('广播提示音播放完成，开始播放计时器消息');
                // 移除提示音元素
                if (alertAudio.parentNode) {
                    alertAudio.parentNode.removeChild(alertAudio);
                }
                // 播放计时器消息，重复播放指定次数
                speakMessage(message, repeatCount);
            };
            
            // 提示音加载错误时，直接播放计时器消息
            alertAudio.onerror = function(e) {
                console.error('广播提示音加载失败:', e);
                // 移除提示音元素
                if (alertAudio.parentNode) {
                    alertAudio.parentNode.removeChild(alertAudio);
                }
                // 直接播放计时器消息，重复播放指定次数
                speakMessage(message, repeatCount);
            };
            
            // 将音频元素添加到DOM，以便控制播放和处理事件
            alertAudio.style.display = 'none'; // 隐藏元素
            document.body.appendChild(alertAudio);
            
            // 触发播放前先设置较低音量，然后再恢复
            alertAudio.volume = 0.1;
            
            // 开始播放提示音
            alertAudio.play().then(() => {
                console.log('广播提示音开始播放');
                // 播放成功后平滑恢复音量
                setTimeout(() => {
                    // 使用定时器平滑调整音量
                    let vol = 0.1;
                    const interval = setInterval(() => {
                        if (vol < 1.0) {
                            vol += 0.1;
                            alertAudio.volume = vol > 1.0 ? 1.0 : vol;
                        } else {
                            clearInterval(interval);
                        }
                    }, 100);
                }, 100);
            }).catch(err => {
                console.error('广播提示音播放失败:', err);
                // 直接播放计时器消息，重复播放指定次数
                speakMessage(message, repeatCount);
            });
        }

        // 语音播报功能
        function speakMessage(message, repeatCount = 1) {
            // 如果已经有语音合成功能，使用现有功能
            if (typeof synthText === 'function') {
                synthText(message, repeatCount);
                return;
            }
            
            // 使用阿里云CosyVoice模型进行语音合成
            fetch('/api/tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ text: message })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.audioUrl) {
                    console.log(`开始播放语音消息${repeatCount > 1 ? `(将重复${repeatCount}遍)` : ''}: "${message}"`);
                    
                    // 使用AudioAutoplay模块播放（带重复）
                    if (window.AudioAutoplay) {
                        playAudioWithRepeat(data.audioUrl, repeatCount);
                        return;
                    }
                    
                    // 创建音频元素并播放
                    playAudioElementWithRepeat(data.audioUrl, message, repeatCount);
                } else {
                    console.error('语音合成失败:', data.error);
                    // 降级到浏览器原生语音合成
                    useBrowserTTS(message, repeatCount);
                }
            })
            .catch(error => {
                console.error('语音合成请求失败:', error);
                // 降级到浏览器原生语音合成
                useBrowserTTS(message, repeatCount);
            });
        }

        // 使用AudioAutoplay模块播放音频并重复
        function playAudioWithRepeat(audioUrl, repeatCount) {
            let currentRepeat = 0;
            
            const playNext = () => {
                currentRepeat++;
                console.log(`播放第 ${currentRepeat}/${repeatCount} 遍`);
                
                if (currentRepeat <= repeatCount) {
                    window.AudioAutoplay.play(audioUrl, () => {
                        console.log(`第 ${currentRepeat} 遍播放完成`);
                        // 如果还需要继续重复，延迟一小段时间后播放下一遍
                        if (currentRepeat < repeatCount) {
                            setTimeout(playNext, 500); // 0.5秒的间隔
                        }
                    });
                }
            };
            
            // 开始第一次播放
            playNext();
        }

        // 使用普通Audio元素播放音频并重复
        function playAudioElementWithRepeat(audioUrl, fallbackText, repeatCount) {
            let currentRepeat = 0;
            
            const playNext = () => {
                currentRepeat++;
                console.log(`播放第 ${currentRepeat}/${repeatCount} 遍`);
                
                const audio = new Audio(audioUrl);
                
                // 添加加载错误处理
                audio.onerror = function(e) {
                    console.error(`第 ${currentRepeat} 遍音频加载失败:`, e);
                    if (currentRepeat === 1) {
                        // 只在第一次失败时降级到浏览器TTS
                        useBrowserTTS(fallbackText, repeatCount);
                    }
                };
                
                // 添加音频播放完成事件
                audio.onended = function() {
                    console.log(`第 ${currentRepeat} 遍音频播放完成`);
                    
                    // 移除音频元素
                    if (audio.parentNode) {
                        audio.parentNode.removeChild(audio);
                    }
                    
                    // 如果还需要继续重复，延迟一小段时间后播放下一遍
                    if (currentRepeat < repeatCount) {
                        setTimeout(playNext, 500); // 0.5秒的间隔
                    }
                };
                
                // 将音频元素添加到DOM
                audio.style.display = 'none';
                document.body.appendChild(audio);
                
                // 开始播放
                audio.play().catch(err => {
                    console.error(`第 ${currentRepeat} 遍音频播放失败:`, err);
                    if (currentRepeat === 1) {
                        // 只在第一次失败时降级到浏览器TTS
                        useBrowserTTS(fallbackText, repeatCount);
                    }
                });
            };
            
            // 开始第一次播放
            playNext();
        }

        // 使用浏览器原生语音合成
        function useBrowserTTS(text, repeatCount = 1) {
            // 检查浏览器是否支持语音合成
            if ('speechSynthesis' in window) {
                // 创建一个数组，包含需要播放的文本（重复多次）
                const textsToSpeak = Array(repeatCount).fill(text);
                let currentIndex = 0;
                
                const speakNext = () => {
                    if (currentIndex < textsToSpeak.length) {
                        const utterance = new SpeechSynthesisUtterance(textsToSpeak[currentIndex]);
                        
                        // 尝试设置中文语音
                        const voices = window.speechSynthesis.getVoices();
                        const chineseVoice = voices.find(voice => 
                            voice.lang.includes('zh') || 
                            voice.name.includes('Chinese') || 
                            voice.name.includes('中文')
                        );
                        
                        if (chineseVoice) {
                            utterance.voice = chineseVoice;
                            utterance.lang = chineseVoice.lang;
                        } else {
                            utterance.lang = 'zh-CN';
                        }
                        
                        // 当前文本播放完毕后的回调
                        utterance.onend = () => {
                            console.log(`浏览器TTS: 第 ${currentIndex + 1} 遍播放完成`);
                            currentIndex++;
                            // 延迟一小段时间后播放下一遍
                            setTimeout(speakNext, 500);
                        };
                        
                        console.log(`浏览器TTS: 播放第 ${currentIndex + 1}/${repeatCount} 遍`);
                        window.speechSynthesis.speak(utterance);
                    }
                };
                
                // 开始第一次播放
                speakNext();
            } else {
                console.error('浏览器不支持语音合成');
            }
        }

        // ... existing code ...
        ws.onopen = () => {
            console.log('WebSocket连接已建立');
        };
        
        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                
                // 处理语音识别结果
                if (data.type === 'asr_result') {
                    updateRecognitionText(data);
                }
                // 处理语音识别完成事件
                else if (data.type === 'asr_complete') {
                    handleRecognitionComplete(data);
                }
                // 处理计时器完成事件
                else if (data.type === 'timer_completed') {
                    // 计时器完成
                    handleTimerCompleted(data.timer);
                }
                // 添加对聊天响应的处理
                else if (data.type === 'chat_response') {
                    // 隐藏输入指示器
                    typingIndicator.style.display = 'none';
                    
                    if (data.success) {
                        // 添加机器人消息
                        console.log('收到回复:', data.answer);
                        addMessage(data.answer, 'bot');
                        
                        // 消息分类标识（可选：如果需要在UI上展示分类）
                        if (data.messageType) {
                            console.log(`消息分类: ${data.messageType}`);
                        }
                        
                        // 如果启用了自动语音
                        if (window.autoSpeakEnabled) {
                            // 请求语音合成
                            requestSpeech(data.answer);
                        }
                    } else {
                        // 处理错误
                        addMessage(data.error || '抱歉，处理您的请求时出错了。', 'bot');
                    }
                    
                    // 滚动到底部
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
                // 处理聊天响应更新
                else if (data.type === 'chat_response_update') {
                    console.log('收到聊天响应更新:', data.answer);
                    
                    if (data.success) {
                        // 添加更新的回复
                        addMessage(data.answer, 'bot');
                        
                        // 如果启用了自动语音，播放更新回复的语音
                        if (window.autoSpeakEnabled) {
                            // 请求语音合成
                            requestSpeech(data.answer);
                        }
                    }
                }
                // 处理TTS响应
                else if (data.type === 'tts_response') {
                    if (data.success && data.audioUrl) {
                        playAudio(data.audioUrl);
                    } else {
                        console.error('TTS处理失败:', data.error || '未知错误');
                    }
                }
            } catch (error) {
                console.error('解析WebSocket消息失败:', error);
            }
        };
        
        ws.onclose = () => {
            console.log('WebSocket连接已关闭，尝试重连...');
            setTimeout(connectWebSocket, 3000);
        };
        // ... existing code ...

        // 下面的函数已被禁用，不再使用实时流式识别
        /*
        function sendAudioChunkForRecognition(audioBlob) {
            // 函数内容被禁用
        }
        */

        // ... existing code ...

        // 初始化全局变量
        window.currentResponseReader = null;
        window.currentBotMessageElement = null;
        window.currentSynthesisRequests = [];

        // 初始化计时器历史记录功能
        function initTimerHistory() {
            const modal = document.getElementById('timerHistoryModal');
            const btn = document.getElementById('timer-history-button');
            const closeBtn = document.getElementsByClassName('close')[0];
            
            // 如果必要元素不存在，直接返回
            if (!modal || !btn) {
                console.warn('计时器历史模态框或按钮不存在，跳过初始化');
                return;
            }
            
            // 点击计时器历史按钮打开模态框
            btn.onclick = function() {
                loadTimerHistory();
                modal.style.display = 'block';
            }
            
            // 点击关闭按钮关闭模态框
            if (closeBtn) {
            closeBtn.onclick = function() {
                modal.style.display = 'none';
                }
            } else {
                console.warn('模态框关闭按钮不存在');
            }
            
            // 点击模态框外部关闭模态框
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            }
        }
        
        // 加载计时器历史记录
        function loadTimerHistory() {
            console.log('加载计时器历史记录');
            const tableBody = document.getElementById('timerHistoryTableBody');
            
            if (!tableBody) {
                console.error('计时器历史记录表格不存在');
                return;
            }
            
            tableBody.innerHTML = '<tr><td colspan="3" class="no-history">加载中...</td></tr>';
            
            fetch('/api/timer-history')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP错误! 状态码: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('获取计时器历史记录成功:', data);
                    
                    if (data.success && data.data && data.data.length > 0) {
                        // 清空表格
                        tableBody.innerHTML = '';
                        
                        // 添加历史记录
                        data.data.forEach(record => {
                            const row = document.createElement('tr');
                            
                            // 格式化时间
                            const completedAt = new Date(record.completed_at);
                            const formattedDate = `${completedAt.getFullYear()}-${(completedAt.getMonth()+1).toString().padStart(2, '0')}-${completedAt.getDate().toString().padStart(2, '0')} ${completedAt.getHours().toString().padStart(2, '0')}:${completedAt.getMinutes().toString().padStart(2, '0')}:${completedAt.getSeconds().toString().padStart(2, '0')}`;
                            
                            row.innerHTML = `
                                <td>${record.title || '--'}</td>
                                <td>${record.message || '--'}</td>
                                <td>${formattedDate}</td>
                            `;
                            tableBody.appendChild(row);
                        });
                    } else {
                        tableBody.innerHTML = '<tr><td colspan="3" class="no-history">没有找到计时器历史记录</td></tr>';
                    }
                })
                .catch(error => {
                    console.error('获取计时器历史记录失败:', error);
                    tableBody.innerHTML = `<tr><td colspan="3" class="no-history">加载失败: ${error.message}</td></tr>`;
                });
        }

        // 全局设置变量 - 已在页面头部内联脚本中初始化
        // 注: 原始声明已移到head中的内联脚本，解决变量初始化顺序问题
        // timerSettings包含:
        // - repeatCount: 提醒重复次数(默认2)
        // - intervalSeconds: 间隔秒数(默认5)
        // - autoStopOnResponse: 有响应时停止提醒(默认true)
        // - audioLoopCount: 音频循环次数(默认1)
        // - audioLoopInterval: 音频循环间隔(默认500ms)
        
        // 定时器相关变量
        let activeTimerReminders = new Map(); // 保存活动的提醒计时器
        let lastUserInteractionTime = Date.now(); // 上次用户交互时间
        
        // DOM加载完成后初始化设置面板
        document.addEventListener('DOMContentLoaded', () => {
            // ... existing code ...
            
            // 初始化设置面板
            initSettingsPanel();
        });
        
        // 初始化设置面板
        function initSettingsPanel() {
            console.log('开始初始化设置面板...');
            
            const toggleSettingsBtn = document.getElementById('toggleSettings');
            console.log('计时器设置按钮元素:', toggleSettingsBtn);
            
            const settingsModal = document.getElementById('timerSettingsModal');
            console.log('设置模态窗口元素:', settingsModal);
            
            const closeBtn = document.getElementById('closeTimerSettings');
            const saveBtn = document.getElementById('saveTimerSettings');
            const testBtn = document.getElementById('testAudioLoop');
            
            const repeatCountInput = document.getElementById('reminderRepeatCount');
            const intervalInput = document.getElementById('reminderInterval');
            const autoStopSelect = document.getElementById('autoStopReminders');
            const audioLoopCountInput = document.getElementById('audioLoopCount');
            const audioLoopIntervalInput = document.getElementById('audioLoopInterval');
            
            // 从localStorage加载设置
            loadSettings();
            
            // 设置初始值
            if (repeatCountInput) repeatCountInput.value = timerSettings.repeatCount;
            if (intervalInput) intervalInput.value = timerSettings.intervalSeconds;
            if (autoStopSelect) autoStopSelect.value = timerSettings.autoStopOnResponse.toString();
            if (audioLoopCountInput) audioLoopCountInput.value = timerSettings.audioLoopCount || 1;
            if (audioLoopIntervalInput) audioLoopIntervalInput.value = timerSettings.audioLoopInterval || 500;
            
            // 点击设置按钮打开模态窗口
            if (toggleSettingsBtn && settingsModal) {
                console.log('正在添加设置按钮点击事件...');
                toggleSettingsBtn.onclick = function() {
                    console.log('设置按钮被点击');
                    settingsModal.style.display = 'block';
                }
            } else {
                console.error('设置按钮或模态窗口元素不存在，无法添加点击事件');
            }
            
            // 点击关闭按钮
            if (closeBtn) {
                closeBtn.onclick = function() {
                    console.log('关闭按钮被点击');
                    if (settingsModal) settingsModal.style.display = 'none';
                }
            }
            
            // 点击模态窗口外部也可关闭
            if (settingsModal) {
                window.onclick = function(event) {
                    if (event.target === settingsModal) {
                        console.log('点击了模态窗口外部');
                        settingsModal.style.display = 'none';
                    }
                }
            }
            
            // 保存设置
            if (saveBtn) {
                saveBtn.onclick = function() {
                    console.log('保存按钮被点击');
                    // 直接调用本地保存函数，避免调用外部库中的函数
                    try {
                        const repeatCountInput = document.getElementById('reminderRepeatCount');
                        const intervalInput = document.getElementById('reminderInterval');
                        const autoStopSelect = document.getElementById('autoStopReminders');
                        const audioLoopCountInput = document.getElementById('audioLoopCount');
                        const audioLoopIntervalInput = document.getElementById('audioLoopInterval');
                        
                        // 更新设置
                        timerSettings.repeatCount = Math.max(1, Math.min(10, parseInt(repeatCountInput.value) || 2));
                        timerSettings.intervalSeconds = Math.max(1, Math.min(60, parseInt(intervalInput.value) || 5));
                        timerSettings.autoStopOnResponse = autoStopSelect.value === 'true';
                        timerSettings.audioLoopCount = Math.max(1, Math.min(5, parseInt(audioLoopCountInput.value) || 1));
                        timerSettings.audioLoopInterval = Math.max(0, Math.min(5000, parseInt(audioLoopIntervalInput.value) || 500));
                        
                        // 更新输入框值（防止无效输入）
                        repeatCountInput.value = timerSettings.repeatCount;
                        intervalInput.value = timerSettings.intervalSeconds;
                        audioLoopCountInput.value = timerSettings.audioLoopCount;
                        audioLoopIntervalInput.value = timerSettings.audioLoopInterval;
                        
                        // 保存到localStorage
                        localStorage.setItem('timerSettings', JSON.stringify(timerSettings));
                        console.log('计时器设置已成功保存:', timerSettings);
                        
                        // 关闭模态窗口
                        if (settingsModal) settingsModal.style.display = 'none';
                        
                        // 显示保存成功的通知
                        showNotification('设置已保存');
                    } catch (error) {
                        console.error('保存设置失败:', error);
                        showNotification('保存设置失败: ' + error.message);
                    }
                }
            }
            
            // 测试循环播放
            if (testBtn) {
                testBtn.onclick = function() {
                    console.log('测试按钮被点击');
                    // 不再调用外部的saveSettings()函数，避免错误
                    // 直接测试音频循环播放
                    testAudioLoopPlayback();
                }
            }
            
            // 用户输入消息时记录交互时间
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.addEventListener('input', () => {
                    lastUserInteractionTime = Date.now();
                    // 如果用户开始输入，停止所有提醒
                    if (timerSettings.autoStopOnResponse && messageInput.value.trim().length > 0) {
                        stopAllTimerReminders();
                    }
                });
            }
            
            console.log('设置面板初始化完成');
        }
        
        // 从localStorage加载设置
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('timerSettings');
                if (savedSettings) {
                    const parsedSettings = JSON.parse(savedSettings);
                    timerSettings.repeatCount = parsedSettings.repeatCount || 2;
                    timerSettings.intervalSeconds = parsedSettings.intervalSeconds || 5;
                    timerSettings.autoStopOnResponse = parsedSettings.autoStopOnResponse !== false; // 默认为true
                    timerSettings.audioLoopCount = parsedSettings.audioLoopCount || 1;
                    timerSettings.audioLoopInterval = parsedSettings.audioLoopInterval || 500;
                }
            } catch (error) {
                console.error('加载设置失败:', error);
            }
        }
        
        // 保存设置到localStorage
        function saveSettings() {
            try {
                const repeatCountInput = document.getElementById('reminderRepeatCount');
                const intervalInput = document.getElementById('reminderInterval');
                const autoStopSelect = document.getElementById('autoStopReminders');
                const audioLoopCountInput = document.getElementById('audioLoopCount');
                const audioLoopIntervalInput = document.getElementById('audioLoopInterval');
                
                // 更新设置
                timerSettings.repeatCount = Math.max(1, Math.min(10, parseInt(repeatCountInput.value) || 2));
                timerSettings.intervalSeconds = Math.max(1, Math.min(60, parseInt(intervalInput.value) || 5));
                timerSettings.autoStopOnResponse = autoStopSelect.value === 'true';
                timerSettings.audioLoopCount = Math.max(1, Math.min(5, parseInt(audioLoopCountInput.value) || 1));
                timerSettings.audioLoopInterval = Math.max(0, Math.min(5000, parseInt(audioLoopIntervalInput.value) || 500));
                
                // 更新输入框值（防止无效输入）
                repeatCountInput.value = timerSettings.repeatCount;
                intervalInput.value = timerSettings.intervalSeconds;
                audioLoopCountInput.value = timerSettings.audioLoopCount;
                audioLoopIntervalInput.value = timerSettings.audioLoopInterval;
                
                // 保存到localStorage
                localStorage.setItem('timerSettings', JSON.stringify(timerSettings));
                console.log('计时器设置已保存:', timerSettings);
            } catch (error) {
                console.error('保存设置失败:', error);
            }
        }
        
        // 设置计时器重复提醒
        function setupTimerReminders(timerId, message) {
            // 如果已经有这个计时器的提醒，先清除
            if (activeTimerReminders.has(timerId)) {
                clearTimeout(activeTimerReminders.get(timerId));
            }
            
            // 当前已播放了第1次，所以从2开始计数
            let repeatCount = 2;
            
            const scheduleNextReminder = () => {
                if (repeatCount <= timerSettings.repeatCount) {
                    // 计算上次用户交互到现在的时间
                    const timeSinceLastInteraction = Date.now() - lastUserInteractionTime;
                    
                    // 如果设置为在用户响应后停止，且用户已有交互，则不再提醒
                    if (timerSettings.autoStopOnResponse && timeSinceLastInteraction < timerSettings.intervalSeconds * 1000) {
                        console.log('检测到用户交互，停止后续提醒');
                        return;
                    }
                    
                    // 安排下一次提醒
                    const timerId = setTimeout(() => {
                        console.log(`播放第${repeatCount}/${timerSettings.repeatCount}次提醒`);
                        playWithAlertSound(message);
                        
                        repeatCount++;
                        if (repeatCount <= timerSettings.repeatCount) {
                            scheduleNextReminder();
                        } else {
                            activeTimerReminders.delete(timerId);
                        }
                    }, timerSettings.intervalSeconds * 1000);
                    
                    activeTimerReminders.set(timerId, timerId);
                }
            };
            
            // 开始安排提醒
            scheduleNextReminder();
        }
        
        // 停止所有计时器提醒
        function stopAllTimerReminders() {
            console.log('停止所有计时器提醒');
            activeTimerReminders.forEach((timeoutId) => {
                clearTimeout(timeoutId);
            });
            activeTimerReminders.clear();
        }

        // 测试音频循环播放
        function testAudioLoopPlayback() {
            const testMessage = "这是一条测试消息，用于验证循环播放设置。";
            const alertSoundUrl = '/audio/Broadcastalert.mp3';
            
            // 检查是否有AudioAutoplay模块
            if (window.AudioAutoplay) {
                showNotification('正在测试音频循环播放...');
                
                // 使用循环设置
                const options = {
                    loopCount: timerSettings.audioLoopCount,
                    loopInterval: timerSettings.audioLoopInterval
                };
                
                console.log(`测试循环播放: 循环${options.loopCount}次，间隔${options.loopInterval}ms`);
                
                // 播放提示音
                window.AudioAutoplay.playLoop(alertSoundUrl, options, () => {
                    showNotification('音频循环播放测试完成');
                    
                    // 延迟1秒后播放消息测试
                    setTimeout(() => {
                        speakMessage(testMessage);
                    }, 1000);
                });
            } else {
                console.error('AudioAutoplay模块未加载，无法测试');
                showNotification('无法测试音频循环播放，请确保音频模块已加载');
            }
        }

        // 显示通知
        function showNotification(message) {
            const notificationEl = document.getElementById('notification');
            if (notificationEl) {
                notificationEl.textContent = message;
                notificationEl.style.display = 'block';
                
                // 3秒后隐藏
                setTimeout(() => {
                    notificationEl.style.display = 'none';
                }, 3000);
            } else {
                // 如果没有通知元素，创建一个临时通知
                const tempNotification = document.createElement('div');
                tempNotification.textContent = message;
                tempNotification.style.position = 'fixed';
                tempNotification.style.top = '20px';
                tempNotification.style.right = '20px';
                tempNotification.style.backgroundColor = '#4CAF50';
                tempNotification.style.color = 'white';
                tempNotification.style.padding = '15px';
                tempNotification.style.borderRadius = '4px';
                tempNotification.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
                tempNotification.style.zIndex = '1000';
                
                document.body.appendChild(tempNotification);
                
                // 3秒后移除
                setTimeout(() => {
                    if (document.body.contains(tempNotification)) {
                        document.body.removeChild(tempNotification);
                    }
                }, 3000);
            }
        }

        // 页面加载时立即尝试解锁音频
        document.addEventListener('DOMContentLoaded', function() {
            console.log('页面加载完成，尝试初始化音频解锁');
            
            // 尝试直接设置计时器设置按钮的点击事件
            const settingsBtn = document.getElementById('toggleSettings');
            const settingsModal = document.getElementById('timerSettingsModal');
            
            if (settingsBtn && settingsModal) {
                console.log('找到计时器设置按钮和模态窗口，添加点击事件');
                
                // 使用直接赋值的方式绑定onclick事件
                settingsBtn.onclick = function() {
                    console.log('计时器设置按钮被点击');
                    settingsModal.style.display = 'block';
                };
                
                // 为关闭按钮添加事件
                const closeBtn = document.getElementById('closeTimerSettings');
                if (closeBtn) {
                    closeBtn.onclick = function() {
                        settingsModal.style.display = 'none';
                    };
                }
                
                // 点击模态窗口外部关闭
                window.onclick = function(event) {
                    if (event.target === settingsModal) {
                        settingsModal.style.display = 'none';
                    }
                };
            } else {
                console.error('计时器设置按钮或模态窗口不存在，无法绑定点击事件');
                if (!settingsBtn) console.error('找不到计时器设置按钮');
                if (!settingsModal) console.error('找不到计时器设置模态窗口');
            }
            
            // 检查AudioAutoplay模块是否存在
            if (window.AudioAutoplay) {
                // 获取初始状态
                const initialStatus = window.AudioAutoplay.getStatus();
                console.log('初始音频状态:', initialStatus);
                
                // 主动尝试解锁
                window.AudioAutoplay.unlock();
                
                // 添加一个用户交互事件监听器，以帮助解锁
                const unlockWithInteraction = () => {
                    if (!window.AudioAutoplay.isFullyUnlocked()) {
                        console.log('用户交互，尝试解锁音频播放');
                        window.AudioAutoplay.unlock();
                        
                        // 检查解锁状态
                        setTimeout(() => {
                            const status = window.AudioAutoplay.getStatus();
                            console.log('交互后音频状态:', status);
                            
                            if (!status.fullyUnlocked) {
                                console.log('通过交互未能完全解锁，显示手动解锁按钮');
                                window.AudioAutoplay.showUnlockButton();
                            }
                        }, 500);
                    }
                };
                
                // 添加事件监听器
                document.addEventListener('click', unlockWithInteraction, { once: false });
                document.addEventListener('touchstart', unlockWithInteraction, { once: false });
                document.addEventListener('keydown', unlockWithInteraction, { once: false });
                
                // 2秒后检查解锁状态
                setTimeout(function() {
                    const status = window.AudioAutoplay.getStatus();
                    console.log('2秒后音频状态:', status);
                    
                    // 如果还未解锁成功，显示手动解锁按钮
                    if (!status.fullyUnlocked && !status.unlocked) {
                        console.log('自动解锁失败，显示手动解锁按钮');
                        window.AudioAutoplay.showUnlockButton();
                    }
                }, 2000);
            } else {
                console.error('AudioAutoplay模块未能正确加载！');
            }
        });
    </script>
    
    <!-- 添加音频自动播放模块 -->
    <script src="/js/audio-autoplay.js"></script>
    
    <!-- 集成音频自动播放功能 -->
    <script>
        // 页面加载时立即尝试解锁音频
        document.addEventListener('DOMContentLoaded', function() {
            console.log('页面加载完成，尝试初始化音频解锁');
            
            // 尝试直接设置计时器设置按钮的点击事件
            const settingsBtn = document.getElementById('toggleSettings');
            const settingsModal = document.getElementById('timerSettingsModal');
            
            if (settingsBtn && settingsModal) {
                console.log('找到计时器设置按钮和模态窗口，添加点击事件');
                
                // 使用直接赋值的方式绑定onclick事件
                settingsBtn.onclick = function() {
                    console.log('计时器设置按钮被点击');
                    settingsModal.style.display = 'block';
                };
                
                // 为关闭按钮添加事件
                const closeBtn = document.getElementById('closeTimerSettings');
                if (closeBtn) {
                    closeBtn.onclick = function() {
                        settingsModal.style.display = 'none';
                    };
                }
                
                // 点击模态窗口外部关闭
                window.onclick = function(event) {
                    if (event.target === settingsModal) {
                        settingsModal.style.display = 'none';
                    }
                };
            } else {
                console.error('计时器设置按钮或模态窗口不存在，无法绑定点击事件');
                if (!settingsBtn) console.error('找不到计时器设置按钮');
                if (!settingsModal) console.error('找不到计时器设置模态窗口');
            }
            
            // 检查AudioAutoplay模块是否存在
            if (window.AudioAutoplay) {
                // 获取初始状态
                const initialStatus = window.AudioAutoplay.getStatus();
                console.log('初始音频状态:', initialStatus);
                
                // 主动尝试解锁
                window.AudioAutoplay.unlock();
                
                // 添加一个用户交互事件监听器，以帮助解锁
                const unlockWithInteraction = () => {
                    if (!window.AudioAutoplay.isFullyUnlocked()) {
                        console.log('用户交互，尝试解锁音频播放');
                        window.AudioAutoplay.unlock();
                        
                        // 检查解锁状态
                        setTimeout(() => {
                            const status = window.AudioAutoplay.getStatus();
                            console.log('交互后音频状态:', status);
                            
                            if (!status.fullyUnlocked) {
                                console.log('通过交互未能完全解锁，显示手动解锁按钮');
                                window.AudioAutoplay.showUnlockButton();
                            }
                        }, 500);
                    }
                };
                
                // 添加事件监听器
                document.addEventListener('click', unlockWithInteraction, { once: false });
                document.addEventListener('touchstart', unlockWithInteraction, { once: false });
                document.addEventListener('keydown', unlockWithInteraction, { once: false });
                
                // 2秒后检查解锁状态
                setTimeout(function() {
                    const status = window.AudioAutoplay.getStatus();
                    console.log('2秒后音频状态:', status);
                    
                    // 如果还未解锁成功，显示手动解锁按钮
                    if (!status.fullyUnlocked && !status.unlocked) {
                        console.log('自动解锁失败，显示手动解锁按钮');
                        window.AudioAutoplay.showUnlockButton();
                    }
                }, 2000);
            } else {
                console.error('AudioAutoplay模块未能正确加载！');
            }
        });
        
        // 保存原始的处理函数
        const originalProcessNextAudio = processNextAudio;
        
        // 完全覆盖音频处理函数，使用AudioAutoplay模块
        processNextAudio = async function() {
            // 如果没有待处理的URL，直接返回
            if (pendingAudioUrls.length === 0) return;
            
            // 如果已经在处理中，直接返回
            if (isProcessingAudio) return;
            
            // 标记正在处理
            isProcessingAudio = true;
            
            try {
                // 获取第一个URL进行处理
                const url = pendingAudioUrls.shift();
                
                // 尝试使用AudioAutoplay模块播放
                if (window.AudioAutoplay) {
                    console.log('使用AudioAutoplay模块播放音频:', url);
                    window.AudioAutoplay.play(url, () => {
                        console.log('AudioAutoplay播放完成:', url);
                        processedUrls.add(url);
                        totalAudioPlayed++;
                        
                        // 处理完毕，标记为非处理状态
                        isProcessingAudio = false;
                        
                        // 处理下一个
                        processNextAudio();
                    });
                } else {
                    // 如果AudioAutoplay不可用，回退到原始方法
                    console.warn('AudioAutoplay模块不可用，使用原始音频处理函数');
                    originalProcessNextAudio();
                }
            } catch (error) {
                console.error('处理音频出错:', error);
                isProcessingAudio = false;
                processNextAudio(); // 尝试处理下一个
            }
        };
    </script>
    
    <!-- 添加音频协调器脚本 -->
    <script src="/js/audio-playback-coordinator.js"></script>
    
    <!-- 添加计时器设置修复脚本 -->
    <script src="/js/chat-settings-fix.js"></script>
    <script src="/js/timer-settings-fix.js"></script>
    <!-- 添加音频URL处理修复脚本 -->
    <script src="/js/chat-audio-url-fix.js"></script>
    <!-- 添加对话框语音修复脚本(放在最后确保优先级最高) -->
    <script src="/js/chat-dialog-audio-fix.js"></script>
    <!-- 添加整合修复脚本(最终解决方案) -->
    <script src="/js/timer-audio-integration-fix.js"></script>
    <!-- 在其他类似的脚本引用之后添加我们的表单修复脚本 -->
    <script src="/js/timer-settings-form-fix.js"></script>
</body>
</html>
