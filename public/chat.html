<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <!-- 立即加载交互时间修复脚本 -->
    <script src="/js/timer-interaction-fix.js"></script>
    
    <!-- 立即初始化关键变量 -->
    <script>
        // 确保lastUserInteractionTime变量在页面加载最早期就被初始化
        window.lastUserInteractionTime = Date.now();
        console.log('[内联脚本] 已初始化lastUserInteractionTime =', new Date(window.lastUserInteractionTime).toLocaleTimeString());
        
        // 初始化activeTimerReminders变量
        window.activeTimerReminders = new Map();
        console.log('[内联脚本] 已初始化activeTimerReminders');
        
        // 初始化自动语音播放开关
        window.autoSpeakEnabled = true;
        console.log('[内联脚本] 已初始化autoSpeakEnabled = true');
        
        // 初始化语音设置
        window.currentVoice = 'longxiaochun';
        window.currentAudio = null;
        console.log('[内联脚本] 已初始化语音设置');

        // 初始化告警状态
        window.alarmPlayingState = {
            isPlaying: false,       // 是否正在播放告警
            activeAlarms: [],       // 当前活动的告警列表
            lastAlarmStates: {},    // 记录上一次告警状态
            loopCounter: 0,         // 循环计数
            paused: false,          // 告警是否被暂停
            alarmCount: 0,          // 告警触发次数
            nextAlarmTime: null,    // 下次告警时间
            alarmHistory: [],       // 告警历史记录
            alarmFirstTriggerTime: {} // 记录每个告警首次触发时间
        };
        console.log('[内联脚本] 已初始化告警状态');
    </script>
    
    <!-- 立即初始化timerSettings变量，确保在任何脚本执行前就存在 -->
    <script>
    (function() {
        console.log('[内联修复] 立即初始化timerSettings变量');
        
        // 在全局作用域定义timerSettings
        window.timerSettings = {
            repeatCount: 2,         // 默认重复次数
            intervalSeconds: 5,     // 默认间隔秒数
            autoStopOnResponse: true, // 默认有响应时停止提醒
            audioLoopCount: 1,      // 音频循环次数
            audioLoopInterval: 500  // 音频循环间隔
        };
        
        // 初始化计时器相关变量，避免类似的初始化顺序问题
        window.activeTimerReminders = new Map(); // 保存活动的提醒计时器
        window.lastUserInteractionTime = Date.now(); // 上次用户交互时间
        
        // 尝试从localStorage加载已保存的设置
        try {
            const savedSettings = localStorage.getItem('timerSettings');
            if (savedSettings) {
                const parsedSettings = JSON.parse(savedSettings);
                // 合并已保存的设置
                window.timerSettings = {...window.timerSettings, ...parsedSettings};
                console.log('[内联修复] 从localStorage加载了保存的设置');
            }
        } catch (error) {
            console.error('[内联修复] 加载设置出错:', error);
        }
        
        // 确保initSettingsPanel函数可以安全执行
        const originalInitSettingsPanel = window.initSettingsPanel;
        window.initSettingsPanel = function() {
            console.log('[内联修复] 调用安全版本的initSettingsPanel');
            
            // 再次确认timerSettings存在
            if (typeof window.timerSettings === 'undefined') {
                console.warn('[内联修复] timerSettings不存在，重新初始化');
                window.timerSettings = {
                    repeatCount: 2,
                    intervalSeconds: 5,
                    autoStopOnResponse: true,
                    audioLoopCount: 1,
                    audioLoopInterval: 500
                };
            }
            
            // 调用原始函数
            if (typeof originalInitSettingsPanel === 'function') {
                try {
                    originalInitSettingsPanel();
                } catch (e) {
                    console.error('[内联修复] 执行原始initSettingsPanel出错:', e);
                }
            }
        };
        
        console.log('[内联修复] 变量初始化和函数修复完成');
    })();
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能聊天</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background-color: #4CAF50;
            color: white;
            padding: 15px;
            text-align: center;
            border-radius: 5px 5px 0 0;
        }
        
        .chat-container {
            background-color: white;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .chat-messages {
            height: 400px;
            overflow-y: auto;
            padding: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 70%;
            word-wrap: break-word;
        }
        
        .user-message {
            background-color: #DCF8C6;
            margin-left: auto;
            border-bottom-right-radius: 5px;
        }
        
        .bot-message {
            background-color: #F1F0F0;
            margin-right: auto;
            border-bottom-left-radius: 5px;
        }
        
        .chat-input {
            display: flex;
            padding: 15px;
        }
        
        .chat-input input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
            font-size: 16px;
        }
        
        .chat-input button {
            margin-left: 10px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .chat-input button:hover {
            background-color: #45a049;
        }
        
        .typing-indicator {
            display: none;
            padding: 10px 15px;
            background-color: #f1f1f1;
            border-radius: 18px;
            margin-bottom: 15px;
            width: fit-content;
        }
        
        .typing-indicator span {
            height: 10px;
            width: 10px;
            float: left;
            margin: 0 1px;
            background-color: #9E9EA1;
            display: block;
            border-radius: 50%;
            opacity: 0.4;
        }
        
        .typing-indicator span:nth-of-type(1) {
            animation: 1s blink infinite 0.3333s;
        }
        
        .typing-indicator span:nth-of-type(2) {
            animation: 1s blink infinite 0.6666s;
        }
        
        .typing-indicator span:nth-of-type(3) {
            animation: 1s blink infinite 0.9999s;
        }
        
        @keyframes blink {
            50% {
                opacity: 1;
            }
        }
        
        .file-upload {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .file-upload input {
            display: none;
        }
        
        .file-upload label {
            padding: 8px 15px;
            background-color: #f1f1f1;
            border-radius: 20px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        .file-upload label:hover {
            background-color: #e1e1e1;
        }
        
        .file-preview {
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .file-item {
            position: relative;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .file-item img {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 5px;
        }
        
        .remove-file {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: #ff4d4d;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            cursor: pointer;
        }
        
        .file-status {
            margin-top: 5px;
            font-size: 14px;
            color: #666;
        }
        
        .nav-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background-color: #333;
        }
        
        .nav-bar a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
        }
        
        .nav-bar a:hover {
            background-color: #555;
            border-radius: 5px;
        }
        
        /* 控制台按钮样式 */
        .console-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
            transition: background-color 0.3s;
        }
        
        .console-button:hover {
            background-color: #45a049;
        }
        
        /* 重置按钮样式 */
        .reset-button {
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .reset-button:hover {
            background-color: #ff5252;
        }
        
        .actions {
            display: flex;
            justify-content: flex-end;
            margin-left: auto;
        }
        
        /* 录音按钮样式 */
        .record-button {
            margin-left: 10px;
            padding: 10px 20px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .record-button.recording {
            background-color: #cc0000;
            animation: pulse 1.5s infinite;
        }
        
        .record-button:hover {
            background-color: #d32f2f;
        }
        
        @keyframes pulse {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                opacity: 1;
            }
        }
        
        .recording-status {
            display: none;
            font-size: 14px;
            color: #f44336;
            margin-top: 5px;
            text-align: center;
        }
        
        /* 添加计时器历史记录按钮样式 */
        .timer-history-button {
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
            transition: background-color 0.3s;
        }
        
        .timer-history-button:hover {
            background-color: #0b7dda;
        }
        
        /* 计时器历史记录模态框样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 800px;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: #000;
        }
        
        .timer-history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .timer-history-table th, .timer-history-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .timer-history-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .timer-history-table th {
            padding-top: 12px;
            padding-bottom: 12px;
            background-color: #4CAF50;
            color: white;
        }
        
        .timer-history-table tr:hover {
            background-color: #ddd;
        }
        
        .no-history {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        
        /* 添加计时器设置面板样式 */
        .settings-panel {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin-top: 15px;
        }
        
        .settings-panel h3 {
            margin-top: 0;
            color: #4CAF50;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .settings-row label {
            flex: 1;
            margin-right: 10px;
        }
        
        .settings-row input, .settings-row select {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .settings-info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            font-style: italic;
        }
        
        .settings-toggle {
            background-color: #f1f1f1;
            color: #333;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 14px;
        }
        
        .settings-toggle:hover {
            background-color: #e1e1e1;
        }

        /* 模态窗口样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            max-width: 600px;
            position: relative;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #555;
        }

        .settings-container {
            margin-top: 15px;
        }

        .settings-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }

        .settings-section h3 {
            margin-top: 0;
            color: #4CAF50;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }

        .settings-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .save-btn, .test-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .save-btn {
            background-color: #4CAF50;
            color: white;
        }

        .test-btn {
            background-color: #2196F3;
            color: white;
        }

        .save-btn:hover {
            background-color: #45a049;
        }

        .test-btn:hover {
            background-color: #0b7dda;
        }
        
        /* 临时消息样式 */
        .temporary-message {
            opacity: 0.8;
            position: relative;
        }
        
        /* 加载动画样式 */
        .loading-dots {
            display: inline-block;
            margin-left: 10px;
            vertical-align: bottom;
        }
        
        .loading-dots span {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #777;
            margin-right: 3px;
            animation: dotPulse 1.5s infinite ease-in-out;
        }
        
        .loading-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .loading-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes dotPulse {
            0%, 100% { transform: scale(0.6); opacity: 0.6; }
            50% { transform: scale(1); opacity: 1; }
        }
        
        /* 消息文本样式 */
        .message-text {
            display: inline-block;
            vertical-align: middle;
        }

        /* 添加新对话和历史对话按钮样式 */
        .chat-actions {
            display: flex;
            align-items: center;
            margin: 0 15px;
        }

        .action-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            margin: 0 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .action-button:hover {
            background-color: #45a049;
        }

        /* 下拉菜单样式 */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: #f9f9f9;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1000;
            border-radius: 4px;
        }

        .dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            transition: background-color 0.2s;
            border-bottom: 1px solid #eee;
        }

        .dropdown-content a:hover {
            background-color: #f1f1f1;
        }

        .dropdown-content .no-history {
            padding: 15px;
            text-align: center;
            color: #777;
            font-style: italic;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item .date {
            font-size: 12px;
            color: #666;
        }

        .history-item .preview {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 180px;
        }

        /* 添加告警消息样式 */
        .message-alarm {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }

        .alarm-notification {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #856404;
        }

        .alarm-notification i {
            font-size: 1.2em;
        }

        .alarm-notification strong {
            color: #dc3545;
        }
    </style>
    <!-- 计时器设置已通过内联脚本初始化，不再需要外部修复脚本 -->
    <!-- <script src="/js/timer-settings-init-quick-fix.js"></script> -->

    <!-- 禁用所有调试功能 -->
    <script>
    (function() {
        console.log('[调试禁用] 正在禁用所有调试面板和功能');
        
        // 添加CSS来隐藏调试面板
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            /* 隐藏所有调试元素 */
            #timerDebugPanel, #debugToggle, .debug-panel, .debug-toggle,
            [id^="debug-"], [class^="debug-"], [id*="debug"], [class*="debug"] {
                display: none !important;
                visibility: hidden !important;
                opacity: 0 !important;
                height: 0 !important;
                width: 0 !important;
                position: absolute !important;
                left: -9999px !important;
                top: -9999px !important;
                z-index: -9999 !important;
            }
        `;
        document.head.appendChild(styleElement);
        
        // 禁用调试面板相关函数
        window.addDebugToggleButton = function() {
            console.log('[调试禁用] 调试按钮功能已禁用');
            return false;
        };
        
        window.debugTimerForm = function() {
            console.log('[调试禁用] 调试面板功能已禁用');
            return false;
        };
        
        // 设置DOM加载后的处理
        document.addEventListener('DOMContentLoaded', function() {
            // 立即移除所有调试元素
            setTimeout(function removeDebugElements() {
                const selectors = [
                    '#timerDebugPanel', '#debugToggle', '.debug-panel', '.debug-toggle',
                    '[id^="debug-"]', '[class^="debug-"]'
                ];
                
                selectors.forEach(function(selector) {
                    document.querySelectorAll(selector).forEach(function(element) {
                        if (element && element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    });
                });
                
                // 禁用emergencyFunctions中的调试功能
                if (window.emergencyFunctions) {
                    window.emergencyFunctions.debugTimerForm = function() {
                        console.log('[调试禁用] 紧急函数中的调试面板功能已禁用');
                        return false;
                    };
                }
            }, 500);
            
            // 定期检查并移除调试元素
            setInterval(function() {
                document.querySelectorAll('#timerDebugPanel, #debugToggle, .debug-panel, .debug-toggle').forEach(function(element) {
                    if (element && element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                });
            }, 2000);
        });
    })();
    </script>
    
    <!-- 添加流式处理器脚本 -->
    <script src="/js/streaming-handler.js"></script>
    
    <!-- 添加全局音频控制函数 -->
    <script>
        // 全局音频控制函数
        window.globalStopAllAudio = function() {
            // 添加检查，确保StreamingHandler存在
            if (window.StreamingHandler && typeof window.StreamingHandler.stopAllAudio === 'function') {
                window.StreamingHandler.stopAllAudio();
            } else {
                console.warn('StreamingHandler不可用，使用备用方法停止音频');
                // 备用方法：停止所有<audio>元素
                document.querySelectorAll('audio').forEach(audio => {
                    if (!audio.paused) {
                        audio.pause();
                        audio.currentTime = 0;
                    }
                });
            }
        };
    </script>
    
    <!-- 确保StreamingHandler对象总是存在 -->
    <script>
        // 确保StreamingHandler对象总是存在并有基本功能
        window.StreamingHandler = window.StreamingHandler || {
            stopAllAudio: function() {
                console.log('备用的stopAllAudio方法被调用');
                // 停止所有<audio>元素
                document.querySelectorAll('audio').forEach(audio => {
                    if (!audio.paused) {
                        audio.pause();
                        audio.currentTime = 0;
                    }
                });
            },
            handleStreamingResponse: function() {
                console.log('备用的handleStreamingResponse方法被调用');
            },
            stopStreamingResponse: function() {
                console.log('备用的stopStreamingResponse方法被调用');
            },
            intelligentTextSegmentation: function(text) {
                console.log('备用的intelligentTextSegmentation方法被调用');
                return [text];
            },
            addAudioToQueue: function() {
                console.log('备用的addAudioToQueue方法被调用');
            },
            handleTTSResponse: function() {
                console.log('备用的handleTTSResponse方法被调用');
            }
        };
        
        // 添加会话ID检查和更新函数
        if (typeof checkAndUpdateConversationId === 'undefined') {
            window.checkAndUpdateConversationId = function() {
                // 检查是否已有会话ID
                if (conversationId && conversationId.trim() !== '') {
                    console.log('使用现有会话ID:', conversationId);
                    return conversationId;
                }
                
                // 生成新的会话ID
                const newConversationId = 'session_' + Date.now();
                console.log('生成新的会话ID:', newConversationId);
                
                // 更新全局变量和localStorage
                conversationId = newConversationId;
                localStorage.setItem('lastSessionId', conversationId);
                localStorage.setItem('lastSessionDate', getCurrentDateString());
                
                return conversationId;
            };
        }
        
        // 获取当前日期字符串函数
        if (typeof getCurrentDateString === 'undefined') {
            window.getCurrentDateString = function() {
                const now = new Date();
                return `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            };
        }
        
        // 生成用户ID函数
        if (typeof generateUserId === 'undefined') {
            window.generateUserId = function() {
                return 'user_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
            };
        }
        
        // 添加消息函数
        if (typeof addMessage === 'undefined') {
            window.addMessage = function(text, sender) {
                // 创建消息元素
                const messageElement = document.createElement('div');
                const messageId = 'message-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
                messageElement.id = messageId;
                messageElement.className = `message ${sender}-message`;
                
                // 创建消息文本元素
                const textElement = document.createElement('div');
                textElement.className = 'message-text';
                textElement.textContent = text;
                messageElement.appendChild(textElement);
                
                // 将消息添加到聊天窗口
                chatMessages.appendChild(messageElement);
                
                // 滚动到最新消息
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.log(`添加新消息，自动生成ID: ${messageId}, 发送者: ${sender}, 内容: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
                
                return messageElement;
            };
        }
        
        // 添加handleCommandMessage函数的空实现
        if (typeof handleCommandMessage === 'undefined') {
            window.handleCommandMessage = function(message) {
                // 简单的命令检查逻辑
                console.log('检查是否是命令消息:', message);
                
                // 如果是以斜杠开头的命令，如"/help"
                if (message && message.trim().startsWith('/')) {
                    const command = message.trim().substring(1).toLowerCase();
                    console.log('检测到命令:', command);
                    
                    // 处理一些基本命令
                    switch (command) {
                        case 'help':
                            console.log('显示帮助信息');
                            return true;
                        case 'clear':
                            console.log('清除聊天记录');
                            return true;
                        default:
                            console.log('未知命令:', command);
                            return false;
                    }
                }
                
                // 不是命令，返回false继续正常处理
                return false;
            };
        }
        
        // 网络状态处理函数
        if (typeof handleWebSocketClosed === 'undefined') {
            window.handleWebSocketClosed = function() {
                console.log('WebSocket连接已关闭，尝试重新连接...');
                // 添加重连逻辑
                setTimeout(function() {
                    console.log('尝试重新建立WebSocket连接');
                    connectWebSocket();
                }, 3000);
            };
        }
        
        // 处理WebSocket消息的函数
        if (typeof handleWebSocketMessage === 'undefined') {
            window.handleWebSocketMessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('收到WebSocket消息:', data);
                    
                    // 根据消息类型处理
                    switch (data.type) {
                        case 'chat_response':
                            // 处理聊天响应
                            typingIndicator.style.display = 'none';
                            const msgElement = addMessage(data.message, 'bot');
                            
                            // 自动语音合成
                            if (window.autoSpeakEnabled) {
                                requestSpeech(data.message);
                            }
                            
                            // 保存会话ID
                            if (data.conversation_id) {
                                conversationId = data.conversation_id;
                                localStorage.setItem('lastSessionId', conversationId);
                                localStorage.setItem('lastSessionDate', getCurrentDateString());
                                console.log('会话ID已更新:', conversationId);
                            }
                            break;
                            
                        case 'tts_response':
                            // 处理TTS响应
                            if (window.StreamingHandler && typeof window.StreamingHandler.handleTTSResponse === 'function') {
                                window.StreamingHandler.handleTTSResponse(data);
                            } else {
                                // 备用处理
                                if (data.audio_url) {
                                    playAudio(data.audio_url);
                                }
                            }
                            break;
                            
                        case 'tts_segment_update':
                            // 处理TTS片段更新
                            if (window.StreamingHandler && typeof window.StreamingHandler.handleTTSResponse === 'function') {
                                window.StreamingHandler.handleTTSResponse(data);
                            }
                            break;
                            
                        case 'error':
                            // 处理错误
                            console.error('服务器错误:', data.message);
                            typingIndicator.style.display = 'none';
                            addMessage(`错误: ${data.message}`, 'bot');
                            break;
                        case 'alarm':
                            console.log('[Chat告警] 收到告警消息:', data);
                            handleAlarmMessage(data.data);
                            break;
                        case 'alarm_cleared':
                            console.log('[Chat告警] 收到告警解除消息:', data);
                            handleAlarmClearedMessage(data.data);
                            break;
                        case 'single_point_alarm':
                            console.log('[Chat告警] 收到单点报警消息:', data);
                            handleAlarmMessage(data.data);
                            break;
                        case 'single_point_alarm_cleared':
                            console.log('[Chat告警] 收到单点报警解除消息:', data);
                            handleAlarmClearedMessage(data.data);
                            break;
                        case 'multi_condition_alarm':
                            console.log('[Chat告警] 收到多条件告警消息:', data);
                            handleMultiConditionAlarmMessage(data.data);
                            break;
                        case 'multi_condition_alarm_cleared':
                            console.log('[Chat告警] 收到多条件告警解除消息:', data);
                            handleMultiConditionAlarmClearedMessage(data.data);
                            break;
                    }
                } catch (error) {
                    console.error('解析WebSocket消息失败:', error);
                }
            };
        }
        
        // WebSocket连接函数
        if (typeof connectWebSocket === 'undefined') {
            window.connectWebSocket = function() {
                // 检查现有连接是否存在并打开
                if (ws && ws.readyState === WebSocket.OPEN) {
                    console.log('WebSocket连接已存在且打开');
                    return;
                }
                
                // 创建新的WebSocket连接
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                console.log('正在建立WebSocket连接:', wsUrl);
                ws = new WebSocket(wsUrl);
                
                // 连接打开事件
                ws.addEventListener('open', function() {
                    console.log('WebSocket连接已建立');
                    
                    // 发送客户端信息
                    ws.send(JSON.stringify({
                        type: 'client_info',
                        userId: userId,
                        conversationId: conversationId
                    }));
                });
                
                // 消息接收事件
                ws.addEventListener('message', window.handleWebSocketMessage);
                
                // 连接关闭事件
                ws.addEventListener('close', function() {
                    console.log('WebSocket连接已关闭');
                    window.handleWebSocketClosed();
                });
                
                // 连接错误事件
                ws.addEventListener('error', function(error) {
                    console.error('WebSocket错误:', error);
                });
            };
        }
    </script>
    
    <!-- 确保processNextAudio函数存在，避免未定义错误 -->
</head>
<body>
    <!-- 导航栏 -->
    <div class="nav-bar">
        <div class="nav-links">
            <a href="/">首页</a>
            <a href="/chat.html">聊天</a>
        </div>
        <div class="chat-actions">
            <button id="newChatButton" class="action-button">新对话</button>
            <div class="dropdown">
                <button id="historyButton" class="action-button">历史对话</button>
                <div id="historyDropdown" class="dropdown-content">
                    <!-- 历史对话将在这里显示 -->
                    <div class="no-history">暂无历史对话</div>
                </div>
            </div>
        </div>
        <div>
            <button class="console-button" onclick="window.location.href='/modbus.html'">控制台</button>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>智能聊天</h1>
            <button id="toggleSettings" class="settings-toggle">计时器设置</button>
        </div>
        
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages">
                <!-- 聊天消息将在这里显示 -->
            </div>
            
            <div class="typing-indicator" id="typingIndicator">
                <span></span>
                <span></span>
                <span></span>
            </div>
            
            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="输入您的问题..." autocomplete="off">
                <button id="sendButton">发送</button>
                <button id="recordButton" class="record-button">录音</button>
            </div>
            
            <div class="recording-status" id="recordingStatus">正在录音...</div>
            
            <div class="file-upload">
                <input type="file" id="fileInput" accept="image/*" multiple>
                <label for="fileInput">上传图片</label>
                <div id="fileStatus" class="file-status"></div>
            </div>
            
            <div class="file-preview" id="filePreview">
                <!-- 文件预览将在这里显示 -->
            </div>
        </div>
    </div>
    
    <!-- 计时器历史记录模态框 -->
    <div id="timerHistoryModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>计时器历史记录</h2>
            <div id="timerHistoryContent">
                <table class="timer-history-table">
                    <thead>
                        <tr>
                            <th>标题</th>
                            <th>消息</th>
                            <th>完成时间</th>
                        </tr>
                    </thead>
                    <tbody id="timerHistoryTableBody">
                        <!-- 计时器历史记录将在这里显示 -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- 添加设置面板 -->
    <!-- 
    <div id="timerSettings" class="settings-panel" style="display: none;">
        <h3>计时器提醒设置</h3>
        <div class="settings-row">
            <label for="reminderRepeatCount">提醒重复次数:</label>
            <input type="number" id="reminderRepeatCount" min="1" max="10" value="2">
        </div>
        <div class="settings-row">
            <label for="reminderInterval">重复间隔时间(秒):</label>
            <input type="number" id="reminderInterval" min="1" max="60" value="5">
        </div>
        <div class="settings-row">
            <label for="autoStopReminders">无人应答时停止提醒:</label>
            <select id="autoStopReminders">
                <option value="true" selected>是</option>
                <option value="false">否</option>
            </select>
        </div>
        <div class="settings-info">
            当计时器结束后，系统会播放提示音和消息，按照上述设置进行重复提醒，直到用户输入消息或达到最大重复次数。
        </div>
    </div>
    -->
    
    <!-- 计时器设置模态窗口 -->
    <div id="timerSettingsModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeTimerSettings">&times;</span>
            <h2>计时器音频设置</h2>
            <div class="settings-container">
                <div class="settings-section">
                    <h3>提醒重复设置</h3>
                    <div class="settings-row">
                        <label for="reminderRepeatCount">提醒重复次数:</label>
                        <input type="number" id="reminderRepeatCount" min="1" max="10" value="2">
                    </div>
                    <div class="settings-row">
                        <label for="reminderInterval">重复间隔时间(秒):</label>
                        <input type="number" id="reminderInterval" min="1" max="60" value="5">
                    </div>
                    <div class="settings-row">
                        <label for="autoStopReminders">无人应答时停止提醒:</label>
                        <select id="autoStopReminders">
                            <option value="true" selected>是</option>
                            <option value="false">否</option>
                        </select>
                    </div>
                    <div class="settings-info">
                        当计时器结束后，系统会播放提示音和消息，按照上述设置进行重复提醒，直到用户输入消息或达到最大重复次数。
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3>音频循环设置</h3>
                    <div class="settings-row">
                        <label for="audioLoopCount">音频循环次数:</label>
                        <input type="number" id="audioLoopCount" min="1" max="5" value="1">
                    </div>
                    <div class="settings-row">
                        <label for="audioLoopInterval">音频循环间隔(毫秒):</label>
                        <input type="number" id="audioLoopInterval" min="0" max="5000" step="100" value="500">
                    </div>
                    <div class="settings-info">
                        音频循环设置控制单次提醒中的循环播放次数和间隔，增强提醒效果。
                    </div>
                </div>
                
                <div class="settings-buttons">
                    <button id="saveTimerSettings" class="save-btn">保存设置</button>
                    <button id="testAudioLoop" class="test-btn">测试循环播放</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // DOM元素
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const typingIndicator = document.getElementById('typingIndicator');
        const fileInput = document.getElementById('fileInput');
        const fileStatus = document.getElementById('fileStatus');
        const filePreview = document.getElementById('filePreview');
        const recordButton = document.getElementById('recordButton');
        
        // 全局变量
        let conversationId = localStorage.getItem('lastSessionId') || '';
        let userId = localStorage.getItem('userId') || generateUserId();
        let ws = null;
        let sessionStartTime = Date.now();
        let mediaSource = null;
        let sourceBuffer = null;
        let audioElement = null;
        let audioChunks = [];
        let audioQueue = []; // 全局声明audioQueue变量
        let pendingAudioUrls = [];
        let isAudioPlaying = false;
        let isProcessingAudio = false;
        let audioInitialized = false;
        let processedUrls = new Set();
        let deletedFiles = new Set();
        let totalAudioReceived = 0;
        let totalAudioPlayed = 0;
        let currentPlayingAudio = null;
        let currentTaskId = null; // 添加当前任务ID变量
        let isStreamingResponse = false; // 标记是否正在接收流式响应
        let uploadedFiles = []; // 添加上传文件数组
        let botMessage = ''; // 添加机器人消息变量，用于累加显示消息内容
        let currentConversationRoundId = ''; // 当前对话轮次ID，用于过滤音频
        
        // 录音相关变量
        let isRecording = false;
        let mediaRecorder = null;
        let audioStream = null;
        let audioTracks = null;
        let recordingStartTime = 0;
        
        // 添加用户交互事件，解锁音频播放
        document.addEventListener('click', unlockAudio);
        document.addEventListener('keydown', unlockAudio);
        
        // 初始化页面
        document.addEventListener('DOMContentLoaded', () => {
            console.log('页面已加载，初始化聊天界面');
            
            // 初始化并获取用户标识
            userId = localStorage.getItem('userId');
            if (!userId) {
                userId = 'user-' + Date.now();
                localStorage.setItem('userId', userId);
                console.log(`生成新的用户标识: ${userId}`);
            } else {
                console.log(`使用已保存的用户标识: ${userId}`);
            }
            
            // 尝试从localStorage恢复临时消息ID
            window.tempPromptMessageId = localStorage.getItem('lastTempPromptId');
            if (window.tempPromptMessageId) {
                console.log(`从localStorage恢复临时消息ID: ${window.tempPromptMessageId}`);
                // 检查对应的消息元素是否存在
                if (!document.getElementById(window.tempPromptMessageId)) {
                    console.log('未找到对应临时消息元素，清除ID');
                    window.tempPromptMessageId = null;
                    localStorage.removeItem('lastTempPromptId');
                }
            }
            
            // 初始化语音识别处理状态
            window.isProcessingAjaxRecognition = false;
            
            // 尝试从localStorage恢复会话ID
            const savedSessionId = localStorage.getItem('lastSessionId');
            const savedSessionDate = localStorage.getItem('lastSessionDate');
            const currentDate = getCurrentDateString();
            
            if (savedSessionId && savedSessionDate === currentDate) {
                // 如果有保存的会话ID，且是今天的，则使用它
                conversationId = savedSessionId;
                console.log(`从localStorage恢复会话ID: ${conversationId}`);
            } else {
                // 否则初始化/检查会话ID
                checkAndUpdateConversationId();
                console.log('当前会话ID:', conversationId);
            }
            
            // 添加事件监听器
            sendButton.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // 阻止默认的回车换行
                    sendMessage();
                }
            });
            fileInput.addEventListener('change', handleFileUpload);
            
            // 初始化音频相关变量
            mediaSource = null;
            sourceBuffer = null;
            audioElement = null;
            audioChunks = [];
            audioQueue = [];
            pendingAudioUrls = [];
            isAudioPlaying = false;
            isProcessingAudio = false;
            audioInitialized = false;
            processedUrls = new Set();
            deletedFiles = new Set();
            totalAudioReceived = 0;
            totalAudioPlayed = 0;
            currentPlayingAudio = null;
            console.log('音频变量已初始化');
            
            // 添加欢迎消息
            addMessage('您好！我是智能助手，有什么可以帮您的吗？', 'bot');
            
            // 清理旧会话的音频文件
            cleanupOldAudioFiles(sessionStartTime);
            
            // 绑定重置按钮事件
            const resetButton = document.getElementById('reset-button');
            if (resetButton) {
                resetButton.addEventListener('click', resetConversation);
            } else {
                console.warn('重置按钮元素未找到，跳过事件绑定');
            }
            
            // 初始化录音功能
            initRecordingFeature();
            
            // 建立WebSocket连接
            if (typeof connectWebSocket === 'function') {
                console.log('开始建立WebSocket连接');
                connectWebSocket();
            } else {
                console.error('connectWebSocket函数未定义，无法建立WebSocket连接');
            }
            
            // 初始化计时器历史记录功能
            initTimerHistory();
            
            // 初始化设置面板
            initSettingsPanel();
        });
        
        // 连接WebSocket
        function connectWebSocket() {
            const wsUrl = `ws://${window.location.host}`;
            
            console.log(`尝试连接WebSocket: ${wsUrl}`);
            ws = new WebSocket(wsUrl);
            
            // 添加变量跟踪消息的版本和状态
            window.messageVersions = new Map(); // 用于跟踪每个消息的版本号
            window.lastSynthesizedVersion = new Map(); // 用于跟踪每个消息最后一次语音合成的版本号
            window.pendingSynthesis = false; // 标记是否有语音合成正在进行中
            
            // 语音合成和播放相关函数
            function requestSpeech(text, isSegment = false, timestamp = null, roundId = null) {
                if (!text || !autoSpeakEnabled) return;
                
                // 获取或使用当前对话轮次ID
                const currentRoundId = roundId || window.currentConversationRoundId || ('round_' + Date.now());
                
                // 文本截断以便显示在日志中
                const textForLog = text.length > 50 ? text.substring(0, 50) + '...' : text;
                console.log('请求语音合成:', textForLog, timestamp ? `时间戳: ${timestamp}` : '', `轮次ID: ${currentRoundId}`);
                
                // 如果不是分段合成，先停止所有音频
                if (!isSegment) {
                    window.StreamingHandler.stopAllAudio();
                }
                
                return new Promise((resolve, reject) => {
                    // 添加重试机制
                    const maxRetries = 3;
                    let retryCount = 0;
                    
                    function attemptSynthesis() {
                        // 生成包含轮次ID的音频文件名
                        const audioFilenamePrefix = timestamp ? `tts_${timestamp}_round_${currentRoundId}` : `tts_${Date.now()}_round_${currentRoundId}`;
                        
                        // 调用TTS API
                        fetch('/api/tts', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                text: text,
                                voice: window.currentVoice || 'longxiaochun',
                                timestamp: timestamp || Date.now(), // 传递时间戳
                                roundId: currentRoundId, // 传递轮次ID (修改为驼峰命名)
                                filename_prefix: audioFilenamePrefix // 指定文件名前缀
                            })
                        })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`服务器返回错误状态: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.success && data.audioUrl) {
                                // 处理成功响应
                                console.log(`语音合成成功，音频URL: ${data.audioUrl}, 轮次ID: ${currentRoundId}`);
                                
                                // 使用StreamingHandler处理音频队列，传递时间戳和轮次ID信息
                                window.StreamingHandler.addAudioToQueue(data.audioUrl, text, timestamp, currentRoundId);
                                
                                // 返回成功
                                resolve(data);
                            } else {
                                console.error('语音合成失败:', data.error || '未知错误');
                                if (retryCount < maxRetries) {
                                    retryCount++;
                                    console.log(`语音合成重试 (${retryCount}/${maxRetries})...`);
                                    setTimeout(attemptSynthesis, 1000); // 1秒后重试
                                } else {
                                    reject(new Error(data.error || '语音合成失败'));
                                }
                            }
                        })
                        .catch(error => {
                            console.error('语音合成请求失败:', error);
                            if (retryCount < maxRetries) {
                                retryCount++;
                                console.log(`语音合成重试 (${retryCount}/${maxRetries})...`);
                                setTimeout(attemptSynthesis, 1000); // 1秒后重试
                            } else {
                                reject(error);
                            }
                        });
                    }
                    
                    // 开始首次尝试
                    attemptSynthesis();
                });
            }

            // 停止所有音频播放
            function stopAllAudio() {
                if (window.StreamingHandler && typeof window.StreamingHandler.stopAllAudio === 'function') {
                    window.StreamingHandler.stopAllAudio();
                } else {
                    // 备用方法：停止所有<audio>元素
                    document.querySelectorAll('audio').forEach(audio => {
                        if (!audio.paused) {
                            audio.pause();
                            audio.currentTime = 0;
                        }
                    });
                }
            }

            // 切换自动语音播放
            window.toggleAutoSpeak = function() {
                window.autoSpeakEnabled = !window.autoSpeakEnabled;
                console.log('自动语音播放已' + (window.autoSpeakEnabled ? '启用' : '禁用'));
                return window.autoSpeakEnabled;
            }

            // 切换语音
            window.changeVoice = function(voice) {
                window.currentVoice = voice;
                console.log('已切换到语音:', voice);
            }
            
            ws.onopen = () => {
                console.log('WebSocket连接已建立');
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('收到WebSocket消息类型:', data.type);
                    
                    // 处理语音识别结果
                    if (data.type === 'asr_result') {
                        // 如果AJAX请求正在处理，跳过WebSocket更新
                        if (window.isProcessingAjaxRecognition !== true) {
                            updateRecognitionText(data);
                        } else {
                            console.log('AJAX识别请求正在处理中，跳过WebSocket asr_result更新');
                        }
                    }
                    // 处理语音识别完成事件
                    else if (data.type === 'asr_complete') {
                        // 如果AJAX请求正在处理，跳过WebSocket更新
                        if (window.isProcessingAjaxRecognition !== true) {
                            handleRecognitionComplete(data);
                        } else {
                            console.log('AJAX识别请求正在处理中，跳过WebSocket asr_complete更新');
                        }
                    }
                    // 处理计时器完成事件
                    else if (data.type === 'timer_completed') {
                        // 计时器完成
                        handleTimerCompleted(data.timer);
                    }
                    // 添加对聊天响应的处理
                    else if (data.type === 'chat_response') {
                        // 隐藏输入指示器
                        typingIndicator.style.display = 'none';
                        
                        if (data.success) {
                            // 如果是临时提示，保存消息ID以便后续更新
                            if (data.isTempPrompt) {
                                console.log('收到临时提示:', data.answer);
                                // 临时提示使用特殊ID，便于后续更新
                                window.tempPromptMessageId = `message-${Date.now()}-temp`;
                                // 添加机器人消息，带有临时标记
                                addMessage(data.answer, 'bot', window.tempPromptMessageId, true);
                                
                                // 保存ID到localStorage，以防页面刷新
                                try {
                                    localStorage.setItem('lastTempPromptId', window.tempPromptMessageId);
                                    console.log('临时消息ID已保存到localStorage:', window.tempPromptMessageId);
                                } catch (e) {
                                    console.error('保存临时消息ID失败:', e);
                                }
                            } else {
                                // 普通回复，直接添加
                                console.log('收到正常回复:', data.answer);
                                const msgElement = addMessage(data.answer, 'bot');
                                
                                // 保存最新的非临时消息ID，以便后续可能的更新
                                window.lastBotMessageId = msgElement.id;
                                console.log('保存最新非临时消息ID:', window.lastBotMessageId);
                                
                                // 初始化版本号
                                window.messageVersions.set(msgElement.id, 1);
                            }
                            
                            // 消息分类标识（可选：如果需要在UI上展示分类）
                            if (data.messageType) {
                                console.log(`消息分类: ${data.messageType}`);
                            }
                            
                            // 如果启用了自动语音
                            if (window.autoSpeakEnabled && !data.isTempPrompt && !window.pendingSynthesis) {
                                // 请求语音合成（临时提示不进行语音合成）
                                console.log('收到新消息，开始语音合成...');
                                requestSpeech(data.answer, window.lastBotMessageId);
                            } else if (window.pendingSynthesis) {
                                console.log('已有语音合成在进行中，暂时跳过本次请求');
                            }
                        } else {
                            // 处理错误
                            addMessage(data.error || '抱歉，处理您的请求时出错了。', 'bot');
                        }
                        
                        // 滚动到底部
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                    // 处理聊天响应更新（更新临时提示为真实响应）
                    else if (data.type === 'chat_response_update') {
                        console.log('收到聊天响应更新:', data.answer.substring(0, 50) + '...');
                        
                        if (data.success) {
                            // 判断是否为最终完整响应
                            const isCompleteResponse = data.isComplete === true;
                            console.log('是否为完整响应:', isCompleteResponse);
                            
                            // 确保我们有一个有效的消息ID，即使是之前没有设置的
                            if (!window.tempPromptMessageId) {
                                console.log('未找到临时消息ID，可能是首次更新或ID已被清除');
                                // 寻找最后一个机器人消息作为更新目标
                                const botMessages = document.querySelectorAll('.bot-message');
                                if (botMessages.length > 0) {
                                    const lastBotMessage = botMessages[botMessages.length - 1];
                                    const messageId = lastBotMessage.getAttribute('data-message-id');
                                    window.tempPromptMessageId = messageId;
                                    console.log('找到最后一个机器人消息ID:', messageId);
                                }
                            }
                            
                            // 获取消息ID
                            const messageId = window.tempPromptMessageId || window.lastBotMessageId;
                            
                            if (messageId) {
                                // 更新版本号
                                const currentVersion = window.messageVersions.get(messageId) || 0;
                                const newVersion = currentVersion + 1;
                                window.messageVersions.set(messageId, newVersion);
                                
                                // 更新消息内容
                                console.log('更新消息内容, ID:', messageId);
                                updateMessage(messageId, data.answer);
                                console.log('消息更新完成，内容长度:', data.answer.length);
                                
                                // 如果是完整响应且启用了自动语音
                                if (isCompleteResponse && window.autoSpeakEnabled) {
                                    // 使用流式文本分段
                                    const lastSynthesizedVersion = window.lastSynthesizedVersion.get(messageId) || 0;
                                    
                                    // 只有当版本更新时才处理
                                    if (newVersion > lastSynthesizedVersion) {
                                        console.log('收到完整响应，处理流式语音合成...');
                                        // 更新语音合成版本标记
                                        window.lastSynthesizedVersion.set(messageId, newVersion);
                                        
                                        // 分段处理文本
                                        const segments = window.StreamingHandler.intelligentTextSegmentation(data.answer);
                                        console.log(`文本已分段为${segments.length}个片段，开始语音合成`);
                                        
                                        // 遍历所有分段，依次添加到合成队列
                                        // 使用当前时间作为基准，确保时间戳递增有序
                                        const baseTimestamp = Date.now();
                                        
                                        // 先创建所有时间戳和对应关系，确保顺序正确
                                        const segmentWithTimestamps = segments.map((segment, index) => {
                                            // 预处理文本，移除多余空白
                                            const cleanText = segment.replace(/\s+/g, ' ').trim();
                                            
                                            // 为防止所有片段都有相同的时间戳，添加递增值
                                            // 但间隔足够小，让内容排序优先级更高
                                            return {
                                                text: cleanText,
                                                timestamp: baseTimestamp + index,
                                                // 标记原始顺序，用于调试
                                                originalIndex: index
                                            };
                                        });
                                        
                                        // 记录分段信息用于调试
                                        console.log("原始文本分段:");
                                        segmentWithTimestamps.forEach((item, index) => {
                                            console.log(`#${index+1} [原始索引:${item.originalIndex}]: "${item.text.substring(0, 30)}..."`);
                                        });
                                        
                                        // 现在按顺序请求合成，使用较小的延迟避免同时发送请求
                                        let successCount = 0;
                                        const totalSegments = segmentWithTimestamps.length;
                                        
                                        // 一次只发送一个请求，等待成功后再发送下一个
                                        // 这样保证了服务器按接收顺序处理，避免乱序
                                        function processNextSegment(index) {
                                            if (index >= totalSegments) {
                                                console.log(`所有${successCount}/${totalSegments}个片段请求完成`);
                                                return;
                                            }
                                            
                                            const item = segmentWithTimestamps[index];
                                            console.log(`请求片段 #${index+1}/${totalSegments}: "${item.text.substring(0, 30)}..."`);
                                            
                                            // 使用当前对话轮次ID
                                            requestSpeech(item.text, true, item.timestamp, window.currentConversationRoundId)
                                                .then(() => {
                                                    successCount++;
                                                    // 成功后处理下一个
                                                    setTimeout(() => processNextSegment(index + 1), 50);
                                                })
                                                .catch(error => {
                                                    console.error(`片段#${index+1}语音合成失败:`, error);
                                                    // 即使失败也继续处理下一个
                                                    setTimeout(() => processNextSegment(index + 1), 50);
                                                });
                                        }
                                        
                                        // 开始处理第一个片段
                                        processNextSegment(0);
                                    } else {
                                        console.log(`跳过版本${newVersion}的语音合成，已处理过版本${lastSynthesizedVersion}`);
                                    }
                                }
                            } else {
                                console.error('未找到有效的消息ID，无法更新消息');
                            }
                        } else {
                            console.error('聊天响应更新失败:', data.error);
                        }
                    }
                    // 处理TTS响应
                    else if (data.type === 'tts_response') {
                        if (data.success && data.audioUrl) {
                            // 使用StreamingHandler处理TTS响应
                            window.StreamingHandler.handleTTSResponse({
                                success: true,
                                audioUrl: data.audioUrl,
                                text: data.text || ""
                            });
                        } else {
                            console.error('TTS处理失败:', data.error || '未知错误');
                        }
                    }
                    // 处理语音段落更新
                    else if (data.type === 'tts_segment_update') {
                        console.log(`收到语音段落更新: 第${data.task.index}段, 状态: ${data.task.status}, 轮次ID: ${data.task.roundId || '未指定'}`);
                        
                        if (data.task.status === 'completed' && data.task.audioUrl) {
                            // 将音频添加到播放队列，传递轮次ID
                            window.StreamingHandler.addAudioToQueue(data.task.audioUrl, data.task.text, null, data.task.roundId);
                            console.log(`语音段落${data.task.index}已添加到播放队列, 轮次ID: ${data.task.roundId || '未指定'}`);
                        } else if (data.task.status === 'failed') {
                            console.error(`语音段落${data.task.index}合成失败:`, data.task.error);
                        }
                    }
                    // 处理告警消息
                    else if (data.type === 'alarm') {
                        console.log('[Chat告警] 收到告警消息:', data);
                        handleAlarmMessage(data.data);
                    }
                    // 处理告警解除消息
                    else if (data.type === 'alarm_cleared') {
                        console.log('[Chat告警] 收到告警解除消息:', data);
                        handleAlarmClearedMessage(data.data);
                    }
                    // 处理单点报警消息
                    else if (data.type === 'single_point_alarm') {
                        console.log('[Chat告警] 收到单点报警消息:', data);
                        handleAlarmMessage(data.data);
                    }
                    // 处理单点报警解除消息
                    else if (data.type === 'single_point_alarm_cleared') {
                        console.log('[Chat告警] 收到单点报警解除消息:', data);
                        handleAlarmClearedMessage(data.data);
                    }
                    // 处理多条件告警消息
                    else if (data.type === 'multi_condition_alarm') {
                        console.log('[Chat告警] 收到多条件告警消息:', data);
                        handleMultiConditionAlarmMessage(data.data);
                    }
                    // 处理多条件告警解除消息
                    else if (data.type === 'multi_condition_alarm_cleared') {
                        console.log('[Chat告警] 收到多条件告警解除消息:', data);
                        handleMultiConditionAlarmClearedMessage(data.data);
                    }
                } catch (error) {
                    console.error('解析WebSocket消息失败:', error);
                }
            };
            
            ws.onclose = () => {
                console.log('WebSocket连接已关闭，尝试重连...');
                setTimeout(connectWebSocket, 3000);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket错误:', error);
            };
        }
        
        // 初始化录音功能
        function initRecordingFeature() {
            console.log('初始化录音功能');
            
            // 检查浏览器是否支持getUserMedia
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('浏览器不支持录音功能');
                recordButton.style.display = 'none';
                return;
            }
            
            // 更新录音按钮状态 - 增强版本
            function updateRecordingButtonState(state) {
                console.log(`更新录音按钮状态: ${state}`);
                
                // 移除所有可能的类
                recordButton.classList.remove('recording', 'processing', 'error');
                
                // 根据状态设置相应的类和属性
                switch (state) {
                    case 'idle':
                        // 空闲状态
                        recordButton.textContent = '录音';
                        recordButton.disabled = false;
                        recordButton.title = '开始录音';
                        
                        // 隐藏状态提示
                        if (recordingStatus.textContent === '正在录音...' || 
                            recordingStatus.textContent.startsWith('正在录音... ')) {
                            recordingStatus.style.display = 'none';
                        }
                        break;
                        
                    case 'recording':
                        // 录音中状态
                        recordButton.classList.add('recording');
                        recordButton.textContent = '停止';
                        recordButton.disabled = false;
                        recordButton.title = '停止录音';
                        
                        // 显示录音状态
                        recordingStatus.style.display = 'block';
                        recordingStatus.textContent = '正在录音...';
                        break;
                        
                    case 'processing':
                        // 处理中状态
                        recordButton.classList.add('processing');
                        recordButton.textContent = '处理中...';
                        recordButton.disabled = true;
                        recordButton.title = '处理中...';
                        
                        // 显示处理状态
                        recordingStatus.style.display = 'block';
                        recordingStatus.textContent = '正在处理录音...';
                        break;
                        
                    case 'error':
                        // 错误状态
                        recordButton.classList.add('error');
                        recordButton.textContent = '重试';
                        recordButton.disabled = false;
                        recordButton.title = '录音出错，点击重试';
                        
                        // 如果没有特定错误消息，显示通用消息
                        if (recordingStatus.textContent === '') {
                            recordingStatus.textContent = '录音出错，请重试';
                        }
                        
                        recordingStatus.style.display = 'block';
                        break;
                    
                    default:
                        console.error(`未知的按钮状态: ${state}`);
                        recordButton.textContent = '录音';
                        recordButton.disabled = false;
                        break;
                }
                
                // 日志当前状态
                console.log(`按钮状态已更新为: ${state}, 禁用状态: ${recordButton.disabled}, 文本: ${recordButton.textContent}`);
            }
            
            // 显示录音状态信息
            function showStatus(type, message) {
                console.log(`状态更新: [${type}] ${message}`);
                
                if (!recordingStatus) {
                    console.error('录音状态元素未找到');
                    return;
                }
                
                recordingStatus.textContent = message;
                recordingStatus.style.display = 'block';
                
                // 根据状态类型设置不同的样式
                recordingStatus.className = 'recording-status';
                switch (type) {
                    case 'error':
                        recordingStatus.classList.add('status-error');
                        break;
                    case 'success':
                        recordingStatus.classList.add('status-success');
                        // 成功状态1.5秒后自动隐藏
                        setTimeout(() => {
                            if (recordingStatus.classList.contains('status-success')) {
                                recordingStatus.style.display = 'none';
                            }
                        }, 1500);
                        break;
                    case 'info':
                        recordingStatus.classList.add('status-info');
                        break;
                    case 'warning':
                        recordingStatus.classList.add('status-warning');
                        break;
                    case 'processing':
                        recordingStatus.classList.add('status-processing');
                        break;
                    default:
                        break;
                }
            }
            
            // 添加录音按钮事件 - 增强版本
            recordButton.addEventListener('click', (event) => {
                console.log('录音按钮被点击，当前录音状态:', isRecording ? '录音中' : '未录音');
                
                // 阻止事件冒泡和默认行为，避免多次触发
                event.preventDefault();
                event.stopPropagation();
                
                // 录音按钮在处理中时禁用点击
                if (recordButton.disabled) {
                    console.log('录音按钮当前已禁用，忽略点击');
                    return;
                }
                
                if (isRecording) {
                    console.log('尝试停止录音...');
                    // 立即更新UI状态，防止用户重复点击
                    recordButton.disabled = true;
                    updateRecordingButtonState('processing');
                    
                    // 使用setTimeout确保状态更新后再停止录音
                    setTimeout(() => {
                        stopRecording();
                    }, 10);
                } else {
                    console.log('尝试开始录音...');
                    startRecording();
                }
            });
            
            // 开始录音 - 只保留完整录音识别版本
            async function startRecording() {
                console.log('开始录音（完整识别模式）');
                
                // 更新录音按钮状态
                updateRecordingButtonState('recording');
                
                try {
                    // 重置音频块数组
                    audioChunks = [];
                    
                    // 设置录音状态为true
                    isRecording = true;
                    
                    // 获取媒体流
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 16000,
                            channelCount: 1 // 确保单声道
                        }
                    });
                    
                    console.log('获取到麦克风权限');
                    
                    // 保存媒体流和轨道
                    audioStream = stream;
                    audioTracks = stream.getAudioTracks();
                    
                    // 创建MediaRecorder实例，明确指定mime类型和比特率
                    const options = {
                        mimeType: 'audio/webm;codecs=opus',
                        audioBitsPerSecond: 128000
                    };
                    
                    // 如果不支持，尝试其他格式
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        console.warn(`${options.mimeType} 不支持，尝试备选格式`);
                        options.mimeType = 'audio/webm';
                    }
                    
                    console.log(`使用录音格式: ${options.mimeType}`);
                    mediaRecorder = new MediaRecorder(stream, options);
                    
                    // 记录开始时间
                    recordingStartTime = Date.now();
                    
                    // 设置数据可用事件处理器
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            console.log(`收集到音频块: ${(event.data.size / 1024).toFixed(2)} KB`);
                            audioChunks.push(event.data);
                        }
                    };
                    
                    // 设置停止事件处理器
                    mediaRecorder.onstop = () => {
                        console.log('MediaRecorder 停止');
                        
                        // 停止所有音频轨道
                        if (audioTracks) {
                            audioTracks.forEach(track => {
                                if (track.readyState === 'live') {
                                    track.stop();
                                    console.log('音频轨道已停止');
                                }
                            });
                        }
                        
                        // 处理完整录音
                        processRecording();
                    };
                    
                    // 开始录音
                    mediaRecorder.start(1000);  // 每1秒获取一次数据块
                    console.log('录音已开始，每1秒收集一次数据');
                    
                    showStatus('info', '录音中...');
                } catch (error) {
                    console.error('启动录音时出错:', error);
                    
                    // 确保录音状态设置为false
                    isRecording = false;
                    
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        showStatus('error', '麦克风访问被拒绝，请检查浏览器权限设置');
                    } else {
                        showStatus('error', `启动录音出错: ${error.message}`);
                    }
                    
                    updateRecordingButtonState('error');
                    
                    // 延迟后恢复按钮状态
                    setTimeout(() => {
                        updateRecordingButtonState('idle');
                    }, 2000);
                }
            }
            
            // 停止录音
            function stopRecording() {
                console.log('停止录音');
                
                // 更新按钮状态
                updateRecordingButtonState('processing');
                
                // 设置录音状态为false
                isRecording = false;
                
                try {
                    // 检查mediaRecorder是否存在和状态
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        console.log('停止MediaRecorder');
                        mediaRecorder.stop();
                    } else {
                        console.warn('MediaRecorder不存在或不在录音状态');
                        
                        // 如果录音器不存在，直接处理结果
                        if (audioChunks && audioChunks.length > 0) {
                            processRecording();
                        } else {
                            updateRecordingButtonState('idle');
                            showStatus('error', '录音异常，请重试');
                        }
                    }
                    
                    // 停止所有音频轨道
                    if (audioTracks) {
                        audioTracks.forEach(track => {
                            if (track.readyState === 'live') {
                                track.stop();
                                console.log('音频轨道已停止');
                            }
                        });
                    }
                    
                    // 释放音频流
                    if (audioStream) {
                        audioStream.getTracks().forEach(track => track.stop());
                        audioStream = null;
                    }
                } catch (error) {
                    console.error('停止录音时出错:', error);
                    showStatus('error', `停止录音出错: ${error.message}`);
                    updateRecordingButtonState('error');
                    
                    // 延迟后恢复按钮状态
                    setTimeout(() => {
                        updateRecordingButtonState('idle');
                    }, 2000);
                }
            }
            
            // 处理录音数据
            function processRecording() {
                console.log('开始处理完整录音数据');
                
                // 检查是否有录音数据
                if (!audioChunks || audioChunks.length === 0) {
                    console.warn('没有录音数据可处理');
                    showStatus('error', '没有检测到语音');
                    updateRecordingButtonState('idle');
                    return;
                }
                
                try {
                    // 创建音频Blob
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    console.log(`完整音频数据大小: ${(audioBlob.size / 1024).toFixed(2)} KB`);
                    
                    // 检查音频大小
                    if (audioBlob.size < 8192) { // 8KB
                        console.warn('音频数据太小，可能没有录到声音');
                        showStatus('error', '录音太短或没有声音');
                        updateRecordingButtonState('idle');
                        return;
                    }
                    
                    // 使用当前时间戳创建唯一用户ID和文件名
                    const uniqueUserId = 'user-' + Date.now();
                    const filename = `recording_${Date.now()}.webm`;
                    
                    // 创建FormData对象
                    const formData = new FormData();
                    formData.append('file', audioBlob, filename);
                    formData.append('user', uniqueUserId);
                    formData.append('isPartial', 'false'); // 标记为完整音频
                    
                    showStatus('info', '正在识别完整语音...');
                    
                    // 标记AJAX识别请求正在处理中
                    window.isProcessingAjaxRecognition = true;
                    
                    // 发送到服务器进行识别
                    fetch('/api/speech-to-text', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.error(`语音识别请求失败: ${response.status} ${response.statusText}`);
                            throw new Error(`语音识别请求失败: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('完整语音识别结果(AJAX):', data);
                        
                        if (data.success && data.text) {
                            // 将识别结果添加到输入框
                            const inputBox = document.getElementById('messageInput');
                            if (inputBox) {
                                const currentText = inputBox.value.trim();
                                let newText = '';
                                
                                // 如果当前输入框已有文本，追加新识别的文本而不是替换
                                if (currentText) {
                                    // 检查是否需要添加空格或标点符号
                                    const needsSeparator = !currentText.endsWith(' ') && 
                                                          !currentText.endsWith('，') && 
                                                          !currentText.endsWith('。') &&
                                                          !currentText.endsWith('？') &&
                                                          !currentText.endsWith('！');
                                    
                                    // 添加适当的分隔符（中文环境下通常使用逗号）
                                    newText = currentText + (needsSeparator ? '，' : '') + data.text;
                                } else {
                                    newText = data.text;
                                }
                                
                                // 更新输入框文本
                                inputBox.value = newText;
                                
                                // 将焦点设置到输入框末尾
                                inputBox.focus();
                                inputBox.setSelectionRange(inputBox.value.length, inputBox.value.length);
                            } else {
                                console.error('未找到id为messageInput的输入框元素');
                            }
                            
                            showStatus('success', '语音识别成功，已添加到输入框');
                        } else {
                            console.warn('语音识别没有返回文本');
                            showStatus('warning', '未能识别语音内容');
                        }
                        
                        // 恢复按钮状态
                        updateRecordingButtonState('idle');
                    })
                    .catch(error => {
                        console.error('语音识别处理出错:', error);
                        showStatus('error', `语音识别失败: ${error.message}`);
                        updateRecordingButtonState('error');
                        
                        // 延迟后恢复按钮状态
                        setTimeout(() => {
                            updateRecordingButtonState('idle');
                        }, 2000);
                    })
                    .finally(() => {
                        // 清空音频数据
                        audioChunks = [];
                        // 标记AJAX识别请求处理完成
                        window.isProcessingAjaxRecognition = false;
                    });
                } catch (error) {
                    console.error('处理录音数据出错:', error);
                    showStatus('error', `处理录音出错: ${error.message}`);
                    updateRecordingButtonState('error');
                    
                    // 延迟后恢复按钮状态
                    setTimeout(() => {
                        updateRecordingButtonState('idle');
                    }, 2000);
                    
                    // 清空音频数据
                    audioChunks = [];
                    // 确保状态重置
                    window.isProcessingAjaxRecognition = false;
                }
            }
        }
        
        // 解锁音频播放（浏览器需要用户交互才能自动播放音频）
        let audioUnlocked = false;
        function unlockAudio() {
            if (audioUnlocked) return;
            
            console.log('尝试解锁音频播放...');
            
            // 创建一个静音的音频元素并尝试播放
            const silentAudio = new Audio();
            silentAudio.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV6urq6urq6urq6urq6urq6urq6v////////////////////////////////8AAAAATGF2YzU4LjU0AAAAAAAAAAAAAAAAJAYAAAAAAAAAASDs90hvAAAAAAAAAAAAAAAAAAAA';
            silentAudio.volume = 0.01;
            
            const promise = silentAudio.play();
            if (promise !== undefined) {
                promise.then(() => {
                    console.log('音频播放已解锁');
                    audioUnlocked = true;
                    
                    // 初始化MediaSource
                    if (!audioInitialized) {
                        initMediaSource();
                    }
                }).catch(e => {
                    console.warn('无法解锁音频播放:', e);
                });
            }
            
            // 移除事件监听器
            document.removeEventListener('click', unlockAudio);
            document.removeEventListener('keydown', unlockAudio);
        }
        
        // 处理音频数据
        function handleAudioData(base64Audio) {
            if (!mediaSource || mediaSource.readyState !== 'open') {
                initMediaSource();
            }
            
            try {
                // 将Base64音频数据转换为ArrayBuffer
                const binaryString = atob(base64Audio);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // 如果SourceBuffer正在更新，将音频块添加到队列
                if (sourceBuffer && sourceBuffer.updating) {
                    audioChunks.push(bytes.buffer);
                } else if (sourceBuffer) {
                    // 否则，直接添加到SourceBuffer
                    sourceBuffer.appendBuffer(bytes.buffer);
                } else {
                    console.error('SourceBuffer尚未创建');
                }
                
                // 如果音频未在播放，开始播放
                if (!isAudioPlaying && audioElement) {
                    audioElement.play().then(() => {
                        isAudioPlaying = true;
                        console.log('开始播放音频');
                    }).catch(e => {
                        console.error('音频播放失败:', e);
                    });
                }
            } catch (e) {
                console.error('处理音频数据失败:', e);
            }
        }
        
        // 结束音频流
        function endAudioStream() {
            if (mediaSource && mediaSource.readyState === 'open') {
                // 处理完队列中的所有音频块后关闭MediaSource
                if (audioChunks.length === 0 && sourceBuffer && !sourceBuffer.updating) {
                    try {
                        mediaSource.endOfStream();
                    } catch (e) {
                        console.error('关闭MediaSource失败:', e);
                    }
                } else {
                    // 如果队列不为空或SourceBuffer正在更新，等待处理完成后再关闭
                    setTimeout(endAudioStream, 100);
                }
            }
        }
        
        // 发送消息
        function sendMessage() {
            const message = messageInput.value.trim();
            
            if (message === '') {
                return; // 不发送空消息
            }
            
            const currentRequestId = 'req_' + Date.now();
            
            // 先清空输入框，再添加消息（避免消息快速发送导致的延迟）
            messageInput.value = '';
            
            // 确保停止所有当前播放的音频并创建新的对话轮次ID
            let currentRoundId;
            if (window.StreamingHandler && typeof window.StreamingHandler.resetAudioState === 'function') {
                // 使用StreamingHandler的重置函数，会停止音频并创建新轮次ID
                currentRoundId = window.StreamingHandler.resetAudioState();
                console.log(`已重置音频状态并创建新的对话轮次: ${currentRoundId}`);
            } else if (typeof window.globalStopAllAudio === 'function') {
                // 使用全局停止函数
                window.globalStopAllAudio();
                // 手动创建新的轮次ID
                window.currentConversationRoundId = 'round_' + Date.now();
                currentRoundId = window.currentConversationRoundId;
                console.log(`已停止音频并手动创建新的对话轮次: ${currentRoundId}`);
            } else {
                // 最后的后备方案：停止所有audio元素
                document.querySelectorAll('audio').forEach(audio => {
                    if (!audio.paused) {
                        audio.pause();
                        audio.currentTime = 0;
                    }
                });
                // 手动创建新的轮次ID
                window.currentConversationRoundId = 'round_' + Date.now();
                currentRoundId = window.currentConversationRoundId;
                console.log(`已停止音频并手动创建新的对话轮次: ${currentRoundId}`);
            }
            
            // 重置音频处理的状态变量
            window.processedAudioUrls = new Set();
            window.lastSynthesizedText = "";
            
            // 取消之前的流式响应（如果正在进行）
            if (window.StreamingHandler && typeof window.StreamingHandler.stopStreamingResponse === 'function') {
                window.StreamingHandler.stopStreamingResponse();
            }
            
            // 添加用户消息到聊天窗口
            addMessage(message, 'user');
            
            // 检查是否指令
            if (handleCommandMessage(message)) {
                return; // 如果是指令消息，处理后直接返回
            }
            
            // 显示输入指示器
            typingIndicator.style.display = 'block';
            
            console.log('已发送聊天请求:', {
                type: 'chat_request',
                message: message,
                requestId: currentRequestId,
                userId: userId,
                conversationRoundId: currentRoundId,
                files: uploadedFiles.length > 0 ? uploadedFiles : []
            });
            
            // 清空上传文件列表
            uploadedFiles = [];
            
            // 隐藏文件上传区域
            const filePreviewArea = document.getElementById('file-preview-area');
            if (filePreviewArea) {
                filePreviewArea.style.display = 'none';
            }
            
            // 检查WebSocket是否可用
            if (ws && ws.readyState === WebSocket.OPEN) {
                // 通过WebSocket发送消息，包含对话轮次ID
                ws.send(JSON.stringify({
                    type: 'chat_request',
                    message: message,
                    requestId: currentRequestId,
                    userId: userId,
                    conversationRoundId: currentRoundId,
                    files: [] // 暂不支持文件上传
                }));
                
                // 更新状态和UI
                window.hasSentMessage = true;
                messageInput.focus();
                chatMessages.scrollTop = chatMessages.scrollHeight;
            } else {
                console.error('WebSocket连接未建立，尝试使用普通HTTP请求');
                
                // 使用Fetch API发起HTTP请求，包含对话轮次ID
                fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: message,
                        user: userId,
                        conversation_id: conversationId,
                        conversation_round_id: currentRoundId
                    })
                })
                .then(response => {
                    // 检查是否是流式响应
                    const contentType = response.headers.get('Content-Type');
                    if (contentType && contentType.includes('text/event-stream')) {
                        console.log('收到流式响应，使用StreamingHandler处理');
                        
                        // 使用StreamingHandler处理流式响应
                        window.StreamingHandler.handleStreamingResponse(
                            response, 
                            addMessage, 
                            requestSpeech, 
                            typingIndicator
                        );
                    } else {
                        // 非流式响应，按普通JSON处理
                        return response.json();
                    }
                })
                .then(data => {
                    // 如果是JSON响应而非流式响应
                    if (data) {
                        // 隐藏输入指示器
                        typingIndicator.style.display = 'none';
                        
                        if (data.answer) {
                            const msgElement = addMessage(data.answer, 'bot');
                            
                            // 自动语音合成
                            if (window.autoSpeakEnabled) {
                                requestSpeech(data.answer, false, null, currentRoundId);
                            }
                            
                            // 保存会话ID（如果有）
                            if (data.conversation_id) {
                                conversationId = data.conversation_id;
                                localStorage.setItem('lastSessionId', conversationId);
                                localStorage.setItem('lastSessionDate', getCurrentDateString());
                                console.log('会话ID已更新:', conversationId);
                            }
                        } else if (data.error) {
                            addMessage(`错误: ${data.error}`, 'bot');
                        }
                    }
                })
                .catch(error => {
                    console.error('请求失败:', error);
                    addMessage('抱歉，服务器连接失败，请稍后再试。', 'bot');
                    typingIndicator.style.display = 'none';
                });
            }
        }
        
        // 请求语音合成
        function requestSpeech(text, isSegment = false, timestamp = null, roundId = null) {
            if (!text || !autoSpeakEnabled) return;
            
            // 获取或使用当前对话轮次ID
            const currentRoundId = roundId || window.currentConversationRoundId || ('round_' + Date.now());
            
            // 文本截断以便显示在日志中
            const textForLog = text.length > 50 ? text.substring(0, 50) + '...' : text;
            console.log('请求语音合成:', textForLog, timestamp ? `时间戳: ${timestamp}` : '', `轮次ID: ${currentRoundId}`);
            
            // 如果不是分段合成，先停止所有音频
            if (!isSegment) {
                window.StreamingHandler.stopAllAudio();
            }
            
            return new Promise((resolve, reject) => {
                // 添加重试机制
                const maxRetries = 3;
                let retryCount = 0;
                
                function attemptSynthesis() {
                    // 生成包含轮次ID的音频文件名
                    const audioFilenamePrefix = timestamp ? `tts_${timestamp}_round_${currentRoundId}` : `tts_${Date.now()}_round_${currentRoundId}`;
                    
                    // 调用TTS API
                    fetch('/api/tts', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: text,
                            voice: window.currentVoice || 'longxiaochun',
                            timestamp: timestamp || Date.now(), // 传递时间戳
                            roundId: currentRoundId, // 传递轮次ID (修改为驼峰命名)
                            filename_prefix: audioFilenamePrefix // 指定文件名前缀
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`服务器返回错误状态: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success && data.audioUrl) {
                            // 处理成功响应
                            console.log(`语音合成成功，音频URL: ${data.audioUrl}, 轮次ID: ${currentRoundId}`);
                            
                            // 使用StreamingHandler处理音频队列，传递时间戳和轮次ID信息
                            window.StreamingHandler.addAudioToQueue(data.audioUrl, text, timestamp, currentRoundId);
                            
                            // 返回成功
                            resolve(data);
                        } else {
                            console.error('语音合成失败:', data.error || '未知错误');
                            if (retryCount < maxRetries) {
                                retryCount++;
                                console.log(`语音合成重试 (${retryCount}/${maxRetries})...`);
                                setTimeout(attemptSynthesis, 1000); // 1秒后重试
                            } else {
                                reject(new Error(data.error || '语音合成失败'));
                            }
                        }
                    })
                    .catch(error => {
                        console.error('语音合成请求失败:', error);
                        if (retryCount < maxRetries) {
                            retryCount++;
                            console.log(`语音合成重试 (${retryCount}/${maxRetries})...`);
                            setTimeout(attemptSynthesis, 1000); // 1秒后重试
                        } else {
                            reject(error);
                        }
                    });
                }
                
                // 开始首次尝试
                attemptSynthesis();
            });
        }
        
        // 播放音频
        function playAudio(audioUrl) {
            if (!audioUrl) return;
            
            console.log('播放音频:', audioUrl);
            
            // 创建音频元素
            const audio = new Audio(audioUrl);
            
            // 音频加载成功事件
            audio.addEventListener('canplaythrough', () => {
                console.log('音频已加载，开始播放');
                
                // 播放音频
                audio.play().catch(error => {
                    console.error('音频播放失败:', error);
                });
            });
            
            // 音频播放完成事件
            audio.addEventListener('ended', () => {
                console.log('音频播放完成');
                
                // 如果有待播放的音频URL，继续播放下一个
                if (pendingAudioUrls.length > 0) {
                    const nextAudioUrl = pendingAudioUrls.shift();
                    playAudio(nextAudioUrl);
                }
            });
            
            // 音频加载错误事件
            audio.addEventListener('error', () => {
                console.error('音频加载失败:', audioUrl);
                
                // 如果有待播放的音频URL，继续播放下一个
                if (pendingAudioUrls.length > 0) {
                    const nextAudioUrl = pendingAudioUrls.shift();
                    playAudio(nextAudioUrl);
                }
            });
            
            // 开始加载音频
            audio.src = audioUrl;
            audio.load();
        }
        
        // 获取当前日期字符串函数
        function getCurrentDateString() {
            const now = new Date();
            return `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
        }
        
        // 生成用户ID函数
        function generateUserId() {
            return 'user_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
        }
        
        // 添加消息函数
        function addMessage(text, sender, messageId = null, isTemporary = false) {
            // 创建消息元素
            const messageElement = document.createElement('div');
            
            // 使用提供的ID或生成新ID
            if (messageId) {
                messageElement.id = messageId;
            } else {
                messageElement.id = 'message-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
            }
            
            messageElement.className = `message ${sender}-message`;
            
            // 如果是临时消息，添加临时样式
            if (isTemporary) {
                messageElement.classList.add('temporary-message');
                
                // 添加加载动画
                const loadingDots = document.createElement('div');
                loadingDots.className = 'loading-dots';
                loadingDots.innerHTML = '<span></span><span></span><span></span>';
                messageElement.appendChild(loadingDots);
            }
            
            // 创建消息文本元素
            const textElement = document.createElement('div');
            textElement.className = 'message-text';
            textElement.textContent = text;
            messageElement.appendChild(textElement);
            
            // 将消息添加到聊天窗口
            chatMessages.appendChild(messageElement);
            
            // 滚动到最新消息
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            console.log(`添加新消息，ID: ${messageElement.id}, 发送者: ${sender}, 内容: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
            
            return messageElement;
        }
        
        // 检查并更新会话ID
        function checkAndUpdateConversationId() {
            // 检查是否已有会话ID
            if (conversationId && conversationId.trim() !== '') {
                console.log('使用现有会话ID:', conversationId);
                return conversationId;
            }
            
            // 生成新的会话ID
            const newConversationId = 'session_' + Date.now();
            console.log('生成新的会话ID:', newConversationId);
            
            // 更新全局变量和localStorage
            conversationId = newConversationId;
            localStorage.setItem('lastSessionId', conversationId);
            localStorage.setItem('lastSessionDate', getCurrentDateString());
            
            return conversationId;
        }
        
        // 解锁音频播放
        function unlockAudio() {
            // 创建一个临时的音频元素
            const tempAudio = new Audio();
            
            // 尝试播放静音音频
            tempAudio.play().then(() => {
                console.log('音频播放已解锁');
                
                // 设置解锁标志
                window.audioUnlocked = true;
                
                // 移除事件监听器
                document.removeEventListener('click', unlockAudio);
                document.removeEventListener('keydown', unlockAudio);
            }).catch(() => {
                console.log('音频播放尚未解锁，等待用户交互');
            });
        }
        
        // 清理旧会话的音频文件
        function cleanupOldAudioFiles(sessionTime) {
            console.log('清理旧会话的音频文件');
            
            // 发送清理请求
            fetch('/api/cleanup-audio', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionTime: sessionTime || Date.now(),
                    userId: userId
                })
            }).then(response => {
                return response.json();
            }).then(data => {
                console.log('音频文件清理结果:', data);
            }).catch(error => {
                console.error('清理音频文件请求失败:', error);
            });
        }
        
        // 重置对话
        function resetConversation() {
            console.log('重置对话开始...');
            
            // 清空聊天消息
            chatMessages.innerHTML = '';
            
            // 停止所有音频播放
            if (window.StreamingHandler && typeof window.StreamingHandler.stopAllAudio === 'function') {
                window.StreamingHandler.stopAllAudio();
            }
            
            // 重置当前对话相关的ID变量
            window.tempPromptMessageId = null;
            window.lastBotMessageId = null;
            
            // 重置会话ID
            conversationId = '';
            localStorage.removeItem('lastSessionId');
            localStorage.removeItem('lastTempPromptId');
            
            // 生成新的会话ID
            checkAndUpdateConversationId();
            
            // 生成新的对话轮次ID
            window.currentConversationRoundId = 'round_' + Date.now();
            
            // 添加欢迎消息
            const welcomeId = `welcome-msg-${Date.now()}`;
            addMessage('您好！我是智能助手，有什么可以帮您的吗？', 'bot', welcomeId);
            
            // 清理旧的音频文件
            cleanupOldAudioFiles();
            
            console.log('对话已重置，新会话ID:', conversationId, '新对话轮次ID:', window.currentConversationRoundId);
        }
        
        // 增强stopAllAudio函数，确保彻底停止和清理所有音频
        function stopAllAudio() {
            if (window.StreamingHandler && typeof window.StreamingHandler.stopAllAudio === 'function') {
                window.StreamingHandler.stopAllAudio();
            } else {
                // 备用方法：停止所有<audio>元素
                document.querySelectorAll('audio').forEach(audio => {
                    if (!audio.paused) {
                        audio.pause();
                        audio.currentTime = 0;
                    }
                });
            }
        }
        
        // 添加消息到聊天窗口
        function addMessage(content, sender, messageId = null, isTemporary = false) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${sender}-message`;
            
            // 如果提供了消息ID，添加为元素ID
            if (messageId) {
                messageEl.id = messageId;
                console.log(`添加新消息，ID: ${messageId}, 发送者: ${sender}, 内容: "${content.substring(0, 30)}${content.length > 30 ? '...' : ''}"`);
            } else {
                // 如果没有提供ID，自动生成一个
                const generatedId = `message-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
                messageEl.id = generatedId;
                // 如果是机器人消息，保存ID以便后续更新
                if (sender === 'bot' && !isTemporary) {
                    window.lastBotMessageId = generatedId;
                }
                console.log(`添加新消息，自动生成ID: ${generatedId}, 发送者: ${sender}, 内容: "${content.substring(0, 30)}${content.length > 30 ? '...' : ''}"`);
            }
            
            // 如果是临时消息，添加样式
            if (isTemporary) {
                messageEl.classList.add('temporary-message');
                // 可以添加一个加载动画...
                const loadingIndicator = document.createElement('div');
                loadingIndicator.className = 'loading-dots';
                loadingIndicator.innerHTML = '<span></span><span></span><span></span>';
                messageEl.appendChild(loadingIndicator);
            }
            
            // 添加内容
            const textEl = document.createElement('div');
            textEl.className = 'message-text';
            textEl.textContent = content;
            messageEl.appendChild(textEl);
            
            chatMessages.appendChild(messageEl);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // 返回消息元素，以便调用者可以进一步操作
            return messageEl;
        }
        
        // 更新现有消息的内容
        function updateMessage(messageId, newContent) {
            console.log(`尝试更新消息 ID: ${messageId}, 新内容: "${newContent.substring(0, 30)}..."`);
            
            let messageEl = document.getElementById(messageId);
            
            // 如果找不到指定ID的元素，尝试找到最后一个机器人消息
            if (!messageEl) {
                console.warn(`未找到ID为 ${messageId} 的消息元素，尝试更新最后一个机器人消息`);
                const botMessages = document.querySelectorAll('.bot-message');
                if (botMessages.length > 0) {
                    messageEl = botMessages[botMessages.length - 1];
                    console.log(`使用最后一个机器人消息代替，新ID: ${messageEl.id || '未设置'}`);
                } else {
                    console.error('未找到任何机器人消息，无法更新');
                    // 创建一个新消息作为后备方案
                    addMessage(newContent, 'bot');
                    return;
                }
            }
            
            if (messageEl) {
                // 移除临时样式
                messageEl.classList.remove('temporary-message');
                
                // 移除加载动画
                const loadingDots = messageEl.querySelector('.loading-dots');
                if (loadingDots) {
                    loadingDots.remove();
                }
                
                // 更新文字内容
                const textEl = messageEl.querySelector('.message-text');
                if (textEl) {
                    // 日志原始内容和新内容
                    console.log(`更新前内容: "${textEl.textContent.substring(0, 30)}..." → 更新后内容: "${newContent.substring(0, 30)}..."`);
                    textEl.textContent = newContent;
                } else {
                    // 如果文字元素不存在，创建一个
                    console.log('未找到文本元素，创建新的文本元素');
                    const newTextEl = document.createElement('div');
                    newTextEl.className = 'message-text';
                    newTextEl.textContent = newContent;
                    messageEl.appendChild(newTextEl);
                }
                
                // 滚动到底部
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // 调试完成操作
                console.log(`消息更新完成，内容长度: ${newContent.length}`);
            }
        }
        
        // 处理文件上传
        function handleFileUpload(event) {
            const files = event.target.files;
            
            if (!files || files.length === 0) {
                return;
            }
            
            fileStatus.textContent = '正在上传...';
            
            // 清空文件预览
            filePreview.innerHTML = '';
            uploadedFiles = [];
            
            // 上传每个文件
            Array.from(files).forEach(file => {
                // 创建FormData
                const formData = new FormData();
                formData.append('file', file);
                
                // 上传文件到服务器
                fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.url) {
                        // 添加到上传的文件列表
                        uploadedFiles.push({
                            name: file.name,
                            url: data.url
                        });
                        
                        // 创建预览
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        
                        const img = document.createElement('img');
                        img.src = data.url;
                        fileItem.appendChild(img);
                        
                        const removeBtn = document.createElement('div');
                        removeBtn.className = 'remove-file';
                        removeBtn.textContent = 'x';
                        removeBtn.addEventListener('click', () => {
                            // 从预览和上传列表中移除
                            fileItem.remove();
                            uploadedFiles = uploadedFiles.filter(f => f.url !== data.url);
                        });
                        fileItem.appendChild(removeBtn);
                        
                        filePreview.appendChild(fileItem);
                        
                        // 更新状态
                        fileStatus.textContent = `已上传 ${uploadedFiles.length} 个文件`;
                    } else {
                        console.error('文件上传失败:', data.error);
                        fileStatus.textContent = '文件上传失败';
                    }
                })
                .catch(error => {
                    console.error('文件上传请求失败:', error);
                    fileStatus.textContent = '文件上传失败';
                });
            });
        }

        // 初始化MediaSource
        function initMediaSource() {
            console.log('初始化MediaSource');
            
            // 如果已经初始化，则返回
            if (audioInitialized) {
                console.log('MediaSource已经初始化');
                return;
            }
            
            // 创建MediaSource实例
            mediaSource = new MediaSource();
            
            // 创建音频元素
            audioElement = new Audio();
            audioElement.controls = false;
            audioElement.style.display = 'none';
            audioElement.volume = 1.0;
            document.body.appendChild(audioElement);
            
            // 设置音频源
            audioElement.src = URL.createObjectURL(mediaSource);
            
            // 监听MediaSource打开事件
            mediaSource.addEventListener('sourceopen', () => {
                console.log('MediaSource已打开');
                
                try {
                    // 尝试不同的MIME类型
                    try {
                        sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg');
                    } catch (e) {
                        console.warn('无法创建audio/mpeg SourceBuffer，尝试其他格式');
                        try {
                            sourceBuffer = mediaSource.addSourceBuffer('audio/mp3');
                        } catch (e2) {
                            console.warn('无法创建audio/mp3 SourceBuffer，尝试其他格式');
                            sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg; codecs="mp3"');
                        }
                    }
                    
                    // 监听SourceBuffer更新结束事件
                    sourceBuffer.addEventListener('updateend', () => {
                        console.log('SourceBuffer更新结束');
                        // 如果队列中有待处理的音频块，继续添加
                        if (audioChunks.length > 0 && !sourceBuffer.updating) {
                            const chunk = audioChunks.shift();
                            console.log(`从队列中取出音频块，剩余: ${audioChunks.length}`);
                            sourceBuffer.appendBuffer(chunk);
                        }
                    });
                    
                    audioInitialized = true;
                    console.log('音频播放器初始化完成');
                } catch (e) {
                    console.error('创建SourceBuffer失败:', e);
                    // 尝试使用普通Audio元素播放
                    fallbackToSimpleAudio();
                }
            });
            
            // 添加错误处理
            mediaSource.addEventListener('error', (e) => {
                console.error('MediaSource错误:', e);
                fallbackToSimpleAudio();
            });
            
            // 监听音频播放结束事件
            audioElement.addEventListener('ended', () => {
                console.log('音频播放结束');
                isAudioPlaying = false;
            });
            
            // 添加错误处理
            audioElement.addEventListener('error', (e) => {
                console.error('音频元素错误:', e);
                fallbackToSimpleAudio();
            });
        }

        // 添加音频块到MediaSource
        function appendAudioChunk(arrayBuffer) {
            if (!sourceBuffer || !mediaSource || mediaSource.readyState !== 'open') {
                // 如果MediaSource尚未准备好，将块添加到队列
                audioChunks.push(arrayBuffer);
                console.log('MediaSource尚未准备好，将音频块添加到队列');
                return;
            }
            
            try {
                if (sourceBuffer.updating) {
                    // 如果SourceBuffer正在更新，将块添加到队列
                    audioChunks.push(arrayBuffer);
                    console.log('SourceBuffer正在更新，将音频块添加到队列');
                } else {
                    // 直接添加到SourceBuffer
                    console.log(`直接添加音频块到SourceBuffer，大小: ${arrayBuffer.byteLength}`);
                    sourceBuffer.appendBuffer(arrayBuffer);
                    console.log(`音频块已添加到SourceBuffer，队列长度: ${audioChunks.length}`);
                }
            } catch (e) {
                console.error('添加音频块失败:', e);
                // 如果添加失败，尝试降级
                fallbackToSimpleAudio();
            }
        }

        // 添加音频预加载功能
        function preloadAudio(url) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.oncanplaythrough = () => {
                    resolve(audio);
                };
                audio.onerror = (error) => {
                    reject(error);
                };
                audio.src = url;
                audio.load();
            });
        }

        // 辅助函数：检查URL是否已处理过
        function isUrlProcessed(url) {
            // 完整URL检查
            if (processedUrls.has(url)) return true;
            
            // 文件名检查（有时URL格式可能略有不同）
            const filename = url.split('/').pop();
            for (const processedUrl of processedUrls) {
                const processedFilename = processedUrl.split('/').pop();
                if (processedFilename === filename) return true;
            }
            return false;
        }
        
        // 辅助函数：检查URL是否已在队列中
        function isUrlInQueue(url) {
            // 完整URL检查
            const exactMatch = pendingAudioUrls.some(item => item.url === url);
            if (exactMatch) return true;
            
            // 文件名检查（有时URL格式可能略有不同）
            const filename = url.split('/').pop();
            return pendingAudioUrls.some(item => {
                const itemFilename = item.url.split('/').pop();
                return itemFilename === filename;
            });
        }
        
        // 当收到音频事件时，处理音频URL
        function handleAudioEvent(parsedData) {
            console.log('收到音频URL:', parsedData.url);
            console.log('音频文本:', parsedData.text);
            console.log('是否最终片段:', parsedData.isFinal);
            console.log('音频轮次ID:', parsedData.roundId || '未指定');
            
            // 检查URL是否有效
            if (!parsedData.url || !parsedData.url.startsWith('/audio/')) {
                console.log('跳过无效音频URL');
                return;
            }
            
            // 提取文件名
            const filename = parsedData.url.split('/').pop();
            
            // 检查文件是否已被删除
            if (deletedFiles.has(filename)) {
                console.log(`跳过已删除的音频文件: ${filename}`);
                return;
            }
            
            // 检查音频是否属于当前对话轮次 - 使用后端返回的轮次ID
            const audioRoundId = parsedData.roundId;
            if (audioRoundId && audioRoundId !== currentConversationRoundId) {
                console.log(`跳过不属于当前轮次的音频: ${parsedData.url} [轮次ID: ${audioRoundId} 不等于 ${currentConversationRoundId}]`);
                return;
            }
            
            // 检查URL是否已在队列中或已处理
            if (isUrlProcessed(parsedData.url)) {
                console.log(`音频URL已被处理，跳过: ${parsedData.url}`);
                return;
            }
            
            if (isUrlInQueue(parsedData.url)) {
                console.log(`音频URL已在队列中，跳过: ${parsedData.url}`);
                return;
            }
            
            // 提取文件名中的数字（用于排序）
            const match = parsedData.url.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
            const timestamp = match ? parseInt(match[1]) : 0;
            
            // 递增计数器
            totalAudioReceived++;
            console.log(`处理新音频 #${totalAudioReceived}: ${parsedData.url}`);
            
            // 添加到待处理队列，包含当前对话轮次ID
            pendingAudioUrls.push({
                url: parsedData.url,
                text: parsedData.text || "",
                isFinal: parsedData.isFinal || false,
                timestamp: timestamp,
                id: totalAudioReceived,
                receivedAt: Date.now(),
                roundId: audioRoundId || currentConversationRoundId // 使用后端返回的轮次ID，如没有则使用当前轮次ID
            });
            
            console.log(`添加到队列成功，当前队列长度: ${pendingAudioUrls.length}, 轮次ID: ${audioRoundId || currentConversationRoundId}`);
            
            // 按时间戳排序队列
            pendingAudioUrls.sort((a, b) => a.timestamp - b.timestamp);
            
            // 如果当前没有正在处理音频，开始处理
            if (!isProcessingAudio) {
                console.log('开始处理音频队列');
                processNextAudio();
            } else {
                console.log('当前有音频正在处理，新音频已加入队列');
            }
        }

        // 修改音频处理函数
        async function processNextAudio() {
            // 过滤不属于当前轮次的音频
            if (pendingAudioUrls.length > 0) {
                const outdatedAudios = pendingAudioUrls.filter(audio => audio.roundId !== currentConversationRoundId);
                if (outdatedAudios.length > 0) {
                    console.log(`发现 ${outdatedAudios.length} 个不属于当前轮次(${currentConversationRoundId})的音频，将被跳过`);
                    // 从队列中移除这些音频
                    pendingAudioUrls = pendingAudioUrls.filter(audio => audio.roundId === currentConversationRoundId);
                }
            }
            
            if (pendingAudioUrls.length === 0) {
                isProcessingAudio = false;
                currentPlayingAudio = null;
                console.log('音频队列为空，处理结束');
                return;
            }
            
            isProcessingAudio = true;
            const audioItem = pendingAudioUrls.shift();
            currentPlayingAudio = audioItem;
            
            console.log(`开始处理音频: ${audioItem.url} (队列剩余: ${pendingAudioUrls.length}个) [轮次ID: ${audioItem.roundId}]`);
            
            // 再次检查该音频是否已被处理或已被删除
            const filename = audioItem.url.split('/').pop();
            if (isUrlProcessed(audioItem.url)) {
                console.log(`音频已被处理，跳过: ${audioItem.url}`);
                currentPlayingAudio = null;
                processNextAudio();
                return;
            }
            
            if (deletedFiles.has(filename)) {
                console.log(`音频文件已被删除，跳过: ${filename}`);
                currentPlayingAudio = null;
                processNextAudio();
                return;
            }
            
            try {
                // 预加载音频
                console.log(`预加载音频: ${audioItem.url}`);
                const audio = await preloadAudio(audioItem.url);
                console.log(`音频预加载成功: ${audioItem.url}`);
                
                // 添加轮次ID属性用于后续检查
                audio.dataset.roundId = audioItem.roundId;
                audio.dataset.audioUrl = audioItem.url;
                
                // 播放音频
                audio.onended = () => {
                    console.log(`音频播放完成: ${audioItem.url}`);
                    // 标记为已处理
                    processedUrls.add(audioItem.url);
                    totalAudioPlayed++;
                    currentPlayingAudio = null;
                    
                    // 播放完成后删除音频文件
                    if (filename && filename.startsWith('tts_') && filename.endsWith('.mp3') && !deletedFiles.has(filename)) {
                        deleteAudioFile(filename);
                    }
                    
                    // 删除音频元素，避免内存泄漏
                    document.body.removeChild(audio);
                    processNextAudio();
                };
                
                // 添加到DOM以便控制
                audio.style.display = 'none'; // 隐藏元素但保持功能
                document.body.appendChild(audio);
                
                console.log(`开始播放音频: ${audioItem.url}`);
                audio.play().catch(error => {
                    console.error(`音频播放失败: ${error.message}`);
                    // 尝试重新加载并播放
                    setTimeout(() => {
                        console.log(`尝试重新加载音频: ${audioItem.url}`);
                        audio.load();
                        audio.play().catch(e => {
                            console.error(`重试播放失败: ${e.message}`);
                            // 移除DOM元素
                            document.body.removeChild(audio);
                            processNextAudio(); // 继续处理下一个
                        });
                    }, 1000);
                });
            } catch (error) {
                console.error(`处理音频出错: ${error.message}`);
                // 继续处理下一个
                currentPlayingAudio = null;
                processNextAudio();
            }
        }

        // 开始播放
        function startPlayback() {
            // 如果音频未在播放，开始播放
            if (!isAudioPlaying && audioElement && audioInitialized) {
                audioElement.play()
                    .then(() => {
                        isAudioPlaying = true;
                        console.log('开始播放音频流');
                    })
                    .catch(err => {
                        // 如果播放失败，尝试降级
                        fallbackToSimpleAudio();
                    });
            } else {
                if (isAudioPlaying) {
                    console.log('已在播放中');
                } else {
                    console.log('播放器未就绪');
                }
            }
        }

        // 降级到简单音频播放
        function fallbackToSimpleAudio() {
            console.log('降级到简单音频播放模式');
            
            // 重置状态
            audioInitialized = false;
            isAudioPlaying = false;
            
            // 清理现有元素
            if (audioElement) {
                audioElement.pause();
                if (audioElement.parentNode) {
                    audioElement.parentNode.removeChild(audioElement);
                }
            }
            
            // 确保队列按时间戳排序
            pendingAudioUrls.sort((a, b) => a.timestamp - b.timestamp);
            
            // 显示当前队列状态
            const queueInfo = pendingAudioUrls.map(item => {
                const shortUrl = item.url.split('/').pop();
                return `${shortUrl}`;
            }).join(', ');
            
            // 创建音频队列播放器
            const audioQueue = [...pendingAudioUrls];
            pendingAudioUrls = [];
            
            // 播放第一个音频
            if (audioQueue.length > 0) {
                playNextInQueue(audioQueue);
            }
        }

        // 按顺序播放队列中的音频
        function playNextInQueue(queue) {
            if (queue.length === 0) {
                console.log('简单模式队列播放完成');
                return;
            }
            
            const audioData = queue.shift();
            console.log(`简单模式播放: ${audioData.url.split('/').pop()}`);
            
            const audio = new Audio(audioData.url);
            audio.volume = 1.0;
            audio.controls = false;
            audio.style.display = 'none';
            document.body.appendChild(audio);
            
            // 播放结束后播放下一个
            audio.onended = () => {
                // 删除音频文件
                const filename = audioData.url.split('/').pop();
                if (filename && filename.startsWith('tts_') && filename.endsWith('.mp3') && !deletedFiles.has(filename)) {
                    deleteAudioFile(filename);
                }
                
                document.body.removeChild(audio);
                playNextInQueue(queue);
            };
            
            // 播放错误处理
            audio.onerror = (e) => {
                console.error('播放错误:', e);
                document.body.removeChild(audio);
                playNextInQueue(queue);
            };
            
            // 开始播放
            audio.play().catch(err => {
                console.error('播放失败:', err);
                document.body.removeChild(audio);
                playNextInQueue(queue);
            });
        }

        // 改进检查音频文件函数
        function checkMissingAudio() {
            console.log('开始检查音频文件...');
            
            // 获取最近30秒内的URL，避免检查太旧的音频
            const recentTime = Date.now() - 30000; // 30秒前
            
            // 获取已处理的最近URLs
            const recentProcessedUrls = Array.from(processedUrls)
                .filter(url => {
                    // 尝试从URL中提取时间戳
                    const match = url.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
                    if (match) {
                        const urlTimestamp = parseInt(match[1]);
                        // 时间戳是否在最近30秒内
                        return Date.now() - urlTimestamp < 30000;
                    }
                    return true; // 如果无法提取时间戳，默认保留
                });
            
            // 检查后台生成的音频文件
            fetch('/api/audio/list')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const backendFiles = data.files || [];
                    if (backendFiles.length === 0) {
                        console.log('后台没有音频文件');
                        return;
                    }
                    
                    console.log(`后台音频文件数量: ${backendFiles.length}`);
                    
                    // 获取最近生成的音频文件（按文件名中的时间戳排序）
                    const recentFiles = backendFiles
                        .filter(file => {
                            // 修改正则表达式以匹配带有轮次ID的文件名
                            const match = file.match(/tts_(\d+)(?:_round_([^.]+))?\.mp3$/);
                            if (match) {
                                const timestamp = parseInt(match[1]);
                                const roundId = match[2];
                                
                                // 只处理30秒内的文件，并且要么没有轮次ID，要么轮次ID匹配当前轮次
                                return Date.now() - timestamp < 30000 && 
                                       (!roundId || roundId === currentConversationRoundId);
                            }
                            return false;
                        })
                        .sort((a, b) => {
                            const matchA = a.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
                            const matchB = b.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
                            const timeA = matchA ? parseInt(matchA[1]) : 0;
                            const timeB = matchB ? parseInt(matchB[1]) : 0;
                            return timeA - timeB;
                        });
                    
                    if (recentFiles.length === 0) {
                        console.log('没有最近生成的音频文件');
                        return;
                    }
                    
                    console.log(`最近音频文件: ${recentFiles.join(', ')}`);
                    
                    // 检查是否有未处理的文件
                    const pendingUrls = pendingAudioUrls.map(item => item.url.split('/').pop());
                    
                    const missingFiles = recentFiles.filter(file => {
                        // 检查文件是否已被删除
                        if (deletedFiles.has(file)) return false;
                        
                        // 检查文件名对应的URL是否已在队列中
                        const fileUrl = `/audio/${file}`;
                        if (isUrlInQueue(fileUrl)) return false;
                        
                        // 检查文件名对应的URL是否已被处理
                        if (isUrlProcessed(fileUrl)) return false;
                        
                        // 检查文件是否属于当前轮次
                        const match = file.match(/tts_\d+_round_([^.]+)\.mp3$/);
                        if (match) {
                            const roundId = match[1];
                            if (roundId !== currentConversationRoundId) {
                                console.log(`跳过不属于当前轮次的音频文件: ${file} [轮次ID: ${roundId}]`);
                                return false;
                            }
                        }
                        
                        // 如果以上条件都不满足，则认为是遗漏的文件
                        return true;
                    });
                    
                    if (missingFiles.length > 0) {
                        console.log(`发现 ${missingFiles.length} 个未处理的音频文件: ${missingFiles.join(', ')}`);
                        
                        // 限制添加的数量，避免添加太多旧文件
                        const filesToAdd = missingFiles.slice(0, 5); // 最多添加5个
                        
                        console.log(`添加 ${filesToAdd.length} 个文件到队列`);
                        
                        // 添加到待处理队列，标记为当前轮次的音频
                        filesToAdd.forEach((file, index) => {
                            const url = `/audio/${file}`;
                            
                            // 检查是否已经在队列中
                            const alreadyInQueue = pendingAudioUrls.some(item => item.url === url);
                            if (alreadyInQueue) {
                                console.log(`文件已在队列中: ${file}`);
                                return;
                            }
                            
                            // 提取文件中的轮次ID
                            let fileRoundId = currentConversationRoundId;
                            const roundMatch = file.match(/tts_\d+_round_([^.]+)\.mp3$/);
                            if (roundMatch) {
                                fileRoundId = roundMatch[1];
                            }
                            
                            const timestampMatch = file.match(/tts_(\d+)(?:_round_[^.]+)?\.mp3$/);
                            const timestamp = timestampMatch ? parseInt(timestampMatch[1]) : 0;
                            
                            pendingAudioUrls.push({
                                url: url,
                                text: "",
                                isFinal: index === filesToAdd.length - 1,
                                timestamp: timestamp,
                                id: totalAudioReceived + index + 1,
                                receivedAt: Date.now(),
                                roundId: fileRoundId // 使用文件名中的轮次ID
                            });
                        });
                        
                        totalAudioReceived += filesToAdd.length;
                        
                        // 按时间戳排序队列
                        pendingAudioUrls.sort((a, b) => a.timestamp - b.timestamp);
                        
                        // 如果当前没有正在处理音频，开始处理
                        if (!isProcessingAudio) {
                            processNextAudio();
                        }
                    } else {
                        console.log('没有发现未处理的音频文件');
                    }
                })
                .catch(error => {
                    console.error('检查音频文件失败:', error);
                });
        }

        // 删除音频文件
        async function deleteAudioFile(filename) {
            try {
                // 检查文件是否已经被删除
                if (deletedFiles.has(filename)) {
                    console.log(`文件已被删除，跳过: ${filename}`);
                    return;
                }
                
                console.log(`正在删除音频文件: ${filename}`);
                const response = await fetch(`/api/audio/delete/${filename}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                if (result.success) {
                    console.log(`音频文件删除成功: ${filename}`);
                    deletedFiles.add(filename);
                } else {
                    console.log(`音频文件删除失败: ${result.message}`);
                }
            } catch (error) {
                console.error('删除音频文件失败:', error);
            }
        }
        
        // 批量清理旧音频文件
        async function cleanupOldAudioFiles(sessionStartTime) {
            try {
                console.log(`正在清理旧音频文件...`);
                const response = await fetch('/api/audio/cleanup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sessionStartTime })
                });
                const result = await response.json();
                if (result.success) {
                    console.log(`清理完成: 已删除${result.deletedCount}个旧文件`);
                    
                    // 将删除的文件记录到deletedFiles集合中
                    if (result.deletedFiles && Array.isArray(result.deletedFiles)) {
                        result.deletedFiles.forEach(file => deletedFiles.add(file));
                    }
                } else {
                    console.log(`清理失败: ${result.message}`);
                }
            } catch (error) {
                console.error('清理旧音频文件失败:', error);
            }
        }

        // 重置对话
        function resetConversation() {
            console.log('重置对话开始...');
            
            // 清空聊天消息
            chatMessages.innerHTML = '';
            
            // 停止所有音频播放
            if (window.StreamingHandler && typeof window.StreamingHandler.stopAllAudio === 'function') {
                window.StreamingHandler.stopAllAudio();
            }
            
            // 重置当前对话相关的ID变量
            window.tempPromptMessageId = null;
            window.lastBotMessageId = null;
            
            // 重置会话ID
            conversationId = '';
            localStorage.removeItem('lastSessionId');
            localStorage.removeItem('lastTempPromptId');
            
            // 生成新的会话ID
            checkAndUpdateConversationId();
            
            // 生成新的对话轮次ID
            window.currentConversationRoundId = 'round_' + Date.now();
            
            // 添加欢迎消息
            const welcomeId = `welcome-msg-${Date.now()}`;
            addMessage('您好！我是智能助手，有什么可以帮您的吗？', 'bot', welcomeId);
            
            // 清理旧的音频文件
            cleanupOldAudioFiles();
            
            console.log('对话已重置，新会话ID:', conversationId, '新对话轮次ID:', window.currentConversationRoundId);
        }

        // 更新语音识别文本到输入框
        function updateRecognitionText(data) {
            console.log('收到WebSocket语音识别结果:', data);
            
            // 检查是否来自WebSocket的实时更新
            const isWebSocketUpdate = true;
            
            // 如果正在进行AJAX识别请求处理，跳过WebSocket更新
            if (window.isProcessingAjaxRecognition === true) {
                console.log('AJAX识别请求正在处理中，跳过WebSocket更新');
                return;
            }
            
            // 将识别文本填充到消息输入框
            messageInput.value = data.text;
            
            // 如果是最终结果，更新状态
            if (data.isFinal) {
                // 显示录音状态为"识别完成"
                recordingStatus.textContent = '句子识别完成';
                setTimeout(() => {
                    if (recordingStatus.textContent === '句子识别完成') {
                        recordingStatus.style.display = 'none';
                    }
                }, 1500);
            }
        }
        
        // 处理语音识别完成
        function handleRecognitionComplete(data) {
            console.log('语音识别完成:', data);
            
            // 将最终识别文本填充到消息输入框
            messageInput.value = data.text;
            
            // 更新状态
            recordingStatus.textContent = '识别完成';
            setTimeout(() => {
                recordingStatus.style.display = 'none';
                updateRecordingButtonState('idle');
                recordButton.disabled = false;
            }, 1500);
            
            // 聚焦输入框
            messageInput.focus();
        }
        
        // 处理计时器完成事件
        function handleTimerCompleted(timer) {
            console.log('计时器完成:', timer);
            
            // 提取消息内容和通知文本
            let notificationMessage = '';
            let messageToSpeak = '';
            
            // 获取计时器的实际消息内容（用于播放）
            if (timer && timer.message) {
                messageToSpeak = timer.message;
            }
            
            // 构建通知消息（只用于显示）
            if (timer && timer.name) {
                notificationMessage = `计时器 "${timer.name}" 已完成`;
            } else if (timer && timer.title) {
                notificationMessage = `计时器 "${timer.title}" 已完成`;
            } else {
                notificationMessage = '计时器已完成';
            }
            
            // 添加消息到聊天框
            addMessage(notificationMessage, 'bot');
            
            // 仅当有指定的消息内容时才播放语音
            if (messageToSpeak) {
                console.log(`计时器消息内容: "${messageToSpeak}"`);
                // 先播放广播提示音，然后再播放计时器消息
                playWithAlertSound(messageToSpeak);
                
                // 设置重复提醒
                if (timerSettings.repeatCount > 1) {
                    const timerId = timer.id || `timer_${Date.now()}`;
                    setupTimerReminders(timerId, messageToSpeak);
                }
            } else {
                // 如果没有指定消息内容，则播放通知消息
                console.log('计时器没有指定消息内容，使用通知消息');
                playWithAlertSound(notificationMessage);
                
                // 设置重复提醒
                if (timerSettings.repeatCount > 1) {
                    const timerId = timer.id || `timer_${Date.now()}`;
                    setupTimerReminders(timerId, notificationMessage);
                }
            }
        }

        // 先播放提示音，然后再播放计时器消息的函数
        function playWithAlertSound(message) {
            const alertSoundUrl = '/audio/Broadcastalert.mp3';
            
            console.log('检查广播提示音文件:', alertSoundUrl);
            console.log(`将要播放的计时器消息:`, message);
            
            // 检查是否有AudioAutoplay模块
            if (window.AudioAutoplay) {
                // 先播放提示音，然后播放消息
                window.AudioAutoplay.play(alertSoundUrl, () => {
                    console.log('广播提示音播放完成，开始播放计时器消息');
                    // 使用语音合成播放消息
                    speakMessage(message);
                });
            } else {
                // 回退方案：检查广播提示音文件是否存在
                fetch(alertSoundUrl, { method: 'HEAD' })
                    .then(response => {
                        if (response.ok) {
                            console.log('广播提示音可用，先播放提示音');
                            playAlertThenMessage(alertSoundUrl, message);
                        } else {
                            console.log('广播提示音不可用，直接播放计时器消息');
                            // 直接播放计时器消息
                            speakMessage(message);
                        }
                    })
                    .catch(error => {
                        console.error('检查广播提示音时出错:', error);
                        // 出错时直接播放计时器消息
                        speakMessage(message);
                    });
            }
        }

        // 使用普通Audio元素播放提示音，然后播放消息
        function playAlertThenMessage(alertSoundUrl, message, repeatCount = 2) {
            console.log('使用普通Audio元素播放提示音');
            
            // 创建音频元素并播放提示音
            const alertAudio = new Audio();
            // 添加playsinline属性以提高在移动设备上自动播放的成功率
            alertAudio.setAttribute('playsinline', '');
            alertAudio.setAttribute('webkit-playsinline', '');
            alertAudio.preload = 'auto';
            
            // 设置音频源
            alertAudio.src = alertSoundUrl;
            
            // 提示音播放完成后，播放计时器消息
            alertAudio.onended = function() {
                console.log('广播提示音播放完成，开始播放计时器消息');
                // 移除提示音元素
                if (alertAudio.parentNode) {
                    alertAudio.parentNode.removeChild(alertAudio);
                }
                // 播放计时器消息，重复播放指定次数
                speakMessage(message, repeatCount);
            };
            
            // 提示音加载错误时，直接播放计时器消息
            alertAudio.onerror = function(e) {
                console.error('广播提示音加载失败:', e);
                // 移除提示音元素
                if (alertAudio.parentNode) {
                    alertAudio.parentNode.removeChild(alertAudio);
                }
                // 直接播放计时器消息，重复播放指定次数
                speakMessage(message, repeatCount);
            };
            
            // 将音频元素添加到DOM，以便控制播放和处理事件
            alertAudio.style.display = 'none'; // 隐藏元素
            document.body.appendChild(alertAudio);
            
            // 触发播放前先设置较低音量，然后再恢复
            alertAudio.volume = 0.1;
            
            // 开始播放提示音
            alertAudio.play().then(() => {
                console.log('广播提示音开始播放');
                // 播放成功后平滑恢复音量
                setTimeout(() => {
                    // 使用定时器平滑调整音量
                    let vol = 0.1;
                    const interval = setInterval(() => {
                        if (vol < 1.0) {
                            vol += 0.1;
                            alertAudio.volume = vol > 1.0 ? 1.0 : vol;
                        } else {
                            clearInterval(interval);
                        }
                    }, 100);
                }, 100);
            }).catch(err => {
                console.error('广播提示音播放失败:', err);
                // 直接播放计时器消息，重复播放指定次数
                speakMessage(message, repeatCount);
            });
        }

        // 语音播报功能
        function speakMessage(message, repeatCount = 1) {
            // 如果已经有语音合成功能，使用现有功能
            if (typeof synthText === 'function') {
                synthText(message, repeatCount);
                return;
            }
            
            // 使用阿里云CosyVoice模型进行语音合成
            fetch('/api/tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ text: message })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.audioUrl) {
                    console.log(`开始播放语音消息${repeatCount > 1 ? `(将重复${repeatCount}遍)` : ''}: "${message}"`);
                    
                    // 使用AudioAutoplay模块播放（带重复）
                    if (window.AudioAutoplay) {
                        playAudioWithRepeat(data.audioUrl, repeatCount);
                        return;
                    }
                    
                    // 创建音频元素并播放
                    playAudioElementWithRepeat(data.audioUrl, message, repeatCount);
                } else {
                    console.error('语音合成失败:', data.error);
                    // 降级到浏览器原生语音合成
                    useBrowserTTS(message, repeatCount);
                }
            })
            .catch(error => {
                console.error('语音合成请求失败:', error);
                // 降级到浏览器原生语音合成
                useBrowserTTS(message, repeatCount);
            });
        }

        // 使用AudioAutoplay模块播放音频并重复
        function playAudioWithRepeat(audioUrl, repeatCount) {
            let currentRepeat = 0;
            
            const playNext = () => {
                currentRepeat++;
                console.log(`播放第 ${currentRepeat}/${repeatCount} 遍`);
                
                if (currentRepeat <= repeatCount) {
                    window.AudioAutoplay.play(audioUrl, () => {
                        console.log(`第 ${currentRepeat} 遍播放完成`);
                        // 如果还需要继续重复，延迟一小段时间后播放下一遍
                        if (currentRepeat < repeatCount) {
                            setTimeout(playNext, 500); // 0.5秒的间隔
                        }
                    });
                }
            };
            
            // 开始第一次播放
            playNext();
        }

        // 使用普通Audio元素播放音频并重复
        function playAudioElementWithRepeat(audioUrl, fallbackText, repeatCount) {
            let currentRepeat = 0;
            
            const playNext = () => {
                currentRepeat++;
                console.log(`播放第 ${currentRepeat}/${repeatCount} 遍`);
                
                const audio = new Audio(audioUrl);
                
                // 添加加载错误处理
                audio.onerror = function(e) {
                    console.error(`第 ${currentRepeat} 遍音频加载失败:`, e);
                    if (currentRepeat === 1) {
                        // 只在第一次失败时降级到浏览器TTS
                        useBrowserTTS(fallbackText, repeatCount);
                    }
                };
                
                // 添加音频播放完成事件
                audio.onended = function() {
                    console.log(`第 ${currentRepeat} 遍音频播放完成`);
                    
                    // 移除音频元素
                    if (audio.parentNode) {
                        audio.parentNode.removeChild(audio);
                    }
                    
                    // 如果还需要继续重复，延迟一小段时间后播放下一遍
                    if (currentRepeat < repeatCount) {
                        setTimeout(playNext, 500); // 0.5秒的间隔
                    }
                };
                
                // 将音频元素添加到DOM
                audio.style.display = 'none';
                document.body.appendChild(audio);
                
                // 开始播放
                audio.play().catch(err => {
                    console.error(`第 ${currentRepeat} 遍音频播放失败:`, err);
                    if (currentRepeat === 1) {
                        // 只在第一次失败时降级到浏览器TTS
                        useBrowserTTS(fallbackText, repeatCount);
                    }
                });
            };
            
            // 开始第一次播放
            playNext();
        }

        // 使用浏览器原生语音合成
        function useBrowserTTS(text, repeatCount = 1) {
            // 检查浏览器是否支持语音合成
            if ('speechSynthesis' in window) {
                // 创建一个数组，包含需要播放的文本（重复多次）
                const textsToSpeak = Array(repeatCount).fill(text);
                let currentIndex = 0;
                
                const speakNext = () => {
                    if (currentIndex < textsToSpeak.length) {
                        const utterance = new SpeechSynthesisUtterance(textsToSpeak[currentIndex]);
                        
                        // 尝试设置中文语音
                        const voices = window.speechSynthesis.getVoices();
                        const chineseVoice = voices.find(voice => 
                            voice.lang.includes('zh') || 
                            voice.name.includes('Chinese') || 
                            voice.name.includes('中文')
                        );
                        
                        if (chineseVoice) {
                            utterance.voice = chineseVoice;
                            utterance.lang = chineseVoice.lang;
                        } else {
                            utterance.lang = 'zh-CN';
                        }
                        
                        // 当前文本播放完毕后的回调
                        utterance.onend = () => {
                            console.log(`浏览器TTS: 第 ${currentIndex + 1} 遍播放完成`);
                            currentIndex++;
                            // 延迟一小段时间后播放下一遍
                            setTimeout(speakNext, 500);
                        };
                        
                        console.log(`浏览器TTS: 播放第 ${currentIndex + 1}/${repeatCount} 遍`);
                        window.speechSynthesis.speak(utterance);
                    }
                };
                
                // 开始第一次播放
                speakNext();
            } else {
                console.error('浏览器不支持语音合成');
            }
        }

        // ... existing code ...
        ws.onopen = () => {
            console.log('WebSocket连接已建立');
        };
        
        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                
                // 处理语音识别结果
                if (data.type === 'asr_result') {
                    updateRecognitionText(data);
                }
                // 处理语音识别完成事件
                else if (data.type === 'asr_complete') {
                    handleRecognitionComplete(data);
                }
                // 处理计时器完成事件
                else if (data.type === 'timer_completed') {
                    // 计时器完成
                    handleTimerCompleted(data.timer);
                }
                // 添加对聊天响应的处理
                else if (data.type === 'chat_response') {
                    // 隐藏输入指示器
                    typingIndicator.style.display = 'none';
                    
                    if (data.success) {
                        // 如果是临时提示，保存消息ID以便后续更新
                        if (data.isTempPrompt) {
                            console.log('收到临时提示:', data.answer);
                            // 临时提示使用特殊ID，便于后续更新
                            window.tempPromptMessageId = `message-${Date.now()}-temp`;
                            // 添加机器人消息，带有临时标记
                            addMessage(data.answer, 'bot', window.tempPromptMessageId, true);
                            
                            // 保存ID到localStorage，以防页面刷新
                            try {
                                localStorage.setItem('lastTempPromptId', window.tempPromptMessageId);
                                console.log('临时消息ID已保存到localStorage:', window.tempPromptMessageId);
                            } catch (e) {
                                console.error('保存临时消息ID失败:', e);
                            }
                        } else {
                            // 普通回复，直接添加
                            console.log('收到正常回复:', data.answer);
                            const msgElement = addMessage(data.answer, 'bot');
                            
                            // 保存最新的非临时消息ID，以便后续可能的更新
                            window.lastBotMessageId = msgElement.id;
                            console.log('保存最新非临时消息ID:', window.lastBotMessageId);
                            
                            // 初始化版本号
                            window.messageVersions.set(msgElement.id, 1);
                        }
                        
                        // 消息分类标识（可选：如果需要在UI上展示分类）
                        if (data.messageType) {
                            console.log(`消息分类: ${data.messageType}`);
                        }
                        
                        // 如果启用了自动语音
                        if (window.autoSpeakEnabled && !data.isTempPrompt && !window.pendingSynthesis) {
                            // 请求语音合成（临时提示不进行语音合成）
                            console.log('收到新消息，开始语音合成...');
                            requestSpeech(data.answer, window.lastBotMessageId);
                        } else if (window.pendingSynthesis) {
                            console.log('已有语音合成在进行中，暂时跳过本次请求');
                        }
                    } else {
                        // 处理错误
                        addMessage(data.error || '抱歉，处理您的请求时出错了。', 'bot');
                    }
                    
                    // 滚动到底部
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
                // 处理聊天响应更新（更新临时提示为真实响应）
                else if (data.type === 'chat_response_update') {
                    console.log('收到聊天响应更新:', data.answer.substring(0, 50) + '...');
                    
                    if (data.success) {
                        // 判断是否为最终完整响应
                        const isCompleteResponse = data.isComplete === true;
                        console.log('是否为完整响应:', isCompleteResponse);
                        
                        // 确保我们有一个有效的消息ID，即使是之前没有设置的
                        if (!window.tempPromptMessageId) {
                            console.log('未找到临时消息ID，可能是首次更新或ID已被清除');
                            // 寻找最后一个机器人消息作为更新目标
                            const botMessages = document.querySelectorAll('.bot-message');
                            if (botMessages.length > 0) {
                                const lastBotMessage = botMessages[botMessages.length - 1];
                                const messageId = lastBotMessage.getAttribute('data-message-id');
                                window.tempPromptMessageId = messageId;
                                console.log('找到最后一个机器人消息ID:', messageId);
                            }
                        }
                        
                        // 获取消息ID
                        const messageId = window.tempPromptMessageId || window.lastBotMessageId;
                        
                        if (messageId) {
                            // 更新版本号
                            const currentVersion = window.messageVersions.get(messageId) || 0;
                            const newVersion = currentVersion + 1;
                            window.messageVersions.set(messageId, newVersion);
                            
                            // 更新消息内容
                            console.log('更新消息内容, ID:', messageId);
                            updateMessage(messageId, data.answer);
                            console.log('消息更新完成，内容长度:', data.answer.length);
                            
                            // 如果是完整响应且启用了自动语音
                            if (isCompleteResponse && window.autoSpeakEnabled) {
                                // 使用流式文本分段
                                const lastSynthesizedVersion = window.lastSynthesizedVersion.get(messageId) || 0;
                                
                                // 只有当版本更新时才处理
                                if (newVersion > lastSynthesizedVersion) {
                                    console.log('收到完整响应，处理流式语音合成...');
                                    // 更新语音合成版本标记
                                    window.lastSynthesizedVersion.set(messageId, newVersion);
                                    
                                    // 分段处理文本
                                    const segments = window.StreamingHandler.intelligentTextSegmentation(data.answer);
                                    console.log(`文本已分段为${segments.length}个片段，开始语音合成`);
                                    
                                    // 遍历所有分段，依次添加到合成队列
                                    // 使用当前时间作为基准，确保时间戳递增有序
                                    const baseTimestamp = Date.now();
                                    
                                    // 先创建所有时间戳和对应关系，确保顺序正确
                                    const segmentWithTimestamps = segments.map((segment, index) => {
                                        // 为每个片段增加一个递增的时间戳，较早片段的时间戳更小
                                        return {
                                            text: segment,
                                            timestamp: baseTimestamp + index
                                        };
                                    });
                                    
                                    // 按照生成顺序进行排序以确保按照文本顺序合成和播放
                                    segmentWithTimestamps.sort((a, b) => a.timestamp - b.timestamp);
                                    
                                    // 记录排序结果用于调试
                                    console.log("合成顺序:");
                                    segmentWithTimestamps.forEach((item, index) => {
                                        console.log(`#${index+1}: 时间戳: ${item.timestamp}, 自然顺序: ${item.naturalOrder}, 内容: "${item.text.substring(0, 15)}..."`);
                                    });
                                    
                                    // 现在按顺序请求合成
                                    segmentWithTimestamps.forEach((item, index) => {
                                        // 使用较小的延迟，只是为了避免同时发送所有请求
                                        setTimeout(() => {
                                            // 使用当前对话轮次ID
                                            requestSpeech(item.text, true, item.timestamp, window.currentConversationRoundId)
                                                .catch(error => console.error(`分段${index+1}语音合成失败:`, error));
                                            
                                            // 调试信息
                                            if (index === 0) {
                                                console.log(`第一段开始合成: "${item.text.substring(0, 50)}..."`);
                                            }
                                        }, index * 50);
                                    });
                                } else {
                                    console.log(`跳过版本${newVersion}的语音合成，已处理过版本${lastSynthesizedVersion}`);
                                }
                            }
                        } else {
                            console.error('未找到有效的消息ID，无法更新消息');
                        }
                    } else {
                        console.error('聊天响应更新失败:', data.error);
                    }
                }
                // 处理TTS响应
                else if (data.type === 'tts_response') {
                    if (data.success && data.audioUrl) {
                        // 使用StreamingHandler处理TTS响应
                        window.StreamingHandler.handleTTSResponse({
                            success: true,
                            audioUrl: data.audioUrl,
                            text: data.text || ""
                        });
                    } else {
                        console.error('TTS处理失败:', data.error || '未知错误');
                    }
                }
                // 处理语音段落更新
                else if (data.type === 'tts_segment_update') {
                    console.log(`收到语音段落更新: 第${data.task.index}段, 状态: ${data.task.status}, 轮次ID: ${data.task.roundId || '未指定'}`);
                    
                    if (data.task.status === 'completed' && data.task.audioUrl) {
                        // 将音频添加到播放队列，传递轮次ID
                        window.StreamingHandler.addAudioToQueue(data.task.audioUrl, data.task.text, null, data.task.roundId);
                        console.log(`语音段落${data.task.index}已添加到播放队列, 轮次ID: ${data.task.roundId || '未指定'}`);
                    } else if (data.task.status === 'failed') {
                        console.error(`语音段落${data.task.index}合成失败:`, data.task.error);
                    }
                }
                // 处理告警消息
                else if (data.type === 'alarm') {
                    console.log('[Chat告警] 收到告警消息:', data);
                    handleAlarmMessage(data.data);
                }
                // 处理告警解除消息
                else if (data.type === 'alarm_cleared') {
                    console.log('[Chat告警] 收到告警解除消息:', data);
                    handleAlarmClearedMessage(data.data);
                }
                // 处理单点报警消息
                else if (data.type === 'single_point_alarm') {
                    console.log('[Chat告警] 收到单点报警消息:', data);
                    handleAlarmMessage(data.data);
                }
                // 处理单点报警解除消息
                else if (data.type === 'single_point_alarm_cleared') {
                    console.log('[Chat告警] 收到单点报警解除消息:', data);
                    handleAlarmClearedMessage(data.data);
                }
                // 处理多条件告警消息
                else if (data.type === 'multi_condition_alarm') {
                    console.log('[Chat告警] 收到多条件告警消息:', data);
                    handleMultiConditionAlarmMessage(data.data);
                }
                // 处理多条件告警解除消息
                else if (data.type === 'multi_condition_alarm_cleared') {
                    console.log('[Chat告警] 收到多条件告警解除消息:', data);
                    handleMultiConditionAlarmClearedMessage(data.data);
                }
            } catch (error) {
                console.error('解析WebSocket消息失败:', error);
            }
        };
        
        ws.onclose = () => {
            console.log('WebSocket连接已关闭，尝试重连...');
            setTimeout(connectWebSocket, 3000);
        };
        // ... existing code ...

        // 下面的函数已被禁用，不再使用实时流式识别
        /*
        function sendAudioChunkForRecognition(audioBlob) {
            // 函数内容被禁用
        }
        */

        // ... existing code ...

        // 初始化全局变量
        window.currentResponseReader = null;
        window.currentBotMessageElement = null;
        window.currentSynthesisRequests = [];

        // 初始化计时器历史记录功能
        function initTimerHistory() {
            const modal = document.getElementById('timerHistoryModal');
            const btn = document.getElementById('timer-history-button');
            const closeBtn = document.getElementsByClassName('close')[0];
            
            // 如果必要元素不存在，直接返回
            if (!modal || !btn) {
                console.warn('计时器历史模态框或按钮不存在，跳过初始化');
                return;
            }
            
            // 点击计时器历史按钮打开模态框
            btn.onclick = function() {
                loadTimerHistory();
                modal.style.display = 'block';
            }
            
            // 点击关闭按钮关闭模态框
            if (closeBtn) {
            closeBtn.onclick = function() {
                modal.style.display = 'none';
                }
            } else {
                console.warn('模态框关闭按钮不存在');
            }
            
            // 点击模态框外部关闭模态框
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            }
        }
        
        // 加载计时器历史记录
        function loadTimerHistory() {
            console.log('加载计时器历史记录');
            const tableBody = document.getElementById('timerHistoryTableBody');
            
            if (!tableBody) {
                console.error('计时器历史记录表格不存在');
                return;
            }
            
            tableBody.innerHTML = '<tr><td colspan="3" class="no-history">加载中...</td></tr>';
            
            fetch('/api/timer-history')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP错误! 状态码: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('获取计时器历史记录成功:', data);
                    
                    if (data.success && data.data && data.data.length > 0) {
                        // 清空表格
                        tableBody.innerHTML = '';
                        
                        // 添加历史记录
                        data.data.forEach(record => {
                            const row = document.createElement('tr');
                            
                            // 格式化时间
                            const completedAt = new Date(record.completed_at);
                            const formattedDate = `${completedAt.getFullYear()}-${(completedAt.getMonth()+1).toString().padStart(2, '0')}-${completedAt.getDate().toString().padStart(2, '0')} ${completedAt.getHours().toString().padStart(2, '0')}:${completedAt.getMinutes().toString().padStart(2, '0')}:${completedAt.getSeconds().toString().padStart(2, '0')}`;
                            
                            row.innerHTML = `
                                <td>${record.title || '--'}</td>
                                <td>${record.message || '--'}</td>
                                <td>${formattedDate}</td>
                            `;
                            tableBody.appendChild(row);
                        });
                    } else {
                        tableBody.innerHTML = '<tr><td colspan="3" class="no-history">没有找到计时器历史记录</td></tr>';
                    }
                })
                .catch(error => {
                    console.error('获取计时器历史记录失败:', error);
                    tableBody.innerHTML = `<tr><td colspan="3" class="no-history">加载失败: ${error.message}</td></tr>`;
                });
        }

        // 全局设置变量 - 已在页面头部内联脚本中初始化
        // 注: 原始声明已移到head中的内联脚本，解决变量初始化顺序问题
        // timerSettings包含:
        // - repeatCount: 提醒重复次数(默认2)
        // - intervalSeconds: 间隔秒数(默认5)
        // - autoStopOnResponse: 有响应时停止提醒(默认true)
        // - audioLoopCount: 音频循环次数(默认1)
        // - audioLoopInterval: 音频循环间隔(默认500ms)
        
        // 定时器相关变量
        let activeTimerReminders = new Map(); // 保存活动的提醒计时器
        let lastUserInteractionTime = Date.now(); // 上次用户交互时间
        
        // DOM加载完成后初始化设置面板
        document.addEventListener('DOMContentLoaded', () => {
            // ... existing code ...
            
            // 初始化设置面板
            initSettingsPanel();
        });
        
        // 初始化设置面板
        function initSettingsPanel() {
            console.log('开始初始化设置面板...');
            
            const toggleSettingsBtn = document.getElementById('toggleSettings');
            console.log('计时器设置按钮元素:', toggleSettingsBtn);
            
            const settingsModal = document.getElementById('timerSettingsModal');
            console.log('设置模态窗口元素:', settingsModal);
            
            const closeBtn = document.getElementById('closeTimerSettings');
            const saveBtn = document.getElementById('saveTimerSettings');
            const testBtn = document.getElementById('testAudioLoop');
            
            const repeatCountInput = document.getElementById('reminderRepeatCount');
            const intervalInput = document.getElementById('reminderInterval');
            const autoStopSelect = document.getElementById('autoStopReminders');
            const audioLoopCountInput = document.getElementById('audioLoopCount');
            const audioLoopIntervalInput = document.getElementById('audioLoopInterval');
            
            // 从localStorage加载设置
            loadSettings();
            
            // 设置初始值
            if (repeatCountInput) repeatCountInput.value = timerSettings.repeatCount;
            if (intervalInput) intervalInput.value = timerSettings.intervalSeconds;
            if (autoStopSelect) autoStopSelect.value = timerSettings.autoStopOnResponse.toString();
            if (audioLoopCountInput) audioLoopCountInput.value = timerSettings.audioLoopCount || 1;
            if (audioLoopIntervalInput) audioLoopIntervalInput.value = timerSettings.audioLoopInterval || 500;
            
            // 点击设置按钮打开模态窗口
            if (toggleSettingsBtn && settingsModal) {
                console.log('正在添加设置按钮点击事件...');
                toggleSettingsBtn.onclick = function() {
                    console.log('设置按钮被点击');
                    settingsModal.style.display = 'block';
                }
            } else {
                console.error('设置按钮或模态窗口元素不存在，无法添加点击事件');
            }
            
            // 点击关闭按钮
            if (closeBtn) {
                closeBtn.onclick = function() {
                    console.log('关闭按钮被点击');
                    if (settingsModal) settingsModal.style.display = 'none';
                }
            }
            
            // 点击模态窗口外部也可关闭
            if (settingsModal) {
                window.onclick = function(event) {
                    if (event.target === settingsModal) {
                        console.log('点击了模态窗口外部');
                        settingsModal.style.display = 'none';
                    }
                }
            }
            
            // 保存设置
            if (saveBtn) {
                saveBtn.onclick = function() {
                    console.log('保存按钮被点击');
                    // 直接调用本地保存函数，避免调用外部库中的函数
                    try {
                        const repeatCountInput = document.getElementById('reminderRepeatCount');
                        const intervalInput = document.getElementById('reminderInterval');
                        const autoStopSelect = document.getElementById('autoStopReminders');
                        const audioLoopCountInput = document.getElementById('audioLoopCount');
                        const audioLoopIntervalInput = document.getElementById('audioLoopInterval');
                        
                        // 更新设置
                        timerSettings.repeatCount = Math.max(1, Math.min(10, parseInt(repeatCountInput.value) || 2));
                        timerSettings.intervalSeconds = Math.max(1, Math.min(60, parseInt(intervalInput.value) || 5));
                        timerSettings.autoStopOnResponse = autoStopSelect.value === 'true';
                        timerSettings.audioLoopCount = Math.max(1, Math.min(5, parseInt(audioLoopCountInput.value) || 1));
                        timerSettings.audioLoopInterval = Math.max(0, Math.min(5000, parseInt(audioLoopIntervalInput.value) || 500));
                        
                        // 更新输入框值（防止无效输入）
                        repeatCountInput.value = timerSettings.repeatCount;
                        intervalInput.value = timerSettings.intervalSeconds;
                        audioLoopCountInput.value = timerSettings.audioLoopCount;
                        audioLoopIntervalInput.value = timerSettings.audioLoopInterval;
                        
                        // 保存到localStorage
                        localStorage.setItem('timerSettings', JSON.stringify(timerSettings));
                        console.log('计时器设置已成功保存:', timerSettings);
                        
                        // 关闭模态窗口
                        if (settingsModal) settingsModal.style.display = 'none';
                        
                        // 显示保存成功的通知
                        showNotification('设置已保存');
                    } catch (error) {
                        console.error('保存设置失败:', error);
                        showNotification('保存设置失败: ' + error.message);
                    }
                }
            }
            
            // 测试循环播放
            if (testBtn) {
                testBtn.onclick = function() {
                    console.log('测试按钮被点击');
                    // 不再调用外部的saveSettings()函数，避免错误
                    // 直接测试音频循环播放
                    testAudioLoopPlayback();
                }
            }
            
            // 用户输入消息时记录交互时间
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.addEventListener('input', () => {
                    lastUserInteractionTime = Date.now();
                    // 如果用户开始输入，停止所有提醒
                    if (timerSettings.autoStopOnResponse && messageInput.value.trim().length > 0) {
                        stopAllTimerReminders();
                    }
                });
            }
            
            console.log('设置面板初始化完成');
        }
        
        // 从localStorage加载设置
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('timerSettings');
                if (savedSettings) {
                    const parsedSettings = JSON.parse(savedSettings);
                    timerSettings.repeatCount = parsedSettings.repeatCount || 2;
                    timerSettings.intervalSeconds = parsedSettings.intervalSeconds || 5;
                    timerSettings.autoStopOnResponse = parsedSettings.autoStopOnResponse !== false; // 默认为true
                    timerSettings.audioLoopCount = parsedSettings.audioLoopCount || 1;
                    timerSettings.audioLoopInterval = parsedSettings.audioLoopInterval || 500;
                }
            } catch (error) {
                console.error('加载设置失败:', error);
            }
        }
        
        // 保存设置到localStorage
        function saveSettings() {
            try {
                const repeatCountInput = document.getElementById('reminderRepeatCount');
                const intervalInput = document.getElementById('reminderInterval');
                const autoStopSelect = document.getElementById('autoStopReminders');
                const audioLoopCountInput = document.getElementById('audioLoopCount');
                const audioLoopIntervalInput = document.getElementById('audioLoopInterval');
                
                // 更新设置
                timerSettings.repeatCount = Math.max(1, Math.min(10, parseInt(repeatCountInput.value) || 2));
                timerSettings.intervalSeconds = Math.max(1, Math.min(60, parseInt(intervalInput.value) || 5));
                timerSettings.autoStopOnResponse = autoStopSelect.value === 'true';
                timerSettings.audioLoopCount = Math.max(1, Math.min(5, parseInt(audioLoopCountInput.value) || 1));
                timerSettings.audioLoopInterval = Math.max(0, Math.min(5000, parseInt(audioLoopIntervalInput.value) || 500));
                
                // 更新输入框值（防止无效输入）
                repeatCountInput.value = timerSettings.repeatCount;
                intervalInput.value = timerSettings.intervalSeconds;
                audioLoopCountInput.value = timerSettings.audioLoopCount;
                audioLoopIntervalInput.value = timerSettings.audioLoopInterval;
                
                // 保存到localStorage
                localStorage.setItem('timerSettings', JSON.stringify(timerSettings));
                console.log('计时器设置已保存:', timerSettings);
            } catch (error) {
                console.error('保存设置失败:', error);
            }
        }
        
        // 设置计时器重复提醒
        function setupTimerReminders(timerId, message) {
            // 如果已经有这个计时器的提醒，先清除
            if (activeTimerReminders.has(timerId)) {
                clearTimeout(activeTimerReminders.get(timerId));
            }
            
            // 当前已播放了第1次，所以从2开始计数
            let repeatCount = 2;
            
            const scheduleNextReminder = () => {
                if (repeatCount <= timerSettings.repeatCount) {
                    // 计算上次用户交互到现在的时间
                    const timeSinceLastInteraction = Date.now() - lastUserInteractionTime;
                    
                    // 如果设置为在用户响应后停止，且用户已有交互，则不再提醒
                    if (timerSettings.autoStopOnResponse && timeSinceLastInteraction < timerSettings.intervalSeconds * 1000) {
                        console.log('检测到用户交互，停止后续提醒');
                        return;
                    }
                    
                    // 安排下一次提醒
                    const timerId = setTimeout(() => {
                        console.log(`播放第${repeatCount}/${timerSettings.repeatCount}次提醒`);
                        playWithAlertSound(message);
                        
                        repeatCount++;
                        if (repeatCount <= timerSettings.repeatCount) {
                            scheduleNextReminder();
                        } else {
                            activeTimerReminders.delete(timerId);
                        }
                    }, timerSettings.intervalSeconds * 1000);
                    
                    activeTimerReminders.set(timerId, timerId);
                }
            };
            
            // 开始安排提醒
            scheduleNextReminder();
        }
        
        // 停止所有计时器提醒
        function stopAllTimerReminders() {
            console.log('停止所有计时器提醒');
            activeTimerReminders.forEach((timeoutId) => {
                clearTimeout(timeoutId);
            });
            activeTimerReminders.clear();
        }

        // 测试音频循环播放
        function testAudioLoopPlayback() {
            const testMessage = "这是一条测试消息，用于验证循环播放设置。";
            const alertSoundUrl = '/audio/Broadcastalert.mp3';
            
            // 检查是否有AudioAutoplay模块
            if (window.AudioAutoplay) {
                showNotification('正在测试音频循环播放...');
                
                // 使用循环设置
                const options = {
                    loopCount: timerSettings.audioLoopCount,
                    loopInterval: timerSettings.audioLoopInterval
                };
                
                console.log(`测试循环播放: 循环${options.loopCount}次，间隔${options.loopInterval}ms`);
                
                // 播放提示音
                window.AudioAutoplay.playLoop(alertSoundUrl, options, () => {
                    showNotification('音频循环播放测试完成');
                    
                    // 延迟1秒后播放消息测试
                    setTimeout(() => {
                        speakMessage(testMessage);
                    }, 1000);
                });
            } else {
                console.error('AudioAutoplay模块未加载，无法测试');
                showNotification('无法测试音频循环播放，请确保音频模块已加载');
            }
        }

        // 显示通知
        function showNotification(message) {
            const notificationEl = document.getElementById('notification');
            if (notificationEl) {
                notificationEl.textContent = message;
                notificationEl.style.display = 'block';
                
                // 3秒后隐藏
                setTimeout(() => {
                    notificationEl.style.display = 'none';
                }, 3000);
            } else {
                // 如果没有通知元素，创建一个临时通知
                const tempNotification = document.createElement('div');
                tempNotification.textContent = message;
                tempNotification.style.position = 'fixed';
                tempNotification.style.top = '20px';
                tempNotification.style.right = '20px';
                tempNotification.style.backgroundColor = '#4CAF50';
                tempNotification.style.color = 'white';
                tempNotification.style.padding = '15px';
                tempNotification.style.borderRadius = '4px';
                tempNotification.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
                tempNotification.style.zIndex = '1000';
                
                document.body.appendChild(tempNotification);
                
                // 3秒后移除
                setTimeout(() => {
                    if (document.body.contains(tempNotification)) {
                        document.body.removeChild(tempNotification);
                    }
                }, 3000);
            }
        }

        // 页面加载时立即尝试解锁音频
        document.addEventListener('DOMContentLoaded', function() {
            console.log('页面加载完成，尝试初始化音频解锁');
            
            // 尝试直接设置计时器设置按钮的点击事件
            const settingsBtn = document.getElementById('toggleSettings');
            const settingsModal = document.getElementById('timerSettingsModal');
            
            if (settingsBtn && settingsModal) {
                console.log('找到计时器设置按钮和模态窗口，添加点击事件');
                
                // 使用直接赋值的方式绑定onclick事件
                settingsBtn.onclick = function() {
                    console.log('计时器设置按钮被点击');
                    settingsModal.style.display = 'block';
                };
                
                // 为关闭按钮添加事件
                const closeBtn = document.getElementById('closeTimerSettings');
                if (closeBtn) {
                    closeBtn.onclick = function() {
                        settingsModal.style.display = 'none';
                    };
                }
                
                // 点击模态窗口外部关闭
                window.onclick = function(event) {
                    if (event.target === settingsModal) {
                        settingsModal.style.display = 'none';
                    }
                };
            } else {
                console.error('计时器设置按钮或模态窗口不存在，无法绑定点击事件');
                if (!settingsBtn) console.error('找不到计时器设置按钮');
                if (!settingsModal) console.error('找不到计时器设置模态窗口');
            }
            
            // 检查AudioAutoplay模块是否存在
            if (window.AudioAutoplay) {
                // 获取初始状态
                const initialStatus = window.AudioAutoplay.getStatus();
                console.log('初始音频状态:', initialStatus);
                
                // 主动尝试解锁
                window.AudioAutoplay.unlock();
                
                // 添加一个用户交互事件监听器，以帮助解锁
                const unlockWithInteraction = () => {
                    if (!window.AudioAutoplay.isFullyUnlocked()) {
                        console.log('用户交互，尝试解锁音频播放');
                        window.AudioAutoplay.unlock();
                        
                        // 检查解锁状态
                        setTimeout(() => {
                            const status = window.AudioAutoplay.getStatus();
                            console.log('交互后音频状态:', status);
                            
                            if (!status.fullyUnlocked) {
                                console.log('通过交互未能完全解锁，显示手动解锁按钮');
                                window.AudioAutoplay.showUnlockButton();
                            }
                        }, 500);
                    }
                };
                
                // 添加事件监听器
                document.addEventListener('click', unlockWithInteraction, { once: false });
                document.addEventListener('touchstart', unlockWithInteraction, { once: false });
                document.addEventListener('keydown', unlockWithInteraction, { once: false });
                
                // 2秒后检查解锁状态
                setTimeout(function() {
                    const status = window.AudioAutoplay.getStatus();
                    console.log('2秒后音频状态:', status);
                    
                    // 如果还未解锁成功，显示手动解锁按钮
                    if (!status.fullyUnlocked && !status.unlocked) {
                        console.log('自动解锁失败，显示手动解锁按钮');
                        window.AudioAutoplay.showUnlockButton();
                    }
                }, 2000);
            } else {
                console.error('AudioAutoplay模块未能正确加载！');
            }
        });

        // 发送聊天消息
        function sendChatRequest(message) {
            // 停止当前所有音频播放
            stopAllAudio();
            
            // 显示用户消息
            const msgId = addMessage(message, 'user');
            
            // 保存到会话历史
            if (!currentConversationRoundId) {
                currentConversationRoundId = generateConversationRoundId();
                console.log('生成新的会话轮次ID:', currentConversationRoundId);
            }
            
            // 检查是否是命令消息
            if (typeof window.handleCommandMessage === 'function' && window.handleCommandMessage(message)) {
                // 如果是命令消息且已处理，直接返回
                return;
            }
            
            // 显示输入指示器
            typingIndicator.style.display = 'block';
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // 清空输入框
            messageInput.value = '';
            
            // 格式化请求数据
            const requestData = {
                type: 'chat_request',
                message: message,
                requestId: `req_${Date.now()}`,
                userId: getUserId(),
                files: selectedFiles.length > 0 ? selectedFiles : []
            };
            
            // 发送WebSocket消息
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('已发送聊天请求:', requestData);
                ws.send(JSON.stringify(requestData));
            } else {
                console.error('WebSocket未连接，无法发送消息');
                addMessage('抱歉，连接已断开，无法发送消息。正在尝试重连...', 'bot');
                
                // 尝试重新连接
                connectWebSocket();
            }
            
            // 清空已选文件
            clearSelectedFiles();
        }

        // 提交表单处理
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            
            // 停止当前所有音频播放
            stopAllAudio();
            
            const message = messageInput.value.trim();
            if (message) {
                sendChatRequest(message);
            }
        });
        
        // 发送按钮点击事件
        sendButton.addEventListener('click', () => {
            // 停止当前所有音频播放
            stopAllAudio();
            
            const message = messageInput.value.trim();
            if (message) {
                sendChatRequest(message);
            }
        });
    </script>
    
    <!-- 添加音频自动播放模块 -->
    <!-- <script src="/js/audio-autoplay.js"></script> -->
    
    <!-- 添加流式处理器脚本 -->
    <script src="/js/streaming-handler.js"></script>
    
    <!-- 确保processNextAudio函数存在，避免未定义错误 -->
    <script>
        // 确保processNextAudio函数存在，即使是空实现
        if (typeof processNextAudio === 'undefined') {
            window.processNextAudio = function() {
                console.log('processNextAudio函数占位实现');
            };
        }
        
        // 添加enhanceSaveButton函数空实现
        if (typeof enhanceSaveButton === 'undefined') {
            window.enhanceSaveButton = function() {
                console.log('enhanceSaveButton函数占位实现');
                return function() {};
            };
        }
        
        // 添加ensureBasicVariables函数空实现
        if (typeof ensureBasicVariables === 'undefined') {
            window.ensureBasicVariables = function() {
                console.log('ensureBasicVariables函数占位实现');
            };
        }
    </script>
    
    <!-- 集成音频自动播放功能 -->
    <script>
        // 页面加载时立即尝试解锁音频
        document.addEventListener('DOMContentLoaded', function() {
            console.log('页面加载完成，尝试初始化音频解锁');
            
            // 尝试直接设置计时器设置按钮的点击事件
            const settingsBtn = document.getElementById('toggleSettings');
            const settingsModal = document.getElementById('timerSettingsModal');
            
            if (settingsBtn && settingsModal) {
                console.log('找到计时器设置按钮和模态窗口，添加点击事件');
                
                // 使用直接赋值的方式绑定onclick事件
                settingsBtn.onclick = function() {
                    console.log('计时器设置按钮被点击');
                    settingsModal.style.display = 'block';
                };
                
                // 为关闭按钮添加事件
                const closeBtn = document.getElementById('closeTimerSettings');
                if (closeBtn) {
                    closeBtn.onclick = function() {
                        settingsModal.style.display = 'none';
                    };
                }
                
                // 点击模态窗口外部关闭
                window.onclick = function(event) {
                    if (event.target === settingsModal) {
                        settingsModal.style.display = 'none';
                    }
                };
            } else {
                console.error('计时器设置按钮或模态窗口不存在，无法绑定点击事件');
                if (!settingsBtn) console.error('找不到计时器设置按钮');
                if (!settingsModal) console.error('找不到计时器设置模态窗口');
            }
            
            // 检查AudioAutoplay模块是否存在
            if (window.AudioAutoplay) {
                // 获取初始状态
                const initialStatus = window.AudioAutoplay.getStatus();
                console.log('初始音频状态:', initialStatus);
                
                // 主动尝试解锁
                window.AudioAutoplay.unlock();
                
                // 添加一个用户交互事件监听器，以帮助解锁
                const unlockWithInteraction = () => {
                    if (!window.AudioAutoplay.isFullyUnlocked()) {
                        console.log('用户交互，尝试解锁音频播放');
                        window.AudioAutoplay.unlock();
                        
                        // 检查解锁状态
                        setTimeout(() => {
                            const status = window.AudioAutoplay.getStatus();
                            console.log('交互后音频状态:', status);
                            
                            if (!status.fullyUnlocked) {
                                console.log('通过交互未能完全解锁，显示手动解锁按钮');
                                window.AudioAutoplay.showUnlockButton();
                            }
                        }, 500);
                    }
                };
                
                // 添加事件监听器
                document.addEventListener('click', unlockWithInteraction, { once: false });
                document.addEventListener('touchstart', unlockWithInteraction, { once: false });
                document.addEventListener('keydown', unlockWithInteraction, { once: false });
                
                // 2秒后检查解锁状态
                setTimeout(function() {
                    const status = window.AudioAutoplay.getStatus();
                    console.log('2秒后音频状态:', status);
                    
                    // 如果还未解锁成功，显示手动解锁按钮
                    if (!status.fullyUnlocked && !status.unlocked) {
                        console.log('自动解锁失败，显示手动解锁按钮');
                        window.AudioAutoplay.showUnlockButton();
                    }
                }, 2000);
            } else {
                console.error('AudioAutoplay模块未能正确加载！');
            }
        });
        
        // 保存原始的处理函数
        const originalProcessNextAudio = processNextAudio;
        
        // 完全覆盖音频处理函数，使用AudioAutoplay模块
        processNextAudio = async function() {
            // 如果没有待处理的URL，直接返回
            if (pendingAudioUrls.length === 0) return;
            
            // 如果已经在处理中，直接返回
            if (isProcessingAudio) return;
            
            // 标记正在处理
            isProcessingAudio = true;
            
            try {
                // 获取第一个URL进行处理
                const url = pendingAudioUrls.shift();
                
                // 尝试使用AudioAutoplay模块播放
                if (window.AudioAutoplay) {
                    console.log('使用AudioAutoplay模块播放音频:', url);
                    window.AudioAutoplay.play(url, () => {
                        console.log('AudioAutoplay播放完成:', url);
                        processedUrls.add(url);
                        totalAudioPlayed++;
                        
                        // 处理完毕，标记为非处理状态
                        isProcessingAudio = false;
                        
                        // 处理下一个
                        processNextAudio();
                    });
                } else {
                    // 如果AudioAutoplay不可用，回退到原始方法
                    console.warn('AudioAutoplay模块不可用，使用原始音频处理函数');
                    originalProcessNextAudio();
                }
            } catch (error) {
                console.error('处理音频出错:', error);
                isProcessingAudio = false;
                processNextAudio(); // 尝试处理下一个
            }
        };
    </script>
    
    <!-- 添加音频协调器脚本 -->
    <script src="/js/audio-playback-coordinator.js"></script>
    
    <!-- 添加计时器设置修复脚本 -->
    <script src="/js/chat-settings-fix.js"></script>
    <script src="/js/timer-settings-fix.js"></script>
    <!-- 添加音频URL处理修复脚本 -->
    <script src="/js/chat-audio-url-fix.js"></script>
    <!-- 添加对话框语音修复脚本(放在最后确保优先级最高) -->
    <script src="/js/chat-dialog-audio-fix.js"></script>
    <!-- 添加整合修复脚本(最终解决方案) -->
    <script src="/js/timer-audio-integration-fix.js"></script>
    <!-- 在其他类似的脚本引用之后添加我们的表单修复脚本 -->
    <script src="/js/timer-settings-form-fix.js"></script>

    <!-- 加载脚本 -->
    <script src="/js/streamUtils.js"></script>
    <script src="/js/streaming-handler.js"></script>
    <script src="/js/audio-playback-coordinator.js"></script>
    <script src="/js/chat-audio-url-fix.js"></script>
    <script src="/js/chat-audio-log.js"></script>

    <!-- 添加对话历史和缓存模块 -->
    <script>
        // 对话历史记录管理
        window.ChatHistory = {
            // 保存当前对话到历史记录
            saveCurrentChat: function() {
                // 获取当前对话的消息元素
                const messages = document.querySelectorAll('.message');
                if (messages.length <= 1) { // 如果只有欢迎消息或没有消息，不保存
                    console.log('当前对话无内容，不保存');
                    return null;
                }
                
                // 构建对话记录
                const chatData = {
                    id: 'chat_' + Date.now(),
                    date: new Date().toISOString(),
                    title: this.generateChatTitle(),
                    messages: [],
                    // 保存三个ID变量
                    tempPromptMessageId: window.tempPromptMessageId || null,
                    lastBotMessageId: window.lastBotMessageId || null,
                    conversationId: conversationId || null,
                    currentRoundId: window.currentConversationRoundId || null
                };
                
                // 收集所有消息
                messages.forEach(msg => {
                    const sender = msg.classList.contains('user-message') ? 'user' : 'bot';
                    const content = msg.querySelector('.message-text') ? msg.querySelector('.message-text').textContent : '';
                    const messageId = msg.id;
                    
                    chatData.messages.push({
                        id: messageId,
                        sender: sender,
                        content: content
                    });
                });
                
                // 获取已有的历史记录
                let chatHistory = this.getAllChats();
                
                // 添加新记录
                chatHistory.unshift(chatData); // 添加到最前面
                
                // 如果历史记录超过50条，删除旧的
                if (chatHistory.length > 50) {
                    chatHistory = chatHistory.slice(0, 50);
                }
                
                // 保存到localStorage
                localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                console.log('已保存当前对话到历史记录，ID:', chatData.id);
                
                return chatData;
            },
            
            // 生成对话标题（使用第一条用户消息的前20个字符）
            generateChatTitle: function() {
                const userMessages = document.querySelectorAll('.user-message');
                if (userMessages.length > 0) {
                    const firstUserMsg = userMessages[0].querySelector('.message-text');
                    if (firstUserMsg) {
                        const content = firstUserMsg.textContent.trim();
                        return content.length > 20 ? content.substring(0, 20) + '...' : content;
                    }
                }
                return '新对话 ' + new Date().toLocaleString();
            },
            
            // 获取所有历史对话
            getAllChats: function() {
                const chatHistoryStr = localStorage.getItem('chatHistory');
                return chatHistoryStr ? JSON.parse(chatHistoryStr) : [];
            },
            
            // 获取指定ID的历史对话
            getChat: function(chatId) {
                const chatHistory = this.getAllChats();
                return chatHistory.find(chat => chat.id === chatId);
            },
            
            // 删除指定ID的历史对话
            deleteChat: function(chatId) {
                let chatHistory = this.getAllChats();
                chatHistory = chatHistory.filter(chat => chat.id !== chatId);
                localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                console.log('已删除历史对话，ID:', chatId);
                return chatHistory;
            },
            
            // 加载历史对话到当前界面
            loadChat: function(chatId) {
                const chatData = this.getChat(chatId);
                if (!chatData) {
                    console.error('未找到指定ID的历史对话:', chatId);
                    return false;
                }
                
                // 清空当前对话
                chatMessages.innerHTML = '';
                
                // 恢复消息
                chatData.messages.forEach(msg => {
                    const messageEl = addMessage(msg.content, msg.sender);
                    // 确保使用原始消息ID
                    if (msg.id) {
                        messageEl.id = msg.id;
                    }
                });
                
                // 恢复对话相关的ID变量
                window.tempPromptMessageId = chatData.tempPromptMessageId;
                window.lastBotMessageId = chatData.lastBotMessageId;
                conversationId = chatData.conversationId;
                window.currentConversationRoundId = chatData.currentRoundId;
                
                // 更新localStorage中的会话ID
                if (conversationId) {
                    localStorage.setItem('lastSessionId', conversationId);
                    localStorage.setItem('lastSessionDate', getCurrentDateString());
                }
                
                // 滚动到底部
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.log('已加载历史对话，ID:', chatId, '会话ID:', conversationId);
                
                return true;
            },
            
            // 更新历史对话下拉菜单
            updateHistoryDropdown: function() {
                const historyDropdown = document.getElementById('historyDropdown');
                const chatHistory = this.getAllChats();
                
                // 清空下拉菜单
                historyDropdown.innerHTML = '';
                
                if (chatHistory.length === 0) {
                    const noHistory = document.createElement('div');
                    noHistory.className = 'no-history';
                    noHistory.textContent = '暂无历史对话';
                    historyDropdown.appendChild(noHistory);
                    return;
                }
                
                // 添加历史对话项
                chatHistory.forEach(chat => {
                    const historyItem = document.createElement('a');
                    historyItem.href = '#';
                    historyItem.setAttribute('data-id', chat.id);
                    historyItem.className = 'history-item';
                    
                    // 创建预览文本
                    const preview = document.createElement('span');
                    preview.className = 'preview';
                    preview.textContent = chat.title;
                    
                    // 创建日期文本
                    const date = document.createElement('span');
                    date.className = 'date';
                    date.textContent = new Date(chat.date).toLocaleString();
                    
                    historyItem.appendChild(preview);
                    historyItem.appendChild(date);
                    
                    // 添加点击事件
                    historyItem.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.loadChat(chat.id);
                        // 隐藏下拉菜单
                        document.getElementById('historyDropdown').style.display = 'none';
                    });
                    
                    historyDropdown.appendChild(historyItem);
                });
            }
        };
        
        // 页面加载完成后初始化对话历史功能
        document.addEventListener('DOMContentLoaded', function() {
            // 更新历史对话下拉菜单
            window.ChatHistory.updateHistoryDropdown();
            
            // 添加新对话按钮点击事件
            const newChatButton = document.getElementById('newChatButton');
            if (newChatButton) {
                newChatButton.addEventListener('click', function() {
                    // 保存当前对话到历史记录
                    const savedChat = window.ChatHistory.saveCurrentChat();
                    
                    // 清空当前对话
                    resetConversation();
                    
                    // 重置三个ID变量
                    window.tempPromptMessageId = null;
                    window.lastBotMessageId = null;
                    
                    // 重置全局变量
                    conversationId = '';
                    window.currentConversationRoundId = null;
                    
                    // 【修复】重置localStorage中的所有对话ID相关项目
                    localStorage.removeItem('lastSessionId');
                    localStorage.removeItem('lastTempPromptId');
                    
                    // 【新增】调用API清空所有分类的对话ID
                    fetch('/api/chat/clear-conversations', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    })
                    .then(response => response.json())
                    .then(result => {
                        if (result.success) {
                            console.log('✅ 所有分类的对话ID已清空');
                        } else {
                            console.warn('⚠️ 清空分类对话ID失败:', result.message);
                        }
                    })
                    .catch(error => {
                        console.error('❌ 调用清空对话ID API失败:', error);
                    });
                    
                    // 生成新的会话ID
                    checkAndUpdateConversationId();
                    
                    // 更新历史对话下拉菜单
                    window.ChatHistory.updateHistoryDropdown();
                    
                    console.log('✅ 已开始新对话，所有对话ID已清空，新会话ID:', conversationId);
                });
            }
            
            // 添加历史对话按钮点击事件
            const historyButton = document.getElementById('historyButton');
            if (historyButton) {
                historyButton.addEventListener('click', function() {
                    const historyDropdown = document.getElementById('historyDropdown');
                    // 切换下拉菜单显示状态
                    if (historyDropdown.style.display === 'block') {
                        historyDropdown.style.display = 'none';
                    } else {
                        historyDropdown.style.display = 'block';
                    }
                });
            }
            
            // 点击页面空白处关闭下拉菜单
            document.addEventListener('click', function(event) {
                const historyDropdown = document.getElementById('historyDropdown');
                const historyButton = document.getElementById('historyButton');
                
                if (!historyButton.contains(event.target) && !historyDropdown.contains(event.target)) {
                    historyDropdown.style.display = 'none';
                }
            });
            
            // 在页面关闭/刷新前保存当前对话
            window.addEventListener('beforeunload', function() {
                // 保存当前对话到历史记录
                window.ChatHistory.saveCurrentChat();
            });
        });
    </script>
    <script src="/js/chat.js"></script>
    <script src="/js/modbus.js"></script>
    <script>
        // 播放告警声音
        function playAlarmSound(alarmMessages = []) {
            console.log('[告警调试] 播放告警声音，告警内容:', alarmMessages);
            
            try {
                // 检查是否有告警消息
                if (!alarmMessages || alarmMessages.length === 0) {
                    console.log('[告警调试] 没有告警消息，不播放声音');
                    return;
                }
                
                // 如果已经有告警在播放，只更新活动告警列表并返回
                if (window.alarmPlayingState.isPlaying) {
                    console.log('[告警调试] 已有告警在播放，更新活动告警列表');
                    
                    // 更新活动告警列表，避免重复
                    alarmMessages.forEach(msg => {
                        if (!window.alarmPlayingState.activeAlarms.includes(msg)) {
                            window.alarmPlayingState.activeAlarms.push(msg);
                            // 记录首次触发时间
                            if (!window.alarmPlayingState.alarmFirstTriggerTime[msg]) {
                                window.alarmPlayingState.alarmFirstTriggerTime[msg] = new Date().toISOString();
                            }
                        }
                    });
                    
                    return;
                }
                
                // 设置为正在播放状态
                window.alarmPlayingState.isPlaying = true;
                window.alarmPlayingState.activeAlarms = [...alarmMessages];
                window.alarmPlayingState.loopCounter = 0;
                
                // 记录首次触发时间
                alarmMessages.forEach(msg => {
                    if (!window.alarmPlayingState.alarmFirstTriggerTime[msg]) {
                        window.alarmPlayingState.alarmFirstTriggerTime[msg] = new Date().toISOString();
                    }
                });
                
                // 开始播放告警序列
                playAlarmSequence();
                
                // 显示告警通知
                showAlarmNotifications(alarmMessages);
                
            } catch (error) {
                console.error('[告警调试] 播放告警声音失败:', error);
                // 即使播放声音失败，也要显示告警信息
                try {
                    const alarmsText = alarmMessages.join(', ');
                    showWarning(`<strong>告警触发!</strong> ${alarmsText} (音频播放失败)`, 8000);
                } catch (e) {
                    console.error('[告警调试] 显示告警信息也失败了:', e);
                }
            }
        }

        // 播放告警序列
        function playAlarmSequence() {
            if (window.alarmPlayingState.paused) {
                console.log('[告警调试] 告警已暂停，不播放');
                return;
            }
            
            if (window.alarmPlayingState.activeAlarms.length === 0) {
                console.log('[告警调试] 没有活动告警，停止播放');
                window.alarmPlayingState.isPlaying = false;
                window.alarmPlayingState.nextAlarmTime = null;
                return;
            }
            
            console.log('[告警调试] 开始告警播放序列，循环次数:', window.alarmPlayingState.loopCounter);
            
            const currentAlarms = [...window.alarmPlayingState.activeAlarms];
            
            // 更新告警状态
            window.alarmPlayingState.alarmCount++;
            window.alarmPlayingState.nextAlarmTime = new Date(Date.now() + 300000); // 5分钟后
            
            // 【修复】播放提示音 - 使用正确的路径和更好的错误处理
            console.log('[告警调试] 播放告警提示音 Broadcastalert.mp3');
            const audio = new Audio('/audio/Broadcastalert.mp3');
            audio.volume = 0.8;
            
            // 添加音频加载事件监听
            audio.addEventListener('loadstart', () => {
                console.log('[告警调试] 开始加载提示音文件');
            });
            
            audio.addEventListener('canplay', () => {
                console.log('[告警调试] 提示音文件可以播放');
            });
            
            audio.addEventListener('error', (e) => {
                console.error('[告警调试] 提示音加载失败:', e);
                console.error('[告警调试] 音频错误详情:', audio.error);
                // 即使提示音失败，也继续播放告警内容
                playAlarmText(currentAlarms);
            });
            
            audio.onended = () => {
                console.log('[告警调试] 提示音播放完成');
                // 播放告警内容
                playAlarmText(currentAlarms);
            };
            
            // 尝试播放提示音
            audio.play().then(() => {
                console.log('[告警调试] 提示音开始播放');
            }).catch(err => {
                console.warn('[告警调试] 提示音自动播放被阻止:', err);
                // 即使提示音失败，也继续播放告警内容
                playAlarmText(currentAlarms);
            });
        }

        // 【新增】播放告警文本的独立函数
        function playAlarmText(alarmTexts) {
            try {
                console.log('[告警调试] 开始播放告警文本，数量:', alarmTexts.length);
                
                // 检查浏览器是否支持语音合成
                if (!window.speechSynthesis) {
                    console.warn('[告警调试] 浏览器不支持语音合成API');
                    // 设置下一次播放定时器
                    scheduleNextAlarmLoop();
                    return;
                }
                
                let completedCount = 0;
                const totalCount = alarmTexts.length;
                
                alarmTexts.forEach((alarmText, index) => {
                    console.log(`[告警调试] 播放文字语音: "${alarmText}"`);
                    
                    const utterance = new SpeechSynthesisUtterance(alarmText);
                    utterance.lang = 'zh-CN';
                    utterance.rate = 1.0;
                    utterance.pitch = 1.0;
                    utterance.volume = 0.8;
                    
                    // 获取可用的语音
                    const voices = window.speechSynthesis.getVoices();
                    const chineseVoice = voices.find(voice => 
                        voice.lang.includes('zh') || 
                        voice.name.includes('Chinese') || 
                        voice.name.includes('中文')
                    );
                    
                    if (chineseVoice) {
                        utterance.voice = chineseVoice;
                        console.log(`[告警调试] 使用中文语音: ${chineseVoice.name}`);
                    } else {
                        console.log('[告警调试] 未找到中文语音，使用默认语音');
                    }
                    
                    utterance.onstart = () => {
                        console.log(`[告警调试] 开始播放文字语音: "${alarmText}"`);
                    };
                    
                    utterance.onend = () => {
                        console.log(`[告警调试] 文字语音播放完成: "${alarmText}"`);
                        completedCount++;
                        
                        // 如果所有语音都播放完成，设置下一次播放
                        if (completedCount >= totalCount) {
                            console.log('[告警调试] 所有告警语音播放完成，设置下次播放');
                            scheduleNextAlarmLoop();
                        }
                    };
                    
                    utterance.onerror = (e) => {
                        console.error(`[告警调试] 文字语音播放失败: "${alarmText}"`, e);
                        completedCount++;
                        
                        // 即使出错也要继续
                        if (completedCount >= totalCount) {
                            scheduleNextAlarmLoop();
                        }
                    };
                    
                    // 播放语音
                    window.speechSynthesis.speak(utterance);
                });
                
                // 如果没有告警文本，直接设置下次播放
                if (totalCount === 0) {
                    scheduleNextAlarmLoop();
                }
                
            } catch (error) {
                console.error('[告警调试] 播放文字语音时发生错误:', error);
                scheduleNextAlarmLoop();
            }
        }

        // 【新增】安排下次告警循环
        function scheduleNextAlarmLoop() {
            console.log('[告警调试] 设置下次告警播放，5分钟后');
            window.alarmLoopTimer = setTimeout(() => {
                if (window.alarmPlayingState.activeAlarms.length > 0) {
                    console.log('[告警调试] 开始下一轮告警播放');
                    playAlarmSequence();
                } else {
                    console.log('[告警调试] 没有活动告警，停止循环');
                    window.alarmPlayingState.isPlaying = false;
                }
            }, 300000); // 5分钟
        }

        // 停止告警循环
        function stopAlarmLoop() {
            console.log('[告警调试] 停止告警循环');
            
            if (window.alarmLoopTimer) {
                clearTimeout(window.alarmLoopTimer);
                window.alarmLoopTimer = null;
            }
            
            window.alarmPlayingState.isPlaying = false;
            window.alarmPlayingState.activeAlarms = [];
            window.alarmPlayingState.loopCounter = 0;
            window.alarmPlayingState.paused = false;
            window.alarmPlayingState.nextAlarmTime = null;
            
            // 停止所有语音合成
            window.speechSynthesis.cancel();
            
            console.log('[告警调试] 告警循环已停止');
        }

        // 显示告警通知
        function showAlarmNotifications(alarmMessages) {
            // 在页面上显示告警提示
            const alarmsText = alarmMessages.join(', ');
            showWarning(`<strong>告警触发!</strong> ${alarmsText}`, 10000);
            
            // 显示桌面通知（如果支持）
            if (alarmMessages.length > 0 && typeof Notification !== 'undefined') {
                if (Notification.permission === 'granted') {
                    console.log('[告警调试] 发送桌面通知');
                    
                    const message = alarmMessages.length === 1 
                        ? alarmMessages[0] 
                        : `有 ${alarmMessages.length} 个告警触发`;
                    
                    try {
                        const notification = new Notification('Modbus告警', {
                            body: message,
                            // 【修复】移除不存在的图标文件引用，避免404错误
                            // icon: '/img/alert-icon.png',
                            vibrate: [100, 50, 100]
                        });
                        
                        setTimeout(() => notification.close(), 10000);
                    } catch (notifyError) {
                        console.error('[告警调试] 创建通知失败:', notifyError);
                    }
                } else if (Notification.permission !== 'denied') {
                    Notification.requestPermission();
                }
            }
        }

        // 处理WebSocket告警消息
        function handleAlarmMessage(alarmData) {
            console.log('[Chat告警] 处理告警消息:', alarmData);
            
            try {
                const { identifier, content, timestamp, dataPointName } = alarmData;
                
                if (!content) {
                    console.error('[Chat告警] 告警消息缺少内容');
                    return;
                }
                
                // 在聊天界面显示告警消息
                addAlarmMessage(content, timestamp, 'alarm');
                
                // 播放告警声音
                playAlarmSound([content]);
                
                // 显示页面通知
                showWarning(`<strong>🚨 设备告警</strong><br>${content}`, 8000);
                
                // 显示桌面通知
                if (typeof Notification !== 'undefined' && Notification.permission === 'granted') {
                    try {
                        const notification = new Notification('设备告警', {
                            body: content,
                            // 【修复】移除不存在的图标文件引用，避免404错误
                            // icon: '/img/alert-icon.png',
                            vibrate: [200, 100, 200],
                            tag: identifier // 使用标识符作为标签，避免重复通知
                        });
                        
                        setTimeout(() => notification.close(), 10000);
                    } catch (notifyError) {
                        console.error('[Chat告警] 创建桌面通知失败:', notifyError);
                    }
                }
                
                console.log('[Chat告警] 告警消息处理完成');
            } catch (error) {
                console.error('[Chat告警] 处理告警消息失败:', error);
            }
        }

        // 处理WebSocket告警解除消息
        function handleAlarmClearedMessage(alarmData) {
            console.log('[Chat告警] 处理告警解除消息:', alarmData);
            
            try {
                const { identifier, content, clearedTime } = alarmData;
                
                if (!content) {
                    console.error('[Chat告警] 告警解除消息缺少内容');
                    return;
                }
                
                // 在聊天界面显示告警解除消息
                addAlarmMessage(`告警已解除: ${content}`, clearedTime, 'alarm_cleared');
                
                // 从活动告警列表中移除
                if (window.alarmPlayingState && window.alarmPlayingState.activeAlarms) {
                    const index = window.alarmPlayingState.activeAlarms.indexOf(content);
                    if (index > -1) {
                        window.alarmPlayingState.activeAlarms.splice(index, 1);
                        console.log('[Chat告警] 已从活动告警列表中移除:', content);
                        
                        // 如果没有活动告警了，停止告警循环
                        if (window.alarmPlayingState.activeAlarms.length === 0) {
                            stopAlarmLoop();
                            console.log('[Chat告警] 所有告警已解除，停止告警循环');
                        }
                    }
                }
                
                // 显示页面通知
                showWarning(`<strong>✅ 告警解除</strong><br>${content}`, 5000);
                
                console.log('[Chat告警] 告警解除消息处理完成');
            } catch (error) {
                console.error('[Chat告警] 处理告警解除消息失败:', error);
            }
        }

        // 在聊天界面添加告警消息
        function addAlarmMessage(content, timestamp, type = 'alarm') {
            try {
                const chatMessages = document.getElementById('chatMessages');
                if (!chatMessages) {
                    console.error('[Chat告警] 找不到聊天消息容器');
                    return;
                }
                
                const messageDiv = document.createElement('div');
                messageDiv.className = type === 'alarm' ? 'message-alarm' : 'message-alarm-clear';
                
                const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
                const icon = type === 'alarm' ? '🚨' : '✅';
                const bgColor = type === 'alarm' ? '#f8d7da' : '#d4edda';
                const borderColor = type === 'alarm' ? '#f5c6cb' : '#c3e6cb';
                const textColor = type === 'alarm' ? '#721c24' : '#155724';
                
                messageDiv.innerHTML = `
                    <div style="background-color: ${bgColor}; border: 1px solid ${borderColor}; color: ${textColor}; padding: 12px; border-radius: 8px; margin: 8px 0;">
                        <div style="display: flex; align-items: center; margin-bottom: 5px;">
                            <span style="font-size: 1.2em; margin-right: 8px;">${icon}</span>
                            <strong>${type === 'alarm' ? '设备告警' : '告警解除'}</strong>
                        </div>
                        <div style="margin-left: 28px; margin-bottom: 8px;">
                            ${content}
                        </div>
                        <div style="font-size: 0.85em; color: #6c757d; text-align: right;">
                            ${time}
                        </div>
                    </div>
                `;
                
                chatMessages.appendChild(messageDiv);
                
                // 滚动到底部
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.log('[Chat告警] 告警消息已添加到聊天界面');
            } catch (error) {
                console.error('[Chat告警] 添加告警消息到聊天界面失败:', error);
            }
        }

        // 【新增】处理多条件告警消息
        function handleMultiConditionAlarmMessage(alarmData) {
            console.log('[Chat告警] 处理多条件告警消息:', alarmData);
            
            try {
                const { ruleId, ruleName, content, timestamp, level, conditions } = alarmData;
                
                if (!content) {
                    console.error('[Chat告警] 多条件告警消息缺少内容');
                    return;
                }
                
                // 在聊天界面显示多条件告警消息
                addMultiConditionAlarmMessage(content, timestamp, ruleName, conditions, 'multi_alarm');
                
                // 播放告警声音
                playAlarmSound([content]);
                
                // 显示页面通知
                const levelText = level === 'high' ? '高级' : level === 'medium' ? '中级' : '低级';
                showWarning(`<strong>🚨 多条件告警 (${levelText})</strong><br>${content}`, 10000);
                
                // 显示桌面通知
                if (typeof Notification !== 'undefined' && Notification.permission === 'granted') {
                    try {
                        const notification = new Notification(`多条件告警 - ${ruleName}`, {
                            body: content,
                            vibrate: [200, 100, 200, 100, 200],
                            tag: `multi_condition_${ruleId}` // 使用规则ID作为标签，避免重复通知
                        });
                        
                        setTimeout(() => notification.close(), 12000);
                    } catch (notifyError) {
                        console.error('[Chat告警] 创建多条件告警桌面通知失败:', notifyError);
                    }
                }
                
                console.log('[Chat告警] 多条件告警消息处理完成');
            } catch (error) {
                console.error('[Chat告警] 处理多条件告警消息失败:', error);
            }
        }

        // 【新增】处理多条件告警解除消息
        function handleMultiConditionAlarmClearedMessage(alarmData) {
            console.log('[Chat告警] 处理多条件告警解除消息:', alarmData);
            
            try {
                const { ruleId, ruleName, content, clearedTime, level } = alarmData;
                
                if (!content) {
                    console.error('[Chat告警] 多条件告警解除消息缺少内容');
                    return;
                }
                
                // 在聊天界面显示多条件告警解除消息
                addMultiConditionAlarmMessage(`告警已解除: ${content}`, clearedTime, ruleName, null, 'multi_alarm_cleared');
                
                // 从活动告警列表中移除
                if (window.alarmPlayingState && window.alarmPlayingState.activeAlarms) {
                    const index = window.alarmPlayingState.activeAlarms.indexOf(content);
                    if (index > -1) {
                        window.alarmPlayingState.activeAlarms.splice(index, 1);
                        console.log('[Chat告警] 已从活动告警列表中移除多条件告警:', content);
                        
                        // 如果没有活动告警了，停止告警循环
                        if (window.alarmPlayingState.activeAlarms.length === 0) {
                            stopAlarmLoop();
                            console.log('[Chat告警] 所有多条件告警已解除，停止告警循环');
                        }
                    }
                }
                
                // 显示页面通知
                const levelText = level === 'high' ? '高级' : level === 'medium' ? '中级' : '低级';
                showWarning(`<strong>✅ 多条件告警解除 (${levelText})</strong><br>${content}`, 6000);
                
                console.log('[Chat告警] 多条件告警解除消息处理完成');
            } catch (error) {
                console.error('[Chat告警] 处理多条件告警解除消息失败:', error);
            }
        }

        // 【新增】在聊天界面添加多条件告警消息
        function addMultiConditionAlarmMessage(content, timestamp, ruleName, conditions, type = 'multi_alarm') {
            try {
                const chatMessages = document.getElementById('chatMessages');
                if (!chatMessages) {
                    console.error('[Chat告警] 找不到聊天消息容器');
                    return;
                }
                
                const messageDiv = document.createElement('div');
                messageDiv.className = type === 'multi_alarm' ? 'message-multi-alarm' : 'message-multi-alarm-clear';
                
                const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
                const icon = type === 'multi_alarm' ? '⚠️' : '✅';
                const bgColor = type === 'multi_alarm' ? '#fff3cd' : '#d4edda';
                const borderColor = type === 'multi_alarm' ? '#ffeaa7' : '#c3e6cb';
                const textColor = type === 'multi_alarm' ? '#856404' : '#155724';
                
                // 构建条件详情HTML
                let conditionsHtml = '';
                if (conditions && conditions.length > 0) {
                    conditionsHtml = '<div style="margin-top: 8px; font-size: 0.9em; color: #6c757d;"><strong>触发条件:</strong><ul style="margin: 5px 0; padding-left: 20px;">';
                    conditions.forEach(condition => {
                        const statusIcon = condition.met ? '✅' : '❌';
                        conditionsHtml += `<li>${condition.datapoint} ${condition.operator} ${condition.targetValue} (当前: ${condition.currentValue}) ${statusIcon}</li>`;
                    });
                    conditionsHtml += '</ul></div>';
                }
                
                messageDiv.innerHTML = `
                    <div style="background-color: ${bgColor}; border: 2px solid ${borderColor}; color: ${textColor}; padding: 15px; border-radius: 10px; margin: 10px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <div style="display: flex; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 1.3em; margin-right: 10px;">${icon}</span>
                            <strong style="font-size: 1.1em;">${type === 'multi_alarm' ? '多条件告警' : '多条件告警解除'}</strong>
                            ${ruleName ? `<span style="margin-left: 10px; font-size: 0.9em; color: #6c757d;">规则: ${ruleName}</span>` : ''}
                        </div>
                        <div style="margin-left: 35px; margin-bottom: 10px; font-size: 1.05em;">
                            ${content}
                        </div>
                        ${conditionsHtml}
                        <div style="font-size: 0.85em; color: #6c757d; text-align: right; margin-top: 8px;">
                            ${time}
                        </div>
                    </div>
                `;
                
                chatMessages.appendChild(messageDiv);
                
                // 滚动到底部
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.log('[Chat告警] 多条件告警消息已添加到聊天界面');
            } catch (error) {
                console.error('[Chat告警] 添加多条件告警消息到聊天界面失败:', error);
            }
        }

        // 在聊天界面添加告警消息
    </script>

    <script>
    // 页面加载时初始化
    document.addEventListener('DOMContentLoaded', function() {
      console.log('[Chat告警] 页面加载完成，初始化告警接收功能');
      
      // 初始化告警获取定时器
      fetchAlarmsInitializer();
    });

    // 向调试面板添加信息 (改为只输出到控制台)
    function logAlarmDebug(message, data) {
      // 输出到控制台
      if (data) {
        console.log(`[Chat告警] ${message}`, data);
      } else {
        console.log(`[Chat告警] ${message}`);
      }
    }
    </script>

    <style>
    /* 告警消息样式 */
    .message-alarm {
      margin: 10px 0;
      padding: 10px;
      max-width: 80%;
      align-self: center;
      width: 100%;
    }

    .alarm-notification {
      background-color: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      padding: 10px;
      border-radius: 8px;
      position: relative;
    }

    .alarm-notification i {
      color: #dc3545;
      margin-right: 5px;
    }

    .alarm-time {
      font-size: 0.8em;
      color: #6c757d;
      margin-top: 5px;
      text-align: right;
    }

    /* 告警解除消息样式 */
    .message-alarm-clear {
      margin: 10px 0;
      padding: 10px;
      max-width: 80%;
      align-self: center;
      width: 100%;
    }

    .alarm-clear-notification {
      background-color: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      padding: 10px;
      border-radius: 8px;
      position: relative;
    }

    .alarm-clear-notification i {
      color: #28a745;
      margin-right: 5px;
    }
    </style>

    <!-- 添加警告通知（支持HTML内容和自定义持续时间） -->
    <script>
    function showWarning(message, duration = 5000) {
        // 创建警告通知元素
        const warningNotification = document.createElement('div');
        warningNotification.innerHTML = message;
        warningNotification.style.position = 'fixed';
        warningNotification.style.top = '20px';
        warningNotification.style.right = '20px';
        warningNotification.style.backgroundColor = '#f8d7da';
        warningNotification.style.border = '1px solid #f5c6cb';
        warningNotification.style.color = '#721c24';
        warningNotification.style.padding = '15px';
        warningNotification.style.borderRadius = '8px';
        warningNotification.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
        warningNotification.style.zIndex = '1001';
        warningNotification.style.maxWidth = '350px';
        warningNotification.style.fontSize = '14px';
        warningNotification.style.lineHeight = '1.4';
        
        // 添加关闭按钮
        const closeBtn = document.createElement('span');
        closeBtn.innerHTML = '&times;';
        closeBtn.style.position = 'absolute';
        closeBtn.style.top = '5px';
        closeBtn.style.right = '10px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontSize = '18px';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.style.color = '#721c24';
        closeBtn.onclick = () => {
            if (document.body.contains(warningNotification)) {
                document.body.removeChild(warningNotification);
            }
        };
        
        warningNotification.appendChild(closeBtn);
        document.body.appendChild(warningNotification);
        
        // 指定时间后自动移除
        setTimeout(() => {
            if (document.body.contains(warningNotification)) {
                document.body.removeChild(warningNotification);
            }
        }, duration);
    }
    </script>

    <!-- 页面加载时立即尝试解锁音频 -->
    <script>
    function unlockAudio() {
        // 创建一个临时的音频元素
        const tempAudio = new Audio();
        
        // 尝试播放静音音频
        tempAudio.play().then(() => {
            console.log('音频播放已解锁');
            
            // 设置解锁标志
            window.audioUnlocked = true;
            
            // 移除事件监听器
            document.removeEventListener('click', unlockAudio);
            document.removeEventListener('keydown', unlockAudio);
        }).catch(() => {
            console.log('音频播放尚未解锁，等待用户交互');
        });
    }
    </script>
   
</body>
</html>