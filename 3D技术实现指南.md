# ğŸ”§ 3Då¯è§†åŒ–æŠ€æœ¯å®ç°æŒ‡å—

## ğŸ¯ æ ¸å¿ƒæŠ€æœ¯è¦ç‚¹

### 1. è‡ªé€‚åº”æ¸²æŸ“å¼•æ“è®¾è®¡

#### è®¾å¤‡æ€§èƒ½æ£€æµ‹æ ¸å¿ƒä»£ç 
```javascript
// device-detector.js
class DeviceDetector {
  static detectCapability() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    if (!gl) {
      return { level: 'fallback', score: 0 };
    }
    
    const capability = {
      // GPUä¿¡æ¯
      renderer: gl.getParameter(gl.RENDERER),
      vendor: gl.getParameter(gl.VENDOR),
      maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
      maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS),
      
      // å†…å­˜ä¿¡æ¯
      memory: navigator.deviceMemory || 4,
      cores: navigator.hardwareConcurrency || 4,
      
      // WebGLæ‰©å±•æ”¯æŒ
      extensions: gl.getSupportedExtensions(),
      
      // æ€§èƒ½åŸºå‡†æµ‹è¯•
      benchmark: this.runBenchmark(gl)
    };
    
    return this.calculatePerformanceLevel(capability);
  }
  
  static runBenchmark(gl) {
    // ç®€å•çš„æ¸²æŸ“æ€§èƒ½æµ‹è¯•
    const startTime = performance.now();
    
    // åˆ›å»ºæµ‹è¯•å‡ ä½•ä½“
    const vertices = new Float32Array(3000); // 1000ä¸ªä¸‰è§’å½¢
    for (let i = 0; i < vertices.length; i++) {
      vertices[i] = Math.random() * 2 - 1;
    }
    
    // æµ‹è¯•ç»˜åˆ¶æ€§èƒ½
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    
    // æ¸²æŸ“æµ‹è¯•
    for (let i = 0; i < 100; i++) {
      gl.drawArrays(gl.TRIANGLES, 0, 1000);
    }
    
    const endTime = performance.now();
    return endTime - startTime;
  }
  
  static calculatePerformanceLevel(capability) {
    let score = 0;
    
    // GPUè¯„åˆ†
    if (capability.maxTextureSize >= 4096) score += 30;
    else if (capability.maxTextureSize >= 2048) score += 20;
    else score += 10;
    
    // å†…å­˜è¯„åˆ†
    if (capability.memory >= 8) score += 25;
    else if (capability.memory >= 4) score += 15;
    else score += 5;
    
    // CPUè¯„åˆ†
    if (capability.cores >= 8) score += 20;
    else if (capability.cores >= 4) score += 15;
    else score += 5;
    
    // åŸºå‡†æµ‹è¯•è¯„åˆ†
    if (capability.benchmark < 50) score += 25;
    else if (capability.benchmark < 100) score += 15;
    else score += 5;
    
    // ç¡®å®šæ€§èƒ½çº§åˆ«
    if (score >= 80) return { level: 'high', score };
    else if (score >= 50) return { level: 'medium', score };
    else if (score >= 30) return { level: 'low', score };
    else return { level: 'fallback', score };
  }
}
```

#### è‡ªé€‚åº”æ¸²æŸ“å™¨æ ¸å¿ƒå®ç°
```javascript
// adaptive-renderer.js
class AdaptiveRenderer {
  constructor(container, config) {
    this.container = container;
    this.config = config;
    this.capability = DeviceDetector.detectCapability();
    this.currentMode = this.capability.level;
    
    this.initRenderer();
    this.setupPerformanceMonitoring();
  }
  
  initRenderer() {
    const renderConfig = this.config.performanceLevels[this.currentMode];
    
    // åˆ›å»ºæ¸²æŸ“å™¨
    this.renderer = new THREE.WebGLRenderer({
      antialias: this.currentMode === 'high',
      alpha: true,
      powerPreference: this.currentMode === 'high' ? 'high-performance' : 'low-power'
    });
    
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.renderer.setClearColor(0x87CEEB, 1); // å¤©ç©ºè“èƒŒæ™¯
    
    // æ ¹æ®æ€§èƒ½çº§åˆ«è°ƒæ•´æ¸²æŸ“è®¾ç½®
    if (renderConfig.enableShadows) {
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    }
    
    this.container.appendChild(this.renderer.domElement);
    
    // åˆ›å»ºåœºæ™¯å’Œç›¸æœº
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(75, 
      this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
    
    this.setupLighting();
    this.setupControls();
  }
  
  setupLighting() {
    const renderConfig = this.config.performanceLevels[this.currentMode];
    
    if (this.currentMode === 'high') {
      // é«˜æ€§èƒ½æ¨¡å¼ï¼šå®Œæ•´å…‰ç…§
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      this.scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 100, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      this.scene.add(directionalLight);
      
      const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.3);
      this.scene.add(hemisphereLight);
    } else {
      // ä¸­ä½æ€§èƒ½æ¨¡å¼ï¼šç®€åŒ–å…‰ç…§
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      this.scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
      directionalLight.position.set(50, 100, 50);
      this.scene.add(directionalLight);
    }
  }
  
  setupPerformanceMonitoring() {
    this.stats = new Stats();
    this.stats.dom.style.position = 'absolute';
    this.stats.dom.style.top = '10px';
    this.stats.dom.style.right = '10px';
    this.container.appendChild(this.stats.dom);
    
    // æ€§èƒ½ç›‘æ§å¾ªç¯
    this.performanceCheckInterval = setInterval(() => {
      this.checkPerformance();
    }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
  }
  
  checkPerformance() {
    const fps = 1000 / this.stats.getAverageDelta();
    
    if (fps < this.config.rendering.fallbackThreshold && this.currentMode !== 'fallback') {
      console.log(`æ€§èƒ½ä¸è¶³ (${fps.toFixed(1)} FPS)ï¼Œé™çº§æ¸²æŸ“æ¨¡å¼`);
      this.downgradeRenderMode();
    }
  }
  
  downgradeRenderMode() {
    const modes = ['high', 'medium', 'low', 'fallback'];
    const currentIndex = modes.indexOf(this.currentMode);
    
    if (currentIndex < modes.length - 1) {
      this.currentMode = modes[currentIndex + 1];
      this.applyRenderMode();
      console.log(`å·²åˆ‡æ¢åˆ° ${this.currentMode} æ¸²æŸ“æ¨¡å¼`);
    }
  }
  
  applyRenderMode() {
    const renderConfig = this.config.performanceLevels[this.currentMode];
    
    // æ›´æ–°æ¸²æŸ“å™¨è®¾ç½®
    this.renderer.shadowMap.enabled = renderConfig.enableShadows;
    
    // æ›´æ–°åœºæ™¯å¤æ‚åº¦
    this.scene.traverse((object) => {
      if (object.userData.deviceObject) {
        this.updateDeviceComplexity(object, renderConfig);
      }
    });
  }
  
  updateDeviceComplexity(device, config) {
    // æ ¹æ®æ€§èƒ½çº§åˆ«è°ƒæ•´è®¾å¤‡æ¨¡å‹å¤æ‚åº¦
    if (config.maxPolygons < 20000) {
      // ä½æ€§èƒ½æ¨¡å¼ï¼šä½¿ç”¨ç®€å•å‡ ä½•ä½“
      this.replaceWithSimpleGeometry(device);
    }
  }
}
```

### 2. è®¾å¤‡3Då¯¹è±¡å·¥å‚

#### è®¾å¤‡åˆ›å»ºå·¥å‚æ¨¡å¼
```javascript
// device-factory.js
class DeviceFactory {
  static createDevice(deviceInfo, performanceLevel) {
    const deviceType = deviceInfo.type || this.inferDeviceType(deviceInfo.identifier);
    
    switch (deviceType) {
      case 'pump':
        return this.createPump(deviceInfo, performanceLevel);
      case 'sensor':
        return this.createSensor(deviceInfo, performanceLevel);
      case 'tank':
        return this.createTank(deviceInfo, performanceLevel);
      case 'valve':
        return this.createValve(deviceInfo, performanceLevel);
      default:
        return this.createGenericDevice(deviceInfo, performanceLevel);
    }
  }
  
  static createPump(deviceInfo, performanceLevel) {
    const group = new THREE.Group();
    group.userData = {
      deviceId: deviceInfo.identifier,
      deviceType: 'pump',
      deviceObject: true
    };
    
    if (performanceLevel === 'high') {
      // é«˜æ€§èƒ½æ¨¡å¼ï¼šè¯¦ç»†æ³µæ¨¡å‹
      const bodyGeometry = new THREE.CylinderGeometry(1, 1.2, 2, 16);
      const bodyMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x4682B4,
        shininess: 30 
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.castShadow = true;
      body.receiveShadow = true;
      
      // æ³µå¤´
      const headGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 12);
      const headMaterial = new THREE.MeshPhongMaterial({ color: 0x2F4F4F });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.25;
      head.castShadow = true;
      
      // è¿›å‡ºæ°´ç®¡
      const pipeGeometry = new THREE.CylinderGeometry(0.2, 0.2, 3, 8);
      const pipeMaterial = new THREE.MeshPhongMaterial({ color: 0x708090 });
      
      const inletPipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
      inletPipe.rotation.z = Math.PI / 2;
      inletPipe.position.set(-2, 0.5, 0);
      
      const outletPipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
      outletPipe.rotation.z = Math.PI / 2;
      outletPipe.position.set(2, 0.5, 0);
      
      group.add(body, head, inletPipe, outletPipe);
      
      // æ—‹è½¬åŠ¨ç”»ï¼ˆè¿è¡ŒçŠ¶æ€æ—¶ï¼‰
      group.userData.animate = () => {
        if (group.userData.status === 'running') {
          head.rotation.y += 0.1;
        }
      };
      
    } else {
      // ä½æ€§èƒ½æ¨¡å¼ï¼šç®€åŒ–æ³µæ¨¡å‹
      const geometry = new THREE.BoxGeometry(2, 2, 1);
      const material = new THREE.MeshLambertMaterial({ color: 0x4682B4 });
      const pump = new THREE.Mesh(geometry, material);
      group.add(pump);
    }
    
    // çŠ¶æ€æŒ‡ç¤ºå™¨
    const statusGeometry = new THREE.SphereGeometry(0.2, 8, 6);
    const statusMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const statusLight = new THREE.Mesh(statusGeometry, statusMaterial);
    statusLight.position.set(0, 2.5, 0);
    group.add(statusLight);
    
    group.userData.statusLight = statusLight;
    
    return group;
  }
  
  static createSensor(deviceInfo, performanceLevel) {
    const group = new THREE.Group();
    group.userData = {
      deviceId: deviceInfo.identifier,
      deviceType: 'sensor',
      deviceObject: true
    };
    
    if (performanceLevel === 'high') {
      // ä¼ æ„Ÿå™¨ä¸»ä½“
      const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 12);
      const bodyMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.9 
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      
      // ä¼ æ„Ÿå™¨æ¢å¤´
      const probeGeometry = new THREE.ConeGeometry(0.15, 0.5, 8);
      const probeMaterial = new THREE.MeshPhongMaterial({ color: 0x2F4F4F });
      const probe = new THREE.Mesh(probeGeometry, probeMaterial);
      probe.position.y = -0.75;
      
      // æ˜¾ç¤ºå±
      const screenGeometry = new THREE.PlaneGeometry(0.8, 0.4);
      const screenMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x000000,
        transparent: true,
        opacity: 0.8 
      });
      const screen = new THREE.Mesh(screenGeometry, screenMaterial);
      screen.position.set(0, 0.2, 0.31);
      
      group.add(body, probe, screen);
      
      // æ•°å€¼æ˜¾ç¤ºæ–‡æœ¬
      group.userData.screen = screen;
    } else {
      // ç®€åŒ–ä¼ æ„Ÿå™¨
      const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 6);
      const material = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const sensor = new THREE.Mesh(geometry, material);
      group.add(sensor);
    }
    
    return group;
  }
  
  static inferDeviceType(identifier) {
    const id = identifier.toLowerCase();
    
    if (id.includes('pump') || id.includes('æ³µ')) return 'pump';
    if (id.includes('sensor') || id.includes('ä¼ æ„Ÿå™¨')) return 'sensor';
    if (id.includes('tank') || id.includes('æ± ') || id.includes('ç½')) return 'tank';
    if (id.includes('valve') || id.includes('é˜€')) return 'valve';
    if (id.includes('meter') || id.includes('è¡¨')) return 'sensor';
    
    return 'generic';
  }
}
```

### 3. æ•°æ®ç»‘å®šä¸çŠ¶æ€æ›´æ–°

#### å®æ—¶æ•°æ®ç»‘å®šç³»ç»Ÿ
```javascript
// data-binding.js
class DataBinding {
  constructor(sceneManager, wsConnection) {
    this.sceneManager = sceneManager;
    this.wsConnection = wsConnection;
    this.deviceMap = new Map(); // è®¾å¤‡IDåˆ°3Då¯¹è±¡çš„æ˜ å°„
    
    this.setupWebSocketHandlers();
    this.setupUpdateLoop();
  }
  
  setupWebSocketHandlers() {
    this.wsConnection.on('modbus-data-update', (data) => {
      this.updateDeviceData(data);
    });
    
    this.wsConnection.on('alarm-update', (alarmData) => {
      this.updateAlarmStatus(alarmData);
    });
  }
  
  updateDeviceData(data) {
    if (!data.identifier) return;
    
    const device3D = this.deviceMap.get(data.identifier);
    if (!device3D) return;
    
    // æ›´æ–°è®¾å¤‡çŠ¶æ€
    this.updateDeviceStatus(device3D, data);
    
    // æ›´æ–°æ•°å€¼æ˜¾ç¤º
    this.updateValueDisplay(device3D, data);
    
    // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºç¯
    this.updateStatusLight(device3D, data);
  }
  
  updateDeviceStatus(device3D, data) {
    const status = this.determineDeviceStatus(data);
    device3D.userData.status = status;
    device3D.userData.lastUpdate = Date.now();
    
    // æ ¹æ®çŠ¶æ€è°ƒæ•´è®¾å¤‡å¤–è§‚
    switch (status) {
      case 'running':
        this.setDeviceColor(device3D, 0x00ff00); // ç»¿è‰²
        break;
      case 'stopped':
        this.setDeviceColor(device3D, 0xff9900); // æ©™è‰²
        break;
      case 'alarm':
        this.setDeviceColor(device3D, 0xff0000); // çº¢è‰²
        this.startAlarmAnimation(device3D);
        break;
      case 'offline':
        this.setDeviceColor(device3D, 0x808080); // ç°è‰²
        break;
    }
  }
  
  updateValueDisplay(device3D, data) {
    if (device3D.userData.screen && data.value !== undefined) {
      // åœ¨ä¼ æ„Ÿå™¨æ˜¾ç¤ºå±ä¸Šæ˜¾ç¤ºæ•°å€¼
      this.updateScreenText(device3D.userData.screen, data.value, data.unit);
    }
    
    // æ ¹æ®æ•°å€¼èŒƒå›´è°ƒæ•´é¢œè‰²
    if (data.value !== undefined && data.min !== undefined && data.max !== undefined) {
      const ratio = (data.value - data.min) / (data.max - data.min);
      const color = this.getValueColor(ratio);
      this.setDeviceAccentColor(device3D, color);
    }
  }
  
  updateStatusLight(device3D, data) {
    const statusLight = device3D.userData.statusLight;
    if (!statusLight) return;
    
    const status = device3D.userData.status;
    
    switch (status) {
      case 'running':
        statusLight.material.color.setHex(0x00ff00);
        statusLight.material.emissive.setHex(0x004400);
        break;
      case 'stopped':
        statusLight.material.color.setHex(0xff9900);
        statusLight.material.emissive.setHex(0x442200);
        break;
      case 'alarm':
        // é—ªçƒæ•ˆæœ
        const time = Date.now() * 0.01;
        const intensity = Math.sin(time) * 0.5 + 0.5;
        statusLight.material.color.setHex(0xff0000);
        statusLight.material.emissive.setScalar(intensity * 0.5);
        break;
      case 'offline':
        statusLight.material.color.setHex(0x808080);
        statusLight.material.emissive.setHex(0x000000);
        break;
    }
  }
  
  getValueColor(ratio) {
    // ä»ç»¿è‰²åˆ°çº¢è‰²çš„æ¸å˜
    const hue = (1 - ratio) * 120; // 120åº¦ = ç»¿è‰², 0åº¦ = çº¢è‰²
    return new THREE.Color().setHSL(hue / 360, 1, 0.5);
  }
  
  determineDeviceStatus(data) {
    if (data.alarmStatus) return 'alarm';
    if (data.offline || !data.connected) return 'offline';
    if (data.running === false) return 'stopped';
    if (data.value !== undefined) return 'running';
    return 'unknown';
  }
  
  registerDevice(deviceId, device3D) {
    this.deviceMap.set(deviceId, device3D);
    console.log(`æ³¨å†Œè®¾å¤‡ ${deviceId} åˆ°3Dåœºæ™¯`);
  }
  
  unregisterDevice(deviceId) {
    this.deviceMap.delete(deviceId);
  }
}
```

### 4. é™çº§æ¸²æŸ“å®ç°

#### Canvas 2D é™çº§æ¸²æŸ“å™¨
```javascript
// fallback-renderer.js
class FallbackRenderer {
  constructor(container, config) {
    this.container = container;
    this.config = config;
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    
    this.setupCanvas();
    this.setupLayout();
  }
  
  setupCanvas() {
    this.canvas.width = this.container.clientWidth;
    this.canvas.height = this.container.clientHeight;
    this.canvas.style.width = '100%';
    this.canvas.style.height = '100%';
    this.container.appendChild(this.canvas);
  }
  
  setupLayout() {
    // 2Dä¿¯è§†å›¾å¸ƒå±€
    this.layout = {
      mainPool: { x: 400, y: 300, radius: 80 },
      secondaryPools: [
        { x: 200, y: 300, width: 60, height: 40 },
        { x: 600, y: 300, width: 60, height: 40 }
      ],
      devices: new Map()
    };
  }
  
  render(deviceData) {
    // æ¸…ç©ºç”»å¸ƒ
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // ç»˜åˆ¶èƒŒæ™¯
    this.drawBackground();
    
    // ç»˜åˆ¶å¤„ç†æ± 
    this.drawPools();
    
    // ç»˜åˆ¶è®¾å¤‡
    this.drawDevices(deviceData);
    
    // ç»˜åˆ¶è¿æ¥ç®¡é“
    this.drawPipes();
    
    // ç»˜åˆ¶å›¾ä¾‹
    this.drawLegend();
  }
  
  drawBackground() {
    // æ¸å˜èƒŒæ™¯
    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(1, '#E0F6FF');
    
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  
  drawPools() {
    this.ctx.strokeStyle = '#2F4F4F';
    this.ctx.lineWidth = 3;
    this.ctx.fillStyle = 'rgba(65, 105, 225, 0.3)';
    
    // ä¸»å¤„ç†æ± ï¼ˆåœ†å½¢ï¼‰
    const mainPool = this.layout.mainPool;
    this.ctx.beginPath();
    this.ctx.arc(mainPool.x, mainPool.y, mainPool.radius, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // æ ‡ç­¾
    this.ctx.fillStyle = '#2F4F4F';
    this.ctx.font = '14px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('ä¸»å¤„ç†æ± ', mainPool.x, mainPool.y);
    
    // äºŒçº§å¤„ç†æ± 
    this.layout.secondaryPools.forEach((pool, index) => {
      this.ctx.fillStyle = 'rgba(65, 105, 225, 0.3)';
      this.ctx.fillRect(pool.x - pool.width/2, pool.y - pool.height/2, 
                       pool.width, pool.height);
      this.ctx.strokeRect(pool.x - pool.width/2, pool.y - pool.height/2, 
                         pool.width, pool.height);
      
      this.ctx.fillStyle = '#2F4F4F';
      this.ctx.fillText(`äºŒçº§æ± ${index + 1}`, pool.x, pool.y);
    });
  }
  
  drawDevices(deviceData) {
    deviceData.forEach((device, id) => {
      const position = this.getDevicePosition(id, device.type);
      if (!position) return;
      
      this.drawDevice(position.x, position.y, device);
    });
  }
  
  drawDevice(x, y, device) {
    const size = 12;
    const color = this.getDeviceColor(device.status);
    
    // è®¾å¤‡å›¾æ ‡
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    
    switch (device.type) {
      case 'pump':
        this.ctx.arc(x, y, size, 0, Math.PI * 2);
        break;
      case 'sensor':
        this.ctx.rect(x - size/2, y - size/2, size, size);
        break;
      case 'valve':
        this.drawDiamond(x, y, size);
        break;
      default:
        this.ctx.rect(x - size/2, y - size/2, size, size);
    }
    
    this.ctx.fill();
    this.ctx.strokeStyle = '#2F4F4F';
    this.ctx.lineWidth = 2;
    this.ctx.stroke();
    
    // çŠ¶æ€æŒ‡ç¤º
    if (device.status === 'alarm') {
      this.drawAlarmIndicator(x, y, size);
    }
    
    // æ•°å€¼æ˜¾ç¤º
    if (device.value !== undefined) {
      this.ctx.fillStyle = '#2F4F4F';
      this.ctx.font = '10px Arial';
      this.ctx.textAlign = 'center';
      this.ctx.fillText(device.value.toFixed(1), x, y + size + 15);
    }
  }
  
  getDeviceColor(status) {
    switch (status) {
      case 'running': return '#00ff00';
      case 'stopped': return '#ff9900';
      case 'alarm': return '#ff0000';
      case 'offline': return '#808080';
      default: return '#cccccc';
    }
  }
  
  drawAlarmIndicator(x, y, size) {
    const time = Date.now() * 0.01;
    const alpha = Math.sin(time) * 0.5 + 0.5;
    
    this.ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
    this.ctx.beginPath();
    this.ctx.arc(x, y, size + 5, 0, Math.PI * 2);
    this.ctx.fill();
  }
}
```

---

## ğŸ”— é›†æˆåˆ°ç°æœ‰é¡¹ç›®

### åœ¨ app.js ä¸­æ·»åŠ 3Dè·¯ç”±
```javascript
// åœ¨ç°æœ‰è·¯ç”±åæ·»åŠ 
const visualization3D = require('./routes/3d-visualization');
app.use('/api/3d', visualization3D);

// 3Då¤§å±é¡µé¢è·¯ç”±
app.get('/3d-dashboard', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', '3d-dashboard.html'));
});
```

### WebSocket æ‰©å±•
```javascript
// åœ¨ç°æœ‰ WebSocket å¤„ç†ä¸­æ·»åŠ 
ws.on('message', (message) => {
  try {
    const data = JSON.parse(message);
    
    // ç°æœ‰å¤„ç†é€»è¾‘...
    
    // æ–°å¢3Dåœºæ™¯æ•°æ®æ¨é€
    if (data.type === '3d-scene-request') {
      // å‘é€åœºæ™¯é…ç½®æ•°æ®
      ws.send(JSON.stringify({
        type: '3d-scene-config',
        data: require('./config/3d-config').deviceLayout
      }));
    }
  } catch (error) {
    console.error('WebSocketæ¶ˆæ¯å¤„ç†é”™è¯¯:', error);
  }
});
```

---

## ğŸ“‹ å¼€å‘æ£€æŸ¥è¦ç‚¹

### å…³é”®æ€§èƒ½æŒ‡æ ‡
- **å¸§ç‡ç›‘æ§**ï¼šç›®æ ‡30FPSï¼Œæœ€ä½20FPS
- **å†…å­˜ä½¿ç”¨**ï¼šä¸è¶…è¿‡500MB
- **GPUä½¿ç”¨ç‡**ï¼šä½ç«¯è®¾å¤‡<60%
- **ç½‘ç»œæµé‡**ï¼šWebSocketæ¶ˆæ¯<10KB/s

### å…¼å®¹æ€§æµ‹è¯•æ¸…å•
- [ ] Chrome 80+ (ä¸»è¦æµè§ˆå™¨)
- [ ] Firefox 75+ 
- [ ] Edge 80+
- [ ] é›†æˆæ˜¾å¡è®¾å¤‡æµ‹è¯•
- [ ] 4GBå†…å­˜è®¾å¤‡æµ‹è¯•
- [ ] ç§»åŠ¨è®¾å¤‡å“åº”å¼æµ‹è¯•

### è°ƒè¯•å·¥å…·é›†æˆ
```javascript
// å¼€å‘æ¨¡å¼è°ƒè¯•é¢æ¿
if (process.env.NODE_ENV === 'development') {
  const gui = new dat.GUI();
  gui.add(renderer, 'currentMode', ['high', 'medium', 'low', 'fallback']);
  gui.add(config.rendering, 'targetFPS', 15, 60);
  gui.add(scene, 'visible');
}
```

---

**è¿™ä¸ªæŠ€æœ¯å®ç°æŒ‡å—æä¾›äº†3Då¯è§†åŒ–ç³»ç»Ÿçš„æ ¸å¿ƒä»£ç æ¡†æ¶ï¼Œå¼€å‘å›¢é˜Ÿå¯ä»¥åŸºäºè¿™äº›ä»£ç æ¨¡æ¿è¿›è¡Œå…·ä½“å®ç°å’Œå®šåˆ¶åŒ–å¼€å‘ã€‚** 